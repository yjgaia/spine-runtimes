<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>spine-threejs 1000 Swordsmen</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }

      body,
      html {
        height: 100%;
        background: #333;
      }

      canvas {
        position: absolute;
        width: 100%;
        height: 100%;
      }

      /* Simple overlay for FPS display */
      #fpsCounter {
        color: #fff;
        position: fixed;
        top: 10px;
        left: 10px;
        font: 14px Arial, sans-serif;
        background: rgba(0, 0, 0, 0.4);
        padding: 4px 8px;
        border-radius: 4px;
      }
    </style>

    <!-- Import map for modules (spine-threejs, three, etc.) -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/",
        "spine-threejs": "../dist/esm/spine-threejs.mjs"
      }
    }
    </script>
  </head>

  <body>
    <!-- DOM overlay for FPS -->
    <div id="fpsCounter">FPS: 0</div>

    <script type="module">
      import * as THREE from "three";
      import * as spine from "spine-threejs";
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

      let scene, camera, renderer, canvas, controls;
      let assetManager;
      let skeletonData; // We'll reuse the loaded skeleton data
      const skeletonMeshes = []; // Array to store 1,000 swordsman SkeletonMesh
      const NUM_SKELETONS = 100;

      // File paths for the swordsman skeleton (adjust if needed)
      const baseUrl = "assets/";
      const skeletonFile = "swordsman.json";
      const atlasFile = skeletonFile
        .replace("-pro", "")
        .replace("-ess", "")
        .replace(".json", ".atlas");
      const animationName = "walk"; // Which animation to play

      // For measuring FPS
      let lastFrameTime = Date.now() / 1000;

      function init() {
        // Basic Three.js setup
        const width = window.innerWidth;
        const height = window.innerHeight;

        camera = new THREE.PerspectiveCamera(75, width / height, 1, 3000);
        camera.position.set(0, 100, 400);

        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);
        canvas = renderer.domElement;

        controls = new OrbitControls(camera, renderer.domElement);

        // Spine asset loading
        assetManager = new spine.AssetManager(baseUrl);
        assetManager.loadText(skeletonFile);
        assetManager.loadTextureAtlas(atlasFile);

        // Start the loading check
        requestAnimationFrame(loadAssets);
      }

      function loadAssets() {
        // Check if all assets are loaded
        if (assetManager.isLoadingComplete()) {
          // Parse the skeleton data once, then clone for multiple instances
          skeletonData = createSkeletonData();

          // Create 1000 skeletons
          createMultipleSkeletons(NUM_SKELETONS);

          // Begin the render loop
          requestAnimationFrame(render);
        } else {
          requestAnimationFrame(loadAssets);
        }
      }

      /**
       * Creates the skeleton data (SkeletonJson -> SkeletonData).
       */
      function createSkeletonData() {
        const atlas = assetManager.require(atlasFile);
        const atlasLoader = new spine.AtlasAttachmentLoader(atlas);
        const skeletonJson = new spine.SkeletonJson(atlasLoader);

        // Adjust scale as needed
        skeletonJson.scale = 0.4;

        // Parse the skeleton JSON
        const rawSkeletonData = assetManager.require(skeletonFile);
        return skeletonJson.readSkeletonData(rawSkeletonData);
      }

      /**
       * Instantiates multiple SkeletonMesh objects from the loaded skeletonData.
       * @param {number} count Number of skeleton meshes to create
       */
      function createMultipleSkeletons(count) {
        for (let i = 0; i < count; i++) {
          // Create a SkeletonMesh
          const skeletonMesh = new spine.SkeletonMesh({ skeletonData });
          skeletonMesh.state.setAnimation(0, animationName, true);

          // Randomly position each skeleton in front of the camera
          // Adjust range or positions as desired
          const rangeX = 800; // how wide
          const rangeY = 400; // how tall
          skeletonMesh.position.x = (Math.random() - 0.5) * rangeX;
          skeletonMesh.position.y = (Math.random() - 0.5) * rangeY;
          // They can also be spread out in Z if you like
          // skeletonMesh.position.z = (Math.random() - 0.5) * 500;

          scene.add(skeletonMesh);
          skeletonMeshes.push(skeletonMesh);
        }
      }

      /**
       * Main render loop: updates animations, calculates FPS, and re-renders the scene.
       */
      function render() {
        // Calculate delta time
        const now = Date.now() / 1000;
        const delta = now - lastFrameTime;
        lastFrameTime = now;

        // Update FPS display
        const fps = (1 / delta).toFixed(1);
        console.log(`FPS: ${fps}`);

        // Resize if needed
        resize();

        // Update OrbitControls
        controls.update();

        // Update each skeleton's animation
        for (let i = 0; i < skeletonMeshes.length; i++) {
          skeletonMeshes[i].update(delta);
        }

        // Render the scene
        renderer.render(scene, camera);

        // Schedule next frame
        requestAnimationFrame(render);
      }

      function resize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
        }

        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      }

      init();
    </script>
  </body>
</html>
