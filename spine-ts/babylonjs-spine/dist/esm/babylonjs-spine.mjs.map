{
  "version": 3,
  "sources": ["../../src/require-shim.ts", "../../../spine-core/src/Utils.ts", "../../../spine-core/src/attachments/Attachment.ts", "../../../spine-core/src/attachments/Sequence.ts", "../../../spine-core/src/Animation.ts", "../../../spine-core/src/AnimationState.ts", "../../../spine-core/src/AnimationStateData.ts", "../../../spine-core/src/attachments/BoundingBoxAttachment.ts", "../../../spine-core/src/attachments/ClippingAttachment.ts", "../../../spine-core/src/Texture.ts", "../../../spine-core/src/TextureAtlas.ts", "../../../spine-core/src/attachments/MeshAttachment.ts", "../../../spine-core/src/attachments/PathAttachment.ts", "../../../spine-core/src/attachments/PointAttachment.ts", "../../../spine-core/src/attachments/RegionAttachment.ts", "../../../spine-core/src/AtlasAttachmentLoader.ts", "../../../spine-core/src/BoneData.ts", "../../../spine-core/src/Bone.ts", "../../../spine-core/src/ConstraintData.ts", "../../../spine-core/src/AssetManagerBase.ts", "../../../spine-core/src/Event.ts", "../../../spine-core/src/EventData.ts", "../../../spine-core/src/IkConstraint.ts", "../../../spine-core/src/IkConstraintData.ts", "../../../spine-core/src/PathConstraintData.ts", "../../../spine-core/src/PathConstraint.ts", "../../../spine-core/src/PhysicsConstraint.ts", "../../../spine-core/src/Slot.ts", "../../../spine-core/src/TransformConstraint.ts", "../../../spine-core/src/Skeleton.ts", "../../../spine-core/src/PhysicsConstraintData.ts", "../../../spine-core/src/SkeletonData.ts", "../../../spine-core/src/Skin.ts", "../../../spine-core/src/SlotData.ts", "../../../spine-core/src/TransformConstraintData.ts", "../../../spine-core/src/SkeletonBinary.ts", "../../../spine-core/src/SkeletonBounds.ts", "../../../spine-core/src/Triangulator.ts", "../../../spine-core/src/SkeletonClipping.ts", "../../../spine-core/src/SkeletonJson.ts", "../../../spine-core/src/polyfills.ts", "../../src/BabylonJsTexture.ts", "../../src/AssetManager.ts", "../../src/MeshBatcher.ts", "../../src/SkeletonMesh.ts"],
  "sourcesContent": ["declare global {\n\tvar require: any;\n\tvar BABYLON: any;\n}\n\nif (typeof window !== \"undefined\" && window.BABYLON) {\n\tconst prevRequire = window.require;\n\t(window as any).require = (x: string) => {\n\t\tif (prevRequire) return prevRequire(x);\n\t\telse if (x === \"babylonjs\") return window.BABYLON;\n\t};\n}\n\nexport {};\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Skeleton } from \"./Skeleton.js\";\nimport { MixBlend } from \"./Animation.js\";\n\nexport interface StringMap<T> {\n\t[key: string]: T;\n}\n\nexport class IntSet {\n\tarray = new Array<number | undefined>();\n\n\tadd (value: number): boolean {\n\t\tlet contains = this.contains(value);\n\t\tthis.array[value | 0] = value | 0;\n\t\treturn !contains;\n\t}\n\n\tcontains (value: number) {\n\t\treturn this.array[value | 0] != undefined;\n\t}\n\n\tremove (value: number) {\n\t\tthis.array[value | 0] = undefined;\n\t}\n\n\tclear () {\n\t\tthis.array.length = 0;\n\t}\n}\n\nexport class StringSet {\n\tentries: StringMap<boolean> = {};\n\tsize = 0;\n\n\tadd (value: string): boolean {\n\t\tlet contains = this.entries[value];\n\t\tthis.entries[value] = true;\n\t\tif (!contains) {\n\t\t\tthis.size++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\taddAll (values: string[]): boolean {\n\t\tlet oldSize = this.size;\n\t\tfor (var i = 0, n = values.length; i < n; i++)\n\t\t\tthis.add(values[i]);\n\t\treturn oldSize != this.size;\n\t}\n\n\tcontains (value: string) {\n\t\treturn this.entries[value];\n\t}\n\n\tclear () {\n\t\tthis.entries = {};\n\t\tthis.size = 0;\n\t}\n}\n\nexport type NumberArrayLike = Array<number> | Float32Array;\nexport type IntArrayLike = Array<number> | Int16Array;\n\nexport interface Disposable {\n\tdispose (): void;\n}\n\nexport interface Restorable {\n\trestore (): void;\n}\n\nexport class Color {\n\tpublic static WHITE = new Color(1, 1, 1, 1);\n\tpublic static RED = new Color(1, 0, 0, 1);\n\tpublic static GREEN = new Color(0, 1, 0, 1);\n\tpublic static BLUE = new Color(0, 0, 1, 1);\n\tpublic static MAGENTA = new Color(1, 0, 1, 1);\n\n\tconstructor (public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {\n\t}\n\n\tset (r: number, g: number, b: number, a: number) {\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\t\tthis.a = a;\n\t\treturn this.clamp();\n\t}\n\n\tsetFromColor (c: Color) {\n\t\tthis.r = c.r;\n\t\tthis.g = c.g;\n\t\tthis.b = c.b;\n\t\tthis.a = c.a;\n\t\treturn this;\n\t}\n\n\tsetFromString (hex: string) {\n\t\thex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n\t\tthis.r = parseInt(hex.substr(0, 2), 16) / 255;\n\t\tthis.g = parseInt(hex.substr(2, 2), 16) / 255;\n\t\tthis.b = parseInt(hex.substr(4, 2), 16) / 255;\n\t\tthis.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;\n\t\treturn this;\n\t}\n\n\tadd (r: number, g: number, b: number, a: number) {\n\t\tthis.r += r;\n\t\tthis.g += g;\n\t\tthis.b += b;\n\t\tthis.a += a;\n\t\treturn this.clamp();\n\t}\n\n\tclamp () {\n\t\tif (this.r < 0) this.r = 0;\n\t\telse if (this.r > 1) this.r = 1;\n\n\t\tif (this.g < 0) this.g = 0;\n\t\telse if (this.g > 1) this.g = 1;\n\n\t\tif (this.b < 0) this.b = 0;\n\t\telse if (this.b > 1) this.b = 1;\n\n\t\tif (this.a < 0) this.a = 0;\n\t\telse if (this.a > 1) this.a = 1;\n\t\treturn this;\n\t}\n\n\tstatic rgba8888ToColor (color: Color, value: number) {\n\t\tcolor.r = ((value & 0xff000000) >>> 24) / 255;\n\t\tcolor.g = ((value & 0x00ff0000) >>> 16) / 255;\n\t\tcolor.b = ((value & 0x0000ff00) >>> 8) / 255;\n\t\tcolor.a = ((value & 0x000000ff)) / 255;\n\t}\n\n\tstatic rgb888ToColor (color: Color, value: number) {\n\t\tcolor.r = ((value & 0x00ff0000) >>> 16) / 255;\n\t\tcolor.g = ((value & 0x0000ff00) >>> 8) / 255;\n\t\tcolor.b = ((value & 0x000000ff)) / 255;\n\t}\n\n\ttoRgb888 () {\n\t\tconst hex = (x: number) => (\"0\" + (x * 255).toString(16)).slice(-2);\n\t\treturn Number(\"0x\" + hex(this.r) + hex(this.g) + hex(this.b));\n\t}\n\n\tstatic fromString (hex: string): Color {\n\t\treturn new Color().setFromString(hex);\n\t}\n}\n\nexport class MathUtils {\n\tstatic PI = 3.1415927;\n\tstatic PI2 = MathUtils.PI * 2;\n\tstatic invPI2 = 1 / MathUtils.PI2;\n\tstatic radiansToDegrees = 180 / MathUtils.PI;\n\tstatic radDeg = MathUtils.radiansToDegrees;\n\tstatic degreesToRadians = MathUtils.PI / 180;\n\tstatic degRad = MathUtils.degreesToRadians;\n\n\tstatic clamp (value: number, min: number, max: number) {\n\t\tif (value < min) return min;\n\t\tif (value > max) return max;\n\t\treturn value;\n\t}\n\n\tstatic cosDeg (degrees: number) {\n\t\treturn Math.cos(degrees * MathUtils.degRad);\n\t}\n\n\tstatic sinDeg (degrees: number) {\n\t\treturn Math.sin(degrees * MathUtils.degRad);\n\t}\n\n\tstatic atan2Deg (y: number, x: number) {\n\t\treturn Math.atan2(y, x) * MathUtils.degRad;\n\t}\n\n\tstatic signum (value: number): number {\n\t\treturn value > 0 ? 1 : value < 0 ? -1 : 0;\n\t}\n\n\tstatic toInt (x: number) {\n\t\treturn x > 0 ? Math.floor(x) : Math.ceil(x);\n\t}\n\n\tstatic cbrt (x: number) {\n\t\tlet y = Math.pow(Math.abs(x), 1 / 3);\n\t\treturn x < 0 ? -y : y;\n\t}\n\n\tstatic randomTriangular (min: number, max: number): number {\n\t\treturn MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n\t}\n\n\tstatic randomTriangularWith (min: number, max: number, mode: number): number {\n\t\tlet u = Math.random();\n\t\tlet d = max - min;\n\t\tif (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\n\t\treturn max - Math.sqrt((1 - u) * d * (max - mode));\n\t}\n\n\tstatic isPowerOfTwo (value: number) {\n\t\treturn value && (value & (value - 1)) === 0;\n\t}\n}\n\nexport abstract class Interpolation {\n\tprotected abstract applyInternal (a: number): number;\n\tapply (start: number, end: number, a: number): number {\n\t\treturn start + (end - start) * this.applyInternal(a);\n\t}\n}\n\nexport class Pow extends Interpolation {\n\tprotected power = 2;\n\n\tconstructor (power: number) {\n\t\tsuper();\n\t\tthis.power = power;\n\t}\n\n\tapplyInternal (a: number): number {\n\t\tif (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\n\t\treturn Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n\t}\n}\n\nexport class PowOut extends Pow {\n\tconstructor (power: number) {\n\t\tsuper(power);\n\t}\n\n\tapplyInternal (a: number): number {\n\t\treturn Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n\t}\n}\n\nexport class Utils {\n\tstatic SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== \"undefined\";\n\n\tstatic arrayCopy<T> (source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\n\t\tfor (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n\t\t\tdest[j] = source[i];\n\t\t}\n\t}\n\n\tstatic arrayFill<T> (array: ArrayLike<T>, fromIndex: number, toIndex: number, value: T) {\n\t\tfor (let i = fromIndex; i < toIndex; i++)\n\t\t\tarray[i] = value;\n\t}\n\n\tstatic setArraySize<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\n\t\tlet oldSize = array.length;\n\t\tif (oldSize == size) return array;\n\t\tarray.length = size;\n\t\tif (oldSize < size) {\n\t\t\tfor (let i = oldSize; i < size; i++) array[i] = value;\n\t\t}\n\t\treturn array;\n\t}\n\n\tstatic ensureArrayCapacity<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\n\t\tif (array.length >= size) return array;\n\t\treturn Utils.setArraySize(array, size, value);\n\t}\n\n\tstatic newArray<T> (size: number, defaultValue: T): Array<T> {\n\t\tlet array = new Array<T>(size);\n\t\tfor (let i = 0; i < size; i++) array[i] = defaultValue;\n\t\treturn array;\n\t}\n\n\tstatic newFloatArray (size: number): NumberArrayLike {\n\t\tif (Utils.SUPPORTS_TYPED_ARRAYS)\n\t\t\treturn new Float32Array(size)\n\t\telse {\n\t\t\tlet array = new Array<number>(size);\n\t\t\tfor (let i = 0; i < array.length; i++) array[i] = 0;\n\t\t\treturn array;\n\t\t}\n\t}\n\n\tstatic newShortArray (size: number): IntArrayLike {\n\t\tif (Utils.SUPPORTS_TYPED_ARRAYS)\n\t\t\treturn new Int16Array(size)\n\t\telse {\n\t\t\tlet array = new Array<number>(size);\n\t\t\tfor (let i = 0; i < array.length; i++) array[i] = 0;\n\t\t\treturn array;\n\t\t}\n\t}\n\n\tstatic toFloatArray (array: Array<number>) {\n\t\treturn Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n\t}\n\n\tstatic toSinglePrecision (value: number) {\n\t\treturn Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\n\t}\n\n\t// This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n\tstatic webkit602BugfixHelper (alpha: number, blend: MixBlend) {\n\t}\n\n\tstatic contains<T> (array: Array<T>, element: T, identity = true) {\n\t\tfor (var i = 0; i < array.length; i++)\n\t\t\tif (array[i] == element) return true;\n\t\treturn false;\n\t}\n\n\tstatic enumValue (type: any, name: string) {\n\t\treturn type[name[0].toUpperCase() + name.slice(1)];\n\t}\n}\n\nexport class DebugUtils {\n\tstatic logBones (skeleton: Skeleton) {\n\t\tfor (let i = 0; i < skeleton.bones.length; i++) {\n\t\t\tlet bone = skeleton.bones[i];\n\t\t\tconsole.log(bone.data.name + \", \" + bone.a + \", \" + bone.b + \", \" + bone.c + \", \" + bone.d + \", \" + bone.worldX + \", \" + bone.worldY);\n\t\t}\n\t}\n}\n\nexport class Pool<T> {\n\tprivate items = new Array<T>();\n\tprivate instantiator: () => T;\n\n\tconstructor (instantiator: () => T) {\n\t\tthis.instantiator = instantiator;\n\t}\n\n\tobtain () {\n\t\treturn this.items.length > 0 ? this.items.pop()! : this.instantiator();\n\t}\n\n\tfree (item: T) {\n\t\tif ((item as any).reset) (item as any).reset();\n\t\tthis.items.push(item);\n\t}\n\n\tfreeAll (items: ArrayLike<T>) {\n\t\tfor (let i = 0; i < items.length; i++)\n\t\t\tthis.free(items[i]);\n\t}\n\n\tclear () {\n\t\tthis.items.length = 0;\n\t}\n}\n\nexport class Vector2 {\n\tconstructor (public x = 0, public y = 0) {\n\t}\n\n\tset (x: number, y: number): Vector2 {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t}\n\n\tlength () {\n\t\tlet x = this.x;\n\t\tlet y = this.y;\n\t\treturn Math.sqrt(x * x + y * y);\n\t}\n\n\tnormalize () {\n\t\tlet len = this.length();\n\t\tif (len != 0) {\n\t\t\tthis.x /= len;\n\t\t\tthis.y /= len;\n\t\t}\n\t\treturn this;\n\t}\n}\n\nexport class TimeKeeper {\n\tmaxDelta = 0.064;\n\tframesPerSecond = 0;\n\tdelta = 0;\n\ttotalTime = 0;\n\n\tprivate lastTime = Date.now() / 1000;\n\tprivate frameCount = 0;\n\tprivate frameTime = 0;\n\n\tupdate () {\n\t\tlet now = Date.now() / 1000;\n\t\tthis.delta = now - this.lastTime;\n\t\tthis.frameTime += this.delta;\n\t\tthis.totalTime += this.delta;\n\t\tif (this.delta > this.maxDelta) this.delta = this.maxDelta;\n\t\tthis.lastTime = now;\n\n\t\tthis.frameCount++;\n\t\tif (this.frameTime > 1) {\n\t\t\tthis.framesPerSecond = this.frameCount / this.frameTime;\n\t\t\tthis.frameTime = 0;\n\t\t\tthis.frameCount = 0;\n\t\t}\n\t}\n}\n\nexport interface ArrayLike<T> {\n\tlength: number;\n\t[n: number]: T;\n}\n\nexport class WindowedMean {\n\tvalues: Array<number>;\n\taddedValues = 0;\n\tlastValue = 0;\n\tmean = 0;\n\tdirty = true;\n\n\tconstructor (windowSize: number = 32) {\n\t\tthis.values = new Array<number>(windowSize);\n\t}\n\n\thasEnoughData () {\n\t\treturn this.addedValues >= this.values.length;\n\t}\n\n\taddValue (value: number) {\n\t\tif (this.addedValues < this.values.length) this.addedValues++;\n\t\tthis.values[this.lastValue++] = value;\n\t\tif (this.lastValue > this.values.length - 1) this.lastValue = 0;\n\t\tthis.dirty = true;\n\t}\n\n\tgetMean () {\n\t\tif (this.hasEnoughData()) {\n\t\t\tif (this.dirty) {\n\t\t\t\tlet mean = 0;\n\t\t\t\tfor (let i = 0; i < this.values.length; i++)\n\t\t\t\t\tmean += this.values[i];\n\t\t\t\tthis.mean = mean / this.values.length;\n\t\t\t\tthis.dirty = false;\n\t\t\t}\n\t\t\treturn this.mean;\n\t\t}\n\t\treturn 0;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Slot } from \"../Slot.js\";\nimport { NumberArrayLike, Utils } from \"../Utils.js\";\n\n/** The base class for all attachments. */\nexport abstract class Attachment {\n\tname: string;\n\n\tconstructor (name: string) {\n\t\tif (!name) throw new Error(\"name cannot be null.\");\n\t\tthis.name = name;\n\t}\n\n\tabstract copy (): Attachment;\n}\n\n/** Base class for an attachment with vertices that are transformed by one or more bones and can be deformed by a slot's\n * {@link Slot#deform}. */\nexport abstract class VertexAttachment extends Attachment {\n\tprivate static nextID = 0;\n\n\t/** The unique ID for this attachment. */\n\tid = VertexAttachment.nextID++;\n\n\t/** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\n\t * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\n\t * if this attachment has no weights. */\n\tbones: Array<number> | null = null;\n\n\t/** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\n\t * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\n\t * each vertex. */\n\tvertices: NumberArrayLike = [];\n\n\t/** The maximum number of world vertex values that can be output by\n\t * {@link #computeWorldVertices()} using the `count` parameter. */\n\tworldVerticesLength = 0;\n\n\t/** Timelines for the timeline attachment are also applied to this attachment.\n\t * May be null if no attachment-specific timelines should be applied. */\n\ttimelineAttachment: Attachment = this;\n\n\tconstructor (name: string) {\n\t\tsuper(name);\n\t}\n\n\t/** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is\n\t * not empty, it is used to deform the vertices.\n\t *\n\t * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n\t * Runtimes Guide.\n\t * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\n\t * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\n\t * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\n\t *           `stride` / 2.\n\t * @param offset The `worldVertices` index to begin writing values.\n\t * @param stride The number of `worldVertices` entries between the value pairs written. */\n\tcomputeWorldVertices (slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\n\t\tcount = offset + (count >> 1) * stride;\n\t\tlet skeleton = slot.bone.skeleton;\n\t\tlet deformArray = slot.deform;\n\t\tlet vertices = this.vertices;\n\t\tlet bones = this.bones;\n\t\tif (!bones) {\n\t\t\tif (deformArray.length > 0) vertices = deformArray;\n\t\t\tlet bone = slot.bone;\n\t\t\tlet x = bone.worldX;\n\t\t\tlet y = bone.worldY;\n\t\t\tlet a = bone.a, b = bone.b, c = bone.c, d = bone.d;\n\t\t\tfor (let v = start, w = offset; w < count; v += 2, w += stride) {\n\t\t\t\tlet vx = vertices[v], vy = vertices[v + 1];\n\t\t\t\tworldVertices[w] = vx * a + vy * b + x;\n\t\t\t\tworldVertices[w + 1] = vx * c + vy * d + y;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlet v = 0, skip = 0;\n\t\tfor (let i = 0; i < start; i += 2) {\n\t\t\tlet n = bones[v];\n\t\t\tv += n + 1;\n\t\t\tskip += n;\n\t\t}\n\t\tlet skeletonBones = skeleton.bones;\n\t\tif (deformArray.length == 0) {\n\t\t\tfor (let w = offset, b = skip * 3; w < count; w += stride) {\n\t\t\t\tlet wx = 0, wy = 0;\n\t\t\t\tlet n = bones[v++];\n\t\t\t\tn += v;\n\t\t\t\tfor (; v < n; v++, b += 3) {\n\t\t\t\t\tlet bone = skeletonBones[bones[v]];\n\t\t\t\t\tlet vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\n\t\t\t\t\twx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\n\t\t\t\t\twy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\n\t\t\t\t}\n\t\t\t\tworldVertices[w] = wx;\n\t\t\t\tworldVertices[w + 1] = wy;\n\t\t\t}\n\t\t} else {\n\t\t\tlet deform = deformArray;\n\t\t\tfor (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n\t\t\t\tlet wx = 0, wy = 0;\n\t\t\t\tlet n = bones[v++];\n\t\t\t\tn += v;\n\t\t\t\tfor (; v < n; v++, b += 3, f += 2) {\n\t\t\t\t\tlet bone = skeletonBones[bones[v]];\n\t\t\t\t\tlet vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\n\t\t\t\t\twx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\n\t\t\t\t\twy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\n\t\t\t\t}\n\t\t\t\tworldVertices[w] = wx;\n\t\t\t\tworldVertices[w + 1] = wy;\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Does not copy id (generated) or name (set on construction). **/\n\tcopyTo (attachment: VertexAttachment) {\n\t\tif (this.bones) {\n\t\t\tattachment.bones = new Array<number>(this.bones.length);\n\t\t\tUtils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\n\t\t} else\n\t\t\tattachment.bones = null;\n\n\t\tif (this.vertices) {\n\t\t\tattachment.vertices = Utils.newFloatArray(this.vertices.length);\n\t\t\tUtils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\n\t\t}\n\n\t\tattachment.worldVerticesLength = this.worldVerticesLength;\n\t\tattachment.timelineAttachment = this.timelineAttachment;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { TextureRegion } from \"../Texture.js\";\nimport { Slot } from \"../Slot.js\";\nimport { HasTextureRegion } from \"./HasTextureRegion.js\";\nimport { Utils } from \"../Utils.js\";\n\n\nexport class Sequence {\n\tprivate static _nextID = 0;\n\n\tid = Sequence.nextID();\n\tregions: TextureRegion[];\n\tstart = 0;\n\tdigits = 0;\n\t/** The index of the region to show for the setup pose. */\n\tsetupIndex = 0;\n\n\tconstructor (count: number) {\n\t\tthis.regions = new Array<TextureRegion>(count);\n\t}\n\n\tcopy (): Sequence {\n\t\tlet copy = new Sequence(this.regions.length);\n\t\tUtils.arrayCopy(this.regions, 0, copy.regions, 0, this.regions.length);\n\t\tcopy.start = this.start;\n\t\tcopy.digits = this.digits;\n\t\tcopy.setupIndex = this.setupIndex;\n\t\treturn copy;\n\t}\n\n\tapply (slot: Slot, attachment: HasTextureRegion) {\n\t\tlet index = slot.sequenceIndex;\n\t\tif (index == -1) index = this.setupIndex;\n\t\tif (index >= this.regions.length) index = this.regions.length - 1;\n\t\tlet region = this.regions[index];\n\t\tif (attachment.region != region) {\n\t\t\tattachment.region = region;\n\t\t\tattachment.updateRegion();\n\t\t}\n\t}\n\n\tgetPath (basePath: string, index: number): string {\n\t\tlet result = basePath;\n\t\tlet frame = (this.start + index).toString();\n\t\tfor (let i = this.digits - frame.length; i > 0; i--)\n\t\t\tresult += \"0\";\n\t\tresult += frame;\n\t\treturn result;\n\t}\n\n\tprivate static nextID (): number {\n\t\treturn Sequence._nextID++;\n\t}\n}\n\nexport enum SequenceMode {\n\thold = 0,\n\tonce = 1,\n\tloop = 2,\n\tpingpong = 3,\n\tonceReverse = 4,\n\tloopReverse = 5,\n\tpingpongReverse = 6\n}\n\nexport const SequenceModeValues = [\n\tSequenceMode.hold,\n\tSequenceMode.once,\n\tSequenceMode.loop,\n\tSequenceMode.pingpong,\n\tSequenceMode.onceReverse,\n\tSequenceMode.loopReverse,\n\tSequenceMode.pingpongReverse\n];\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { VertexAttachment, Attachment } from \"./attachments/Attachment.js\";\nimport { IkConstraint } from \"./IkConstraint.js\";\nimport { PathConstraint } from \"./PathConstraint.js\";\nimport { Skeleton } from \"./Skeleton.js\";\nimport { Slot } from \"./Slot.js\";\nimport { TransformConstraint } from \"./TransformConstraint.js\";\nimport { StringSet, Utils, MathUtils, NumberArrayLike } from \"./Utils.js\";\nimport { Event } from \"./Event.js\";\nimport { HasTextureRegion } from \"./attachments/HasTextureRegion.js\";\nimport { SequenceMode, SequenceModeValues } from \"./attachments/Sequence.js\";\nimport { PhysicsConstraint } from \"./PhysicsConstraint.js\";\nimport { PhysicsConstraintData } from \"./PhysicsConstraintData.js\";\nimport { Inherit } from \"./BoneData.js\";\n\n/** A simple container for a list of timelines and a name. */\nexport class Animation {\n\t/** The animation's name, which is unique across all animations in the skeleton. */\n\tname: string;\n\ttimelines: Array<Timeline> = [];\n\ttimelineIds: StringSet = new StringSet();\n\n\t/** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\n\tduration: number;\n\n\tconstructor (name: string, timelines: Array<Timeline>, duration: number) {\n\t\tif (!name) throw new Error(\"name cannot be null.\");\n\t\tthis.name = name;\n\t\tthis.setTimelines(timelines);\n\t\tthis.duration = duration;\n\t}\n\n\tsetTimelines (timelines: Array<Timeline>) {\n\t\tif (!timelines) throw new Error(\"timelines cannot be null.\");\n\t\tthis.timelines = timelines;\n\t\tthis.timelineIds.clear();\n\t\tfor (var i = 0; i < timelines.length; i++)\n\t\t\tthis.timelineIds.addAll(timelines[i].getPropertyIds());\n\t}\n\n\thasTimeline (ids: string[]): boolean {\n\t\tfor (let i = 0; i < ids.length; i++)\n\t\t\tif (this.timelineIds.contains(ids[i])) return true;\n\t\treturn false;\n\t}\n\n\t/** Applies all the animation's timelines to the specified skeleton.\n\t *\n\t * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n\t * @param loop If true, the animation repeats after {@link #getDuration()}.\n\t * @param events May be null to ignore fired events. */\n\tapply (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tif (!skeleton) throw new Error(\"skeleton cannot be null.\");\n\n\t\tif (loop && this.duration != 0) {\n\t\t\ttime %= this.duration;\n\t\t\tif (lastTime > 0) lastTime %= this.duration;\n\t\t}\n\n\t\tlet timelines = this.timelines;\n\t\tfor (let i = 0, n = timelines.length; i < n; i++)\n\t\t\ttimelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n\t}\n}\n\n/** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\n * < 1.\n *\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}. */\nexport enum MixBlend {\n\t/** Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup\n\t * value is set. */\n\tsetup,\n\t/** Transitions from the current value to the timeline value. Before the first key, transitions from the current value to\n\t * the setup value. Timelines which perform instant transitions, such as {@link DrawOrderTimeline} or\n\t * {@link AttachmentTimeline}, use the setup value before the first key.\n\t *\n\t * `first` is intended for the first animations applied, not for animations layered on top of those. */\n\tfirst,\n\t/** Transitions from the current value to the timeline value. No change is made before the first key (the current value is\n\t * kept until the first key).\n\t *\n\t * `replace` is intended for animations layered on top of others, not for the first animations applied. */\n\treplace,\n\t/** Transitions from the current value to the current value plus the timeline value. No change is made before the first key\n\t * (the current value is kept until the first key).\n\t *\n\t * `add` is intended for animations layered on top of others, not for the first animations applied. Properties\n\t * keyed by additive animations must be set manually or by another animation before applying the additive animations, else\n\t * the property values will increase continually. */\n\tadd\n}\n\n/** Indicates whether a timeline's `alpha` is mixing out over time toward 0 (the setup or current pose value) or\n * mixing in toward 1 (the timeline's value).\n *\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}. */\nexport enum MixDirection {\n\tmixIn, mixOut\n}\n\nconst Property = {\n\trotate: 0,\n\tx: 1,\n\ty: 2,\n\tscaleX: 3,\n\tscaleY: 4,\n\tshearX: 5,\n\tshearY: 6,\n\tinherit: 7,\n\n\trgb: 8,\n\talpha: 9,\n\trgb2: 10,\n\n\tattachment: 11,\n\tdeform: 12,\n\n\tevent: 13,\n\tdrawOrder: 14,\n\n\tikConstraint: 15,\n\ttransformConstraint: 16,\n\n\tpathConstraintPosition: 17,\n\tpathConstraintSpacing: 18,\n\tpathConstraintMix: 19,\n\n\tphysicsConstraintInertia: 20,\n\tphysicsConstraintStrength: 21,\n\tphysicsConstraintDamping: 22,\n\tphysicsConstraintMass: 23,\n\tphysicsConstraintWind: 24,\n\tphysicsConstraintGravity: 25,\n\tphysicsConstraintMix: 26,\n\tphysicsConstraintReset: 27,\n\n\tsequence: 28,\n}\n\n/** The interface for all timelines. */\nexport abstract class Timeline {\n\tpropertyIds: string[];\n\tframes: NumberArrayLike;\n\n\tconstructor (frameCount: number, propertyIds: string[]) {\n\t\tthis.propertyIds = propertyIds;\n\t\tthis.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());\n\t}\n\n\tgetPropertyIds () {\n\t\treturn this.propertyIds;\n\t}\n\n\tgetFrameEntries (): number {\n\t\treturn 1;\n\t}\n\n\tgetFrameCount () {\n\t\treturn this.frames.length / this.getFrameEntries();\n\t}\n\n\tgetDuration (): number {\n\t\treturn this.frames[this.frames.length - this.getFrameEntries()];\n\t}\n\n\tabstract apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event> | null, alpha: number, blend: MixBlend, direction: MixDirection): void;\n\n\tstatic search1 (frames: NumberArrayLike, time: number) {\n\t\tlet n = frames.length;\n\t\tfor (let i = 1; i < n; i++)\n\t\t\tif (frames[i] > time) return i - 1;\n\t\treturn n - 1;\n\t}\n\n\tstatic search (frames: NumberArrayLike, time: number, step: number) {\n\t\tlet n = frames.length;\n\t\tfor (let i = step; i < n; i += step)\n\t\t\tif (frames[i] > time) return i - step;\n\t\treturn n - step;\n\t}\n}\n\nexport interface BoneTimeline {\n\t/** The index of the bone in {@link Skeleton#bones} that will be changed. */\n\tboneIndex: number;\n}\n\nexport interface SlotTimeline {\n\t/** The index of the slot in {@link Skeleton#slots} that will be changed. */\n\tslotIndex: number;\n}\n\n/** The base class for timelines that use interpolation between key frame values. */\nexport abstract class CurveTimeline extends Timeline {\n\tprotected curves: NumberArrayLike; // type, x, y, ...\n\n\tconstructor (frameCount: number, bezierCount: number, propertyIds: string[]) {\n\t\tsuper(frameCount, propertyIds);\n\t\tthis.curves = Utils.newFloatArray(frameCount + bezierCount * 18/*BEZIER_SIZE*/);\n\t\tthis.curves[frameCount - 1] = 1/*STEPPED*/;\n\t}\n\n\t/** Sets the specified key frame to linear interpolation. */\n\tsetLinear (frame: number) {\n\t\tthis.curves[frame] = 0/*LINEAR*/;\n\t}\n\n\t/** Sets the specified key frame to stepped interpolation. */\n\tsetStepped (frame: number) {\n\t\tthis.curves[frame] = 1/*STEPPED*/;\n\t}\n\n\t/** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger\n\t * than the actual number of Bezier curves. */\n\tshrink (bezierCount: number) {\n\t\tlet size = this.getFrameCount() + bezierCount * 18/*BEZIER_SIZE*/;\n\t\tif (this.curves.length > size) {\n\t\t\tlet newCurves = Utils.newFloatArray(size);\n\t\t\tUtils.arrayCopy(this.curves, 0, newCurves, 0, size);\n\t\t\tthis.curves = newCurves;\n\t\t}\n\t}\n\n\t/** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than\n\t * one curve per frame.\n\t * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified\n\t *           in the constructor), inclusive.\n\t * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.\n\t * @param value The index of the value for this frame that this curve is used for.\n\t * @param time1 The time for the first key.\n\t * @param value1 The value for the first key.\n\t * @param cx1 The time for the first Bezier handle.\n\t * @param cy1 The value for the first Bezier handle.\n\t * @param cx2 The time of the second Bezier handle.\n\t * @param cy2 The value for the second Bezier handle.\n\t * @param time2 The time for the second key.\n\t * @param value2 The value for the second key. */\n\tsetBezier (bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number,\n\t\tcy2: number, time2: number, value2: number) {\n\t\tlet curves = this.curves;\n\t\tlet i = this.getFrameCount() + bezier * 18/*BEZIER_SIZE*/;\n\t\tif (value == 0) curves[frame] = 2/*BEZIER*/ + i;\n\t\tlet tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = (value1 - cy1 * 2 + cy2) * 0.03;\n\t\tlet dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006, dddy = ((cy1 - cy2) * 3 - value1 + value2) * 0.006;\n\t\tlet ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;\n\t\tlet dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667, dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;\n\t\tlet x = time1 + dx, y = value1 + dy;\n\t\tfor (let n = i + 18/*BEZIER_SIZE*/; i < n; i += 2) {\n\t\t\tcurves[i] = x;\n\t\t\tcurves[i + 1] = y;\n\t\t\tdx += ddx;\n\t\t\tdy += ddy;\n\t\t\tddx += dddx;\n\t\t\tddy += dddy;\n\t\t\tx += dx;\n\t\t\ty += dy;\n\t\t}\n\t}\n\n\t/** Returns the Bezier interpolated value for the specified time.\n\t * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.\n\t * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.\n\t * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */\n\tgetBezierValue (time: number, frameIndex: number, valueOffset: number, i: number) {\n\t\tlet curves = this.curves;\n\t\tif (curves[i] > time) {\n\t\t\tlet x = this.frames[frameIndex], y = this.frames[frameIndex + valueOffset];\n\t\t\treturn y + (time - x) / (curves[i] - x) * (curves[i + 1] - y);\n\t\t}\n\t\tlet n = i + 18/*BEZIER_SIZE*/;\n\t\tfor (i += 2; i < n; i += 2) {\n\t\t\tif (curves[i] >= time) {\n\t\t\t\tlet x = curves[i - 2], y = curves[i - 1];\n\t\t\t\treturn y + (time - x) / (curves[i] - x) * (curves[i + 1] - y);\n\t\t\t}\n\t\t}\n\t\tframeIndex += this.getFrameEntries();\n\t\tlet x = curves[n - 2], y = curves[n - 1];\n\t\treturn y + (time - x) / (this.frames[frameIndex] - x) * (this.frames[frameIndex + valueOffset] - y);\n\t}\n}\n\nexport abstract class CurveTimeline1 extends CurveTimeline {\n\tconstructor (frameCount: number, bezierCount: number, propertyId: string) {\n\t\tsuper(frameCount, bezierCount, [propertyId]);\n\t}\n\n\tgetFrameEntries () {\n\t\treturn 2/*ENTRIES*/;\n\t}\n\n\t/** Sets the time and value for the specified frame.\n\t * @param frame Between 0 and <code>frameCount</code>, inclusive.\n\t * @param time The frame time in seconds. */\n\tsetFrame (frame: number, time: number, value: number) {\n\t\tframe <<= 1;\n\t\tthis.frames[frame] = time;\n\t\tthis.frames[frame + 1/*VALUE*/] = value;\n\t}\n\n\t/** Returns the interpolated value for the specified time. */\n\tgetCurveValue (time: number) {\n\t\tlet frames = this.frames;\n\t\tlet i = frames.length - 2;\n\t\tfor (let ii = 2; ii <= i; ii += 2) {\n\t\t\tif (frames[ii] > time) {\n\t\t\t\ti = ii - 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlet curveType = this.curves[i >> 1];\n\t\tswitch (curveType) {\n\t\t\tcase 0/*LINEAR*/:\n\t\t\t\tlet before = frames[i], value = frames[i + 1/*VALUE*/];\n\t\t\t\treturn value + (time - before) / (frames[i + 2/*ENTRIES*/] - before) * (frames[i + 2/*ENTRIES*/ + 1/*VALUE*/] - value);\n\t\t\tcase 1/*STEPPED*/:\n\t\t\t\treturn frames[i + 1/*VALUE*/];\n\t\t}\n\t\treturn this.getBezierValue(time, i, 1/*VALUE*/, curveType - 2/*BEZIER*/);\n\t}\n\n\tgetRelativeValue (time: number, alpha: number, blend: MixBlend, current: number, setup: number) {\n\t\tif (time < this.frames[0]) {\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\treturn setup;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\treturn current + (setup - current) * alpha;\n\t\t\t}\n\t\t\treturn current;\n\t\t}\n\t\tlet value = this.getCurveValue(time);\n\t\tswitch (blend) {\n\t\t\tcase MixBlend.setup:\n\t\t\t\treturn setup + value * alpha;\n\t\t\tcase MixBlend.first:\n\t\t\tcase MixBlend.replace:\n\t\t\t\tvalue += setup - current;\n\t\t}\n\t\treturn current + value * alpha;\n\t}\n\n\tgetAbsoluteValue (time: number, alpha: number, blend: MixBlend, current: number, setup: number) {\n\t\tif (time < this.frames[0]) {\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\treturn setup;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\treturn current + (setup - current) * alpha;\n\t\t\t}\n\t\t\treturn current;\n\t\t}\n\t\tlet value = this.getCurveValue(time);\n\t\tif (blend == MixBlend.setup) return setup + (value - setup) * alpha;\n\t\treturn current + (value - current) * alpha;\n\t}\n\n\tgetAbsoluteValue2 (time: number, alpha: number, blend: MixBlend, current: number, setup: number, value: number) {\n\t\tif (time < this.frames[0]) {\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\treturn setup;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\treturn current + (setup - current) * alpha;\n\t\t\t}\n\t\t\treturn current;\n\t\t}\n\t\tif (blend == MixBlend.setup) return setup + (value - setup) * alpha;\n\t\treturn current + (value - current) * alpha;\n\t}\n\n\tgetScaleValue (time: number, alpha: number, blend: MixBlend, direction: MixDirection, current: number, setup: number) {\n\t\tconst frames = this.frames;\n\t\tif (time < frames[0]) {\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\treturn setup;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\treturn current + (setup - current) * alpha;\n\t\t\t}\n\t\t\treturn current;\n\t\t}\n\t\tlet value = this.getCurveValue(time) * setup;\n\t\tif (alpha == 1) {\n\t\t\tif (blend == MixBlend.add) return current + value - setup;\n\t\t\treturn value;\n\t\t}\n\t\t// Mixing out uses sign of setup or current pose, else use sign of key.\n\t\tif (direction == MixDirection.mixOut) {\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\treturn setup + (Math.abs(value) * MathUtils.signum(setup) - setup) * alpha;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\treturn current + (Math.abs(value) * MathUtils.signum(current) - current) * alpha;\n\t\t\t}\n\t\t} else {\n\t\t\tlet s = 0;\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\ts = Math.abs(setup) * MathUtils.signum(value);\n\t\t\t\t\treturn s + (value - s) * alpha;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\ts = Math.abs(current) * MathUtils.signum(value);\n\t\t\t\t\treturn s + (value - s) * alpha;\n\t\t\t}\n\t\t}\n\t\treturn current + (value - setup) * alpha;\n\t}\n}\n\n/** The base class for a {@link CurveTimeline} which sets two properties. */\nexport abstract class CurveTimeline2 extends CurveTimeline {\n\t/** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.\n\t * @param propertyIds Unique identifiers for the properties the timeline modifies. */\n\tconstructor (frameCount: number, bezierCount: number, propertyId1: string, propertyId2: string) {\n\t\tsuper(frameCount, bezierCount, [propertyId1, propertyId2]);\n\t}\n\n\tgetFrameEntries () {\n\t\treturn 3/*ENTRIES*/;\n\t}\n\n\t/** Sets the time and values for the specified frame.\n\t * @param frame Between 0 and <code>frameCount</code>, inclusive.\n\t * @param time The frame time in seconds. */\n\tsetFrame (frame: number, time: number, value1: number, value2: number) {\n\t\tframe *= 3/*ENTRIES*/;\n\t\tthis.frames[frame] = time;\n\t\tthis.frames[frame + 1/*VALUE1*/] = value1;\n\t\tthis.frames[frame + 2/*VALUE2*/] = value2;\n\t}\n}\n\n/** Changes a bone's local {@link Bone#rotation}. */\nexport class RotateTimeline extends CurveTimeline1 implements BoneTimeline {\n\tboneIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, boneIndex: number) {\n\t\tsuper(frameCount, bezierCount, Property.rotate + \"|\" + boneIndex);\n\t\tthis.boneIndex = boneIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event> | null, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet bone = skeleton.bones[this.boneIndex];\n\t\tif (bone.active) bone.rotation = this.getRelativeValue(time, alpha, blend, bone.rotation, bone.data.rotation);\n\t}\n}\n\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}. */\nexport class TranslateTimeline extends CurveTimeline2 implements BoneTimeline {\n\tboneIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, boneIndex: number) {\n\t\tsuper(frameCount, bezierCount,\n\t\t\tProperty.x + \"|\" + boneIndex,\n\t\t\tProperty.y + \"|\" + boneIndex,\n\t\t);\n\t\tthis.boneIndex = boneIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet bone = skeleton.bones[this.boneIndex];\n\t\tif (!bone.active) return;\n\n\t\tlet frames = this.frames;\n\t\tif (time < frames[0]) {\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tbone.x = bone.data.x;\n\t\t\t\t\tbone.y = bone.data.y;\n\t\t\t\t\treturn;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tbone.x += (bone.data.x - bone.x) * alpha;\n\t\t\t\t\tbone.y += (bone.data.y - bone.y) * alpha;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet x = 0, y = 0;\n\t\tlet i = Timeline.search(frames, time, 3/*ENTRIES*/);\n\t\tlet curveType = this.curves[i / 3/*ENTRIES*/];\n\t\tswitch (curveType) {\n\t\t\tcase 0/*LINEAR*/:\n\t\t\t\tlet before = frames[i];\n\t\t\t\tx = frames[i + 1/*VALUE1*/];\n\t\t\t\ty = frames[i + 2/*VALUE2*/];\n\t\t\t\tlet t = (time - before) / (frames[i + 3/*ENTRIES*/] - before);\n\t\t\t\tx += (frames[i + 3/*ENTRIES*/ + 1/*VALUE1*/] - x) * t;\n\t\t\t\ty += (frames[i + 3/*ENTRIES*/ + 2/*VALUE2*/] - y) * t;\n\t\t\t\tbreak;\n\t\t\tcase 1/*STEPPED*/:\n\t\t\t\tx = frames[i + 1/*VALUE1*/];\n\t\t\t\ty = frames[i + 2/*VALUE2*/];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tx = this.getBezierValue(time, i, 1/*VALUE1*/, curveType - 2/*BEZIER*/);\n\t\t\t\ty = this.getBezierValue(time, i, 2/*VALUE2*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\n\t\t}\n\n\t\tswitch (blend) {\n\t\t\tcase MixBlend.setup:\n\t\t\t\tbone.x = bone.data.x + x * alpha;\n\t\t\t\tbone.y = bone.data.y + y * alpha;\n\t\t\t\tbreak;\n\t\t\tcase MixBlend.first:\n\t\t\tcase MixBlend.replace:\n\t\t\t\tbone.x += (bone.data.x + x - bone.x) * alpha;\n\t\t\t\tbone.y += (bone.data.y + y - bone.y) * alpha;\n\t\t\t\tbreak;\n\t\t\tcase MixBlend.add:\n\t\t\t\tbone.x += x * alpha;\n\t\t\t\tbone.y += y * alpha;\n\t\t}\n\t}\n}\n\n/** Changes a bone's local {@link Bone#x}. */\nexport class TranslateXTimeline extends CurveTimeline1 implements BoneTimeline {\n\tboneIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, boneIndex: number) {\n\t\tsuper(frameCount, bezierCount, Property.x + \"|\" + boneIndex);\n\t\tthis.boneIndex = boneIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet bone = skeleton.bones[this.boneIndex];\n\t\tif (bone.active) bone.x = this.getRelativeValue(time, alpha, blend, bone.x, bone.data.x);\n\t}\n}\n\n/** Changes a bone's local {@link Bone#x}. */\nexport class TranslateYTimeline extends CurveTimeline1 implements BoneTimeline {\n\tboneIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, boneIndex: number) {\n\t\tsuper(frameCount, bezierCount, Property.y + \"|\" + boneIndex);\n\t\tthis.boneIndex = boneIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet bone = skeleton.bones[this.boneIndex];\n\t\tif (bone.active) bone.y = this.getRelativeValue(time, alpha, blend, bone.y, bone.data.y);\n\t}\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}. */\nexport class ScaleTimeline extends CurveTimeline2 implements BoneTimeline {\n\tboneIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, boneIndex: number) {\n\t\tsuper(frameCount, bezierCount,\n\t\t\tProperty.scaleX + \"|\" + boneIndex,\n\t\t\tProperty.scaleY + \"|\" + boneIndex\n\t\t);\n\t\tthis.boneIndex = boneIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet bone = skeleton.bones[this.boneIndex];\n\t\tif (!bone.active) return;\n\n\t\tlet frames = this.frames;\n\t\tif (time < frames[0]) {\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tbone.scaleX = bone.data.scaleX;\n\t\t\t\t\tbone.scaleY = bone.data.scaleY;\n\t\t\t\t\treturn;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tbone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n\t\t\t\t\tbone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet x, y;\n\t\tlet i = Timeline.search(frames, time, 3/*ENTRIES*/);\n\t\tlet curveType = this.curves[i / 3/*ENTRIES*/];\n\t\tswitch (curveType) {\n\t\t\tcase 0/*LINEAR*/:\n\t\t\t\tlet before = frames[i];\n\t\t\t\tx = frames[i + 1/*VALUE1*/];\n\t\t\t\ty = frames[i + 2/*VALUE2*/];\n\t\t\t\tlet t = (time - before) / (frames[i + 3/*ENTRIES*/] - before);\n\t\t\t\tx += (frames[i + 3/*ENTRIES*/ + 1/*VALUE1*/] - x) * t;\n\t\t\t\ty += (frames[i + 3/*ENTRIES*/ + 2/*VALUE2*/] - y) * t;\n\t\t\t\tbreak;\n\t\t\tcase 1/*STEPPED*/:\n\t\t\t\tx = frames[i + 1/*VALUE1*/];\n\t\t\t\ty = frames[i + 2/*VALUE2*/];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tx = this.getBezierValue(time, i, 1/*VALUE1*/, curveType - 2/*BEZIER*/);\n\t\t\t\ty = this.getBezierValue(time, i, 2/*VALUE2*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\n\t\t}\n\t\tx *= bone.data.scaleX;\n\t\ty *= bone.data.scaleY;\n\n\t\tif (alpha == 1) {\n\t\t\tif (blend == MixBlend.add) {\n\t\t\t\tbone.scaleX += x - bone.data.scaleX;\n\t\t\t\tbone.scaleY += y - bone.data.scaleY;\n\t\t\t} else {\n\t\t\t\tbone.scaleX = x;\n\t\t\t\tbone.scaleY = y;\n\t\t\t}\n\t\t} else {\n\t\t\tlet bx = 0, by = 0;\n\t\t\tif (direction == MixDirection.mixOut) {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tbx = bone.data.scaleX;\n\t\t\t\t\t\tby = bone.data.scaleY;\n\t\t\t\t\t\tbone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n\t\t\t\t\t\tbone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\t\tbx = bone.scaleX;\n\t\t\t\t\t\tby = bone.scaleY;\n\t\t\t\t\t\tbone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n\t\t\t\t\t\tbone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MixBlend.add:\n\t\t\t\t\t\tbone.scaleX += (x - bone.data.scaleX) * alpha;\n\t\t\t\t\t\tbone.scaleY += (y - bone.data.scaleY) * alpha;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tbx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n\t\t\t\t\t\tby = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n\t\t\t\t\t\tbone.scaleX = bx + (x - bx) * alpha;\n\t\t\t\t\t\tbone.scaleY = by + (y - by) * alpha;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\t\tbx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n\t\t\t\t\t\tby = Math.abs(bone.scaleY) * MathUtils.signum(y);\n\t\t\t\t\t\tbone.scaleX = bx + (x - bx) * alpha;\n\t\t\t\t\t\tbone.scaleY = by + (y - by) * alpha;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MixBlend.add:\n\t\t\t\t\t\tbone.scaleX += (x - bone.data.scaleX) * alpha;\n\t\t\t\t\t\tbone.scaleY += (y - bone.data.scaleY) * alpha;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}. */\nexport class ScaleXTimeline extends CurveTimeline1 implements BoneTimeline {\n\tboneIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, boneIndex: number) {\n\t\tsuper(frameCount, bezierCount, Property.scaleX + \"|\" + boneIndex);\n\t\tthis.boneIndex = boneIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet bone = skeleton.bones[this.boneIndex];\n\t\tif (bone.active) bone.scaleX = this.getScaleValue(time, alpha, blend, direction, bone.scaleX, bone.data.scaleX);\n\t}\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}. */\nexport class ScaleYTimeline extends CurveTimeline1 implements BoneTimeline {\n\tboneIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, boneIndex: number) {\n\t\tsuper(frameCount, bezierCount, Property.scaleY + \"|\" + boneIndex);\n\t\tthis.boneIndex = boneIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet bone = skeleton.bones[this.boneIndex];\n\t\tif (bone.active) bone.scaleY = this.getScaleValue(time, alpha, blend, direction, bone.scaleY, bone.data.scaleY);\n\t}\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\nexport class ShearTimeline extends CurveTimeline2 implements BoneTimeline {\n\tboneIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, boneIndex: number) {\n\t\tsuper(frameCount, bezierCount,\n\t\t\tProperty.shearX + \"|\" + boneIndex,\n\t\t\tProperty.shearY + \"|\" + boneIndex\n\t\t);\n\t\tthis.boneIndex = boneIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet bone = skeleton.bones[this.boneIndex];\n\t\tif (!bone.active) return;\n\n\t\tlet frames = this.frames;\n\t\tif (time < frames[0]) {\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tbone.shearX = bone.data.shearX;\n\t\t\t\t\tbone.shearY = bone.data.shearY;\n\t\t\t\t\treturn;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tbone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n\t\t\t\t\tbone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet x = 0, y = 0;\n\t\tlet i = Timeline.search(frames, time, 3/*ENTRIES*/);\n\t\tlet curveType = this.curves[i / 3/*ENTRIES*/];\n\t\tswitch (curveType) {\n\t\t\tcase 0/*LINEAR*/:\n\t\t\t\tlet before = frames[i];\n\t\t\t\tx = frames[i + 1/*VALUE1*/];\n\t\t\t\ty = frames[i + 2/*VALUE2*/];\n\t\t\t\tlet t = (time - before) / (frames[i + 3/*ENTRIES*/] - before);\n\t\t\t\tx += (frames[i + 3/*ENTRIES*/ + 1/*VALUE1*/] - x) * t;\n\t\t\t\ty += (frames[i + 3/*ENTRIES*/ + 2/*VALUE2*/] - y) * t;\n\t\t\t\tbreak;\n\t\t\tcase 1/*STEPPED*/:\n\t\t\t\tx = frames[i + 1/*VALUE1*/];\n\t\t\t\ty = frames[i + 2/*VALUE2*/];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tx = this.getBezierValue(time, i, 1/*VALUE1*/, curveType - 2/*BEZIER*/);\n\t\t\t\ty = this.getBezierValue(time, i, 2/*VALUE2*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\n\t\t}\n\n\t\tswitch (blend) {\n\t\t\tcase MixBlend.setup:\n\t\t\t\tbone.shearX = bone.data.shearX + x * alpha;\n\t\t\t\tbone.shearY = bone.data.shearY + y * alpha;\n\t\t\t\tbreak;\n\t\t\tcase MixBlend.first:\n\t\t\tcase MixBlend.replace:\n\t\t\t\tbone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n\t\t\t\tbone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n\t\t\t\tbreak;\n\t\t\tcase MixBlend.add:\n\t\t\t\tbone.shearX += x * alpha;\n\t\t\t\tbone.shearY += y * alpha;\n\t\t}\n\t}\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\nexport class ShearXTimeline extends CurveTimeline1 implements BoneTimeline {\n\tboneIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, boneIndex: number) {\n\t\tsuper(frameCount, bezierCount, Property.shearX + \"|\" + boneIndex);\n\t\tthis.boneIndex = boneIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet bone = skeleton.bones[this.boneIndex];\n\t\tif (bone.active) bone.shearX = this.getRelativeValue(time, alpha, blend, bone.shearX, bone.data.shearX);\n\t}\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\nexport class ShearYTimeline extends CurveTimeline1 implements BoneTimeline {\n\tboneIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, boneIndex: number) {\n\t\tsuper(frameCount, bezierCount, Property.shearY + \"|\" + boneIndex);\n\t\tthis.boneIndex = boneIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet bone = skeleton.bones[this.boneIndex];\n\t\tif (bone.active) bone.shearY = this.getRelativeValue(time, alpha, blend, bone.shearY, bone.data.shearY);\n\t}\n}\n\nexport class InheritTimeline extends Timeline implements BoneTimeline {\n\tboneIndex = 0;\n\n\tconstructor (frameCount: number, boneIndex: number) {\n\t\tsuper(frameCount, [Property.inherit + \"|\" + boneIndex]);\n\t\tthis.boneIndex = boneIndex;\n\t}\n\n\tpublic getFrameEntries () {\n\t\treturn 2/*ENTRIES*/;\n\t}\n\n\t/** Sets the transform mode for the specified frame.\n\t * @param frame Between 0 and <code>frameCount</code>, inclusive.\n\t * @param time The frame time in seconds. */\n\tpublic setFrame (frame: number, time: number, inherit: Inherit) {\n\t\tframe *= 2/*ENTRIES*/;\n\t\tthis.frames[frame] = time;\n\t\tthis.frames[frame + 1/*INHERIT*/] = inherit;\n\t}\n\n\tpublic apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet bone = skeleton.bones[this.boneIndex];\n\t\tif (!bone.active) return;\n\n\t\tif (direction == MixDirection.mixOut) {\n\t\t\tif (blend == MixBlend.setup) bone.inherit = bone.data.inherit;\n\t\t\treturn;\n\t\t}\n\n\t\tlet frames = this.frames;\n\t\tif (time < frames[0]) {\n\t\t\tif (blend == MixBlend.setup || blend == MixBlend.first) bone.inherit = bone.data.inherit;\n\t\t\treturn;\n\t\t}\n\t\tbone.inherit = this.frames[Timeline.search(frames, time, 2/*ENTRIES*/) + 1/*INHERIT*/];\n\t}\n}\n\n/** Changes a slot's {@link Slot#color}. */\nexport class RGBATimeline extends CurveTimeline implements SlotTimeline {\n\tslotIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, slotIndex: number) {\n\t\tsuper(frameCount, bezierCount, [\n\t\t\tProperty.rgb + \"|\" + slotIndex,\n\t\t\tProperty.alpha + \"|\" + slotIndex\n\t\t]);\n\t\tthis.slotIndex = slotIndex;\n\t}\n\n\tgetFrameEntries () {\n\t\treturn 5/*ENTRIES*/;\n\t}\n\n\t/** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n\tsetFrame (frame: number, time: number, r: number, g: number, b: number, a: number) {\n\t\tframe *= 5/*ENTRIES*/;\n\t\tthis.frames[frame] = time;\n\t\tthis.frames[frame + 1/*R*/] = r;\n\t\tthis.frames[frame + 2/*G*/] = g;\n\t\tthis.frames[frame + 3/*B*/] = b;\n\t\tthis.frames[frame + 4/*A*/] = a;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet slot = skeleton.slots[this.slotIndex];\n\t\tif (!slot.bone.active) return;\n\n\t\tlet frames = this.frames;\n\t\tlet color = slot.color;\n\t\tif (time < frames[0]) {\n\t\t\tlet setup = slot.data.color;\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tcolor.setFromColor(setup);\n\t\t\t\t\treturn;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tcolor.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha,\n\t\t\t\t\t\t(setup.a - color.a) * alpha);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet r = 0, g = 0, b = 0, a = 0;\n\t\tlet i = Timeline.search(frames, time, 5/*ENTRIES*/);\n\t\tlet curveType = this.curves[i / 5/*ENTRIES*/];\n\t\tswitch (curveType) {\n\t\t\tcase 0/*LINEAR*/:\n\t\t\t\tlet before = frames[i];\n\t\t\t\tr = frames[i + 1/*R*/];\n\t\t\t\tg = frames[i + 2/*G*/];\n\t\t\t\tb = frames[i + 3/*B*/];\n\t\t\t\ta = frames[i + 4/*A*/];\n\t\t\t\tlet t = (time - before) / (frames[i + 5/*ENTRIES*/] - before);\n\t\t\t\tr += (frames[i + 5/*ENTRIES*/ + 1/*R*/] - r) * t;\n\t\t\t\tg += (frames[i + 5/*ENTRIES*/ + 2/*G*/] - g) * t;\n\t\t\t\tb += (frames[i + 5/*ENTRIES*/ + 3/*B*/] - b) * t;\n\t\t\t\ta += (frames[i + 5/*ENTRIES*/ + 4/*A*/] - a) * t;\n\t\t\t\tbreak;\n\t\t\tcase 1/*STEPPED*/:\n\t\t\t\tr = frames[i + 1/*R*/];\n\t\t\t\tg = frames[i + 2/*G*/];\n\t\t\t\tb = frames[i + 3/*B*/];\n\t\t\t\ta = frames[i + 4/*A*/];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr = this.getBezierValue(time, i, 1/*R*/, curveType - 2/*BEZIER*/);\n\t\t\t\tg = this.getBezierValue(time, i, 2/*G*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\n\t\t\t\tb = this.getBezierValue(time, i, 3/*B*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\n\t\t\t\ta = this.getBezierValue(time, i, 4/*A*/, curveType + 18/*BEZIER_SIZE*/ * 3 - 2/*BEZIER*/);\n\t\t}\n\t\tif (alpha == 1)\n\t\t\tcolor.set(r, g, b, a);\n\t\telse {\n\t\t\tif (blend == MixBlend.setup) color.setFromColor(slot.data.color);\n\t\t\tcolor.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n\t\t}\n\t}\n}\n\n/** Changes a slot's {@link Slot#color}. */\nexport class RGBTimeline extends CurveTimeline implements SlotTimeline {\n\tslotIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, slotIndex: number) {\n\t\tsuper(frameCount, bezierCount, [\n\t\t\tProperty.rgb + \"|\" + slotIndex\n\t\t]);\n\t\tthis.slotIndex = slotIndex;\n\t}\n\n\tgetFrameEntries () {\n\t\treturn 4/*ENTRIES*/;\n\t}\n\n\t/** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n\tsetFrame (frame: number, time: number, r: number, g: number, b: number) {\n\t\tframe <<= 2;\n\t\tthis.frames[frame] = time;\n\t\tthis.frames[frame + 1/*R*/] = r;\n\t\tthis.frames[frame + 2/*G*/] = g;\n\t\tthis.frames[frame + 3/*B*/] = b;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet slot = skeleton.slots[this.slotIndex];\n\t\tif (!slot.bone.active) return;\n\n\t\tlet frames = this.frames;\n\t\tlet color = slot.color;\n\t\tif (time < frames[0]) {\n\t\t\tlet setup = slot.data.color;\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tcolor.r = setup.r;\n\t\t\t\t\tcolor.g = setup.g;\n\t\t\t\t\tcolor.b = setup.b;\n\t\t\t\t\treturn;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tcolor.r += (setup.r - color.r) * alpha;\n\t\t\t\t\tcolor.g += (setup.g - color.g) * alpha;\n\t\t\t\t\tcolor.b += (setup.b - color.b) * alpha;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet r = 0, g = 0, b = 0;\n\t\tlet i = Timeline.search(frames, time, 4/*ENTRIES*/);\n\t\tlet curveType = this.curves[i >> 2];\n\t\tswitch (curveType) {\n\t\t\tcase 0/*LINEAR*/:\n\t\t\t\tlet before = frames[i];\n\t\t\t\tr = frames[i + 1/*R*/];\n\t\t\t\tg = frames[i + 2/*G*/];\n\t\t\t\tb = frames[i + 3/*B*/];\n\t\t\t\tlet t = (time - before) / (frames[i + 4/*ENTRIES*/] - before);\n\t\t\t\tr += (frames[i + 4/*ENTRIES*/ + 1/*R*/] - r) * t;\n\t\t\t\tg += (frames[i + 4/*ENTRIES*/ + 2/*G*/] - g) * t;\n\t\t\t\tb += (frames[i + 4/*ENTRIES*/ + 3/*B*/] - b) * t;\n\t\t\t\tbreak;\n\t\t\tcase 1/*STEPPED*/:\n\t\t\t\tr = frames[i + 1/*R*/];\n\t\t\t\tg = frames[i + 2/*G*/];\n\t\t\t\tb = frames[i + 3/*B*/];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr = this.getBezierValue(time, i, 1/*R*/, curveType - 2/*BEZIER*/);\n\t\t\t\tg = this.getBezierValue(time, i, 2/*G*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\n\t\t\t\tb = this.getBezierValue(time, i, 3/*B*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\n\t\t}\n\t\tif (alpha == 1) {\n\t\t\tcolor.r = r;\n\t\t\tcolor.g = g;\n\t\t\tcolor.b = b;\n\t\t} else {\n\t\t\tif (blend == MixBlend.setup) {\n\t\t\t\tlet setup = slot.data.color;\n\t\t\t\tcolor.r = setup.r;\n\t\t\t\tcolor.g = setup.g;\n\t\t\t\tcolor.b = setup.b;\n\t\t\t}\n\t\t\tcolor.r += (r - color.r) * alpha;\n\t\t\tcolor.g += (g - color.g) * alpha;\n\t\t\tcolor.b += (b - color.b) * alpha;\n\t\t}\n\t}\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\nexport class AlphaTimeline extends CurveTimeline1 implements SlotTimeline {\n\tslotIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, slotIndex: number) {\n\t\tsuper(frameCount, bezierCount, Property.alpha + \"|\" + slotIndex);\n\t\tthis.slotIndex = slotIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet slot = skeleton.slots[this.slotIndex];\n\t\tif (!slot.bone.active) return;\n\n\t\tlet color = slot.color;\n\t\tif (time < this.frames[0]) {\n\t\t\tlet setup = slot.data.color;\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tcolor.a = setup.a;\n\t\t\t\t\treturn;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tcolor.a += (setup.a - color.a) * alpha;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet a = this.getCurveValue(time);\n\t\tif (alpha == 1)\n\t\t\tcolor.a = a;\n\t\telse {\n\t\t\tif (blend == MixBlend.setup) color.a = slot.data.color.a;\n\t\t\tcolor.a += (a - color.a) * alpha;\n\t\t}\n\t}\n}\n\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting. */\nexport class RGBA2Timeline extends CurveTimeline implements SlotTimeline {\n\tslotIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, slotIndex: number) {\n\t\tsuper(frameCount, bezierCount, [\n\t\t\tProperty.rgb + \"|\" + slotIndex,\n\t\t\tProperty.alpha + \"|\" + slotIndex,\n\t\t\tProperty.rgb2 + \"|\" + slotIndex\n\t\t]);\n\t\tthis.slotIndex = slotIndex;\n\t}\n\n\tgetFrameEntries () {\n\t\treturn 8/*ENTRIES*/;\n\t}\n\n\t/** Sets the time in seconds, light, and dark colors for the specified key frame. */\n\tsetFrame (frame: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\n\t\tframe <<= 3;\n\t\tthis.frames[frame] = time;\n\t\tthis.frames[frame + 1/*R*/] = r;\n\t\tthis.frames[frame + 2/*G*/] = g;\n\t\tthis.frames[frame + 3/*B*/] = b;\n\t\tthis.frames[frame + 4/*A*/] = a;\n\t\tthis.frames[frame + 5/*R2*/] = r2;\n\t\tthis.frames[frame + 6/*G2*/] = g2;\n\t\tthis.frames[frame + 7/*B2*/] = b2;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet slot = skeleton.slots[this.slotIndex];\n\t\tif (!slot.bone.active) return;\n\n\t\tlet frames = this.frames;\n\t\tlet light = slot.color, dark = slot.darkColor!;\n\t\tif (time < frames[0]) {\n\t\t\tlet setupLight = slot.data.color, setupDark = slot.data.darkColor!;\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tlight.setFromColor(setupLight);\n\t\t\t\t\tdark.r = setupDark.r;\n\t\t\t\t\tdark.g = setupDark.g;\n\t\t\t\t\tdark.b = setupDark.b;\n\t\t\t\t\treturn;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tlight.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha,\n\t\t\t\t\t\t(setupLight.a - light.a) * alpha);\n\t\t\t\t\tdark.r += (setupDark.r - dark.r) * alpha;\n\t\t\t\t\tdark.g += (setupDark.g - dark.g) * alpha;\n\t\t\t\t\tdark.b += (setupDark.b - dark.b) * alpha;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\n\t\tlet i = Timeline.search(frames, time, 8/*ENTRIES*/);\n\t\tlet curveType = this.curves[i >> 3];\n\t\tswitch (curveType) {\n\t\t\tcase 0/*LINEAR*/:\n\t\t\t\tlet before = frames[i];\n\t\t\t\tr = frames[i + 1/*R*/];\n\t\t\t\tg = frames[i + 2/*G*/];\n\t\t\t\tb = frames[i + 3/*B*/];\n\t\t\t\ta = frames[i + 4/*A*/];\n\t\t\t\tr2 = frames[i + 5/*R2*/];\n\t\t\t\tg2 = frames[i + 6/*G2*/];\n\t\t\t\tb2 = frames[i + 7/*B2*/];\n\t\t\t\tlet t = (time - before) / (frames[i + 8/*ENTRIES*/] - before);\n\t\t\t\tr += (frames[i + 8/*ENTRIES*/ + 1/*R*/] - r) * t;\n\t\t\t\tg += (frames[i + 8/*ENTRIES*/ + 2/*G*/] - g) * t;\n\t\t\t\tb += (frames[i + 8/*ENTRIES*/ + 3/*B*/] - b) * t;\n\t\t\t\ta += (frames[i + 8/*ENTRIES*/ + 4/*A*/] - a) * t;\n\t\t\t\tr2 += (frames[i + 8/*ENTRIES*/ + 5/*R2*/] - r2) * t;\n\t\t\t\tg2 += (frames[i + 8/*ENTRIES*/ + 6/*G2*/] - g2) * t;\n\t\t\t\tb2 += (frames[i + 8/*ENTRIES*/ + 7/*B2*/] - b2) * t;\n\t\t\t\tbreak;\n\t\t\tcase 1/*STEPPED*/:\n\t\t\t\tr = frames[i + 1/*R*/];\n\t\t\t\tg = frames[i + 2/*G*/];\n\t\t\t\tb = frames[i + 3/*B*/];\n\t\t\t\ta = frames[i + 4/*A*/];\n\t\t\t\tr2 = frames[i + 5/*R2*/];\n\t\t\t\tg2 = frames[i + 6/*G2*/];\n\t\t\t\tb2 = frames[i + 7/*B2*/];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr = this.getBezierValue(time, i, 1/*R*/, curveType - 2/*BEZIER*/);\n\t\t\t\tg = this.getBezierValue(time, i, 2/*G*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\n\t\t\t\tb = this.getBezierValue(time, i, 3/*B*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\n\t\t\t\ta = this.getBezierValue(time, i, 4/*A*/, curveType + 18/*BEZIER_SIZE*/ * 3 - 2/*BEZIER*/);\n\t\t\t\tr2 = this.getBezierValue(time, i, 5/*R2*/, curveType + 18/*BEZIER_SIZE*/ * 4 - 2/*BEZIER*/);\n\t\t\t\tg2 = this.getBezierValue(time, i, 6/*G2*/, curveType + 18/*BEZIER_SIZE*/ * 5 - 2/*BEZIER*/);\n\t\t\t\tb2 = this.getBezierValue(time, i, 7/*B2*/, curveType + 18/*BEZIER_SIZE*/ * 6 - 2/*BEZIER*/);\n\t\t}\n\n\t\tif (alpha == 1) {\n\t\t\tlight.set(r, g, b, a);\n\t\t\tdark.r = r2;\n\t\t\tdark.g = g2;\n\t\t\tdark.b = b2;\n\t\t} else {\n\t\t\tif (blend == MixBlend.setup) {\n\t\t\t\tlight.setFromColor(slot.data.color);\n\t\t\t\tlet setupDark = slot.data.darkColor!;\n\t\t\t\tdark.r = setupDark.r;\n\t\t\t\tdark.g = setupDark.g;\n\t\t\t\tdark.b = setupDark.b;\n\t\t\t}\n\t\t\tlight.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n\t\t\tdark.r += (r2 - dark.r) * alpha;\n\t\t\tdark.g += (g2 - dark.g) * alpha;\n\t\t\tdark.b += (b2 - dark.b) * alpha;\n\t\t}\n\t}\n}\n\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting. */\nexport class RGB2Timeline extends CurveTimeline implements SlotTimeline {\n\tslotIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, slotIndex: number) {\n\t\tsuper(frameCount, bezierCount, [\n\t\t\tProperty.rgb + \"|\" + slotIndex,\n\t\t\tProperty.rgb2 + \"|\" + slotIndex\n\t\t]);\n\t\tthis.slotIndex = slotIndex;\n\t}\n\n\tgetFrameEntries () {\n\t\treturn 7/*ENTRIES*/;\n\t}\n\n\t/** Sets the time in seconds, light, and dark colors for the specified key frame. */\n\tsetFrame (frame: number, time: number, r: number, g: number, b: number, r2: number, g2: number, b2: number) {\n\t\tframe *= 7/*ENTRIES*/;\n\t\tthis.frames[frame] = time;\n\t\tthis.frames[frame + 1/*R*/] = r;\n\t\tthis.frames[frame + 2/*G*/] = g;\n\t\tthis.frames[frame + 3/*B*/] = b;\n\t\tthis.frames[frame + 4/*R2*/] = r2;\n\t\tthis.frames[frame + 5/*G2*/] = g2;\n\t\tthis.frames[frame + 6/*B2*/] = b2;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet slot = skeleton.slots[this.slotIndex];\n\t\tif (!slot.bone.active) return;\n\n\t\tlet frames = this.frames;\n\t\tlet light = slot.color, dark = slot.darkColor!;\n\t\tif (time < frames[0]) {\n\t\t\tlet setupLight = slot.data.color, setupDark = slot.data.darkColor!;\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tlight.r = setupLight.r;\n\t\t\t\t\tlight.g = setupLight.g;\n\t\t\t\t\tlight.b = setupLight.b;\n\t\t\t\t\tdark.r = setupDark.r;\n\t\t\t\t\tdark.g = setupDark.g;\n\t\t\t\t\tdark.b = setupDark.b;\n\t\t\t\t\treturn;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tlight.r += (setupLight.r - light.r) * alpha;\n\t\t\t\t\tlight.g += (setupLight.g - light.g) * alpha;\n\t\t\t\t\tlight.b += (setupLight.b - light.b) * alpha;\n\t\t\t\t\tdark.r += (setupDark.r - dark.r) * alpha;\n\t\t\t\t\tdark.g += (setupDark.g - dark.g) * alpha;\n\t\t\t\t\tdark.b += (setupDark.b - dark.b) * alpha;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\n\t\tlet i = Timeline.search(frames, time, 7/*ENTRIES*/);\n\t\tlet curveType = this.curves[i / 7/*ENTRIES*/];\n\t\tswitch (curveType) {\n\t\t\tcase 0/*LINEAR*/:\n\t\t\t\tlet before = frames[i];\n\t\t\t\tr = frames[i + 1/*R*/];\n\t\t\t\tg = frames[i + 2/*G*/];\n\t\t\t\tb = frames[i + 3/*B*/];\n\t\t\t\tr2 = frames[i + 4/*R2*/];\n\t\t\t\tg2 = frames[i + 5/*G2*/];\n\t\t\t\tb2 = frames[i + 6/*B2*/];\n\t\t\t\tlet t = (time - before) / (frames[i + 7/*ENTRIES*/] - before);\n\t\t\t\tr += (frames[i + 7/*ENTRIES*/ + 1/*R*/] - r) * t;\n\t\t\t\tg += (frames[i + 7/*ENTRIES*/ + 2/*G*/] - g) * t;\n\t\t\t\tb += (frames[i + 7/*ENTRIES*/ + 3/*B*/] - b) * t;\n\t\t\t\tr2 += (frames[i + 7/*ENTRIES*/ + 4/*R2*/] - r2) * t;\n\t\t\t\tg2 += (frames[i + 7/*ENTRIES*/ + 5/*G2*/] - g2) * t;\n\t\t\t\tb2 += (frames[i + 7/*ENTRIES*/ + 6/*B2*/] - b2) * t;\n\t\t\t\tbreak;\n\t\t\tcase 1/*STEPPED*/:\n\t\t\t\tr = frames[i + 1/*R*/];\n\t\t\t\tg = frames[i + 2/*G*/];\n\t\t\t\tb = frames[i + 3/*B*/];\n\t\t\t\tr2 = frames[i + 4/*R2*/];\n\t\t\t\tg2 = frames[i + 5/*G2*/];\n\t\t\t\tb2 = frames[i + 6/*B2*/];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr = this.getBezierValue(time, i, 1/*R*/, curveType - 2/*BEZIER*/);\n\t\t\t\tg = this.getBezierValue(time, i, 2/*G*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\n\t\t\t\tb = this.getBezierValue(time, i, 3/*B*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\n\t\t\t\tr2 = this.getBezierValue(time, i, 4/*R2*/, curveType + 18/*BEZIER_SIZE*/ * 3 - 2/*BEZIER*/);\n\t\t\t\tg2 = this.getBezierValue(time, i, 5/*G2*/, curveType + 18/*BEZIER_SIZE*/ * 4 - 2/*BEZIER*/);\n\t\t\t\tb2 = this.getBezierValue(time, i, 6/*B2*/, curveType + 18/*BEZIER_SIZE*/ * 5 - 2/*BEZIER*/);\n\t\t}\n\n\t\tif (alpha == 1) {\n\t\t\tlight.r = r;\n\t\t\tlight.g = g;\n\t\t\tlight.b = b;\n\t\t\tdark.r = r2;\n\t\t\tdark.g = g2;\n\t\t\tdark.b = b2;\n\t\t} else {\n\t\t\tif (blend == MixBlend.setup) {\n\t\t\t\tlet setupLight = slot.data.color, setupDark = slot.data.darkColor!;\n\t\t\t\tlight.r = setupLight.r;\n\t\t\t\tlight.g = setupLight.g;\n\t\t\t\tlight.b = setupLight.b;\n\t\t\t\tdark.r = setupDark.r;\n\t\t\t\tdark.g = setupDark.g;\n\t\t\t\tdark.b = setupDark.b;\n\t\t\t}\n\t\t\tlight.r += (r - light.r) * alpha;\n\t\t\tlight.g += (g - light.g) * alpha;\n\t\t\tlight.b += (b - light.b) * alpha;\n\t\t\tdark.r += (r2 - dark.r) * alpha;\n\t\t\tdark.g += (g2 - dark.g) * alpha;\n\t\t\tdark.b += (b2 - dark.b) * alpha;\n\t\t}\n\t}\n}\n\n/** Changes a slot's {@link Slot#attachment}. */\nexport class AttachmentTimeline extends Timeline implements SlotTimeline {\n\tslotIndex = 0;\n\n\t/** The attachment name for each key frame. May contain null values to clear the attachment. */\n\tattachmentNames: Array<string | null>;\n\n\tconstructor (frameCount: number, slotIndex: number) {\n\t\tsuper(frameCount, [\n\t\t\tProperty.attachment + \"|\" + slotIndex\n\t\t]);\n\t\tthis.slotIndex = slotIndex;\n\t\tthis.attachmentNames = new Array<string>(frameCount);\n\t}\n\n\tgetFrameCount () {\n\t\treturn this.frames.length;\n\t}\n\n\t/** Sets the time in seconds and the attachment name for the specified key frame. */\n\tsetFrame (frame: number, time: number, attachmentName: string | null) {\n\t\tthis.frames[frame] = time;\n\t\tthis.attachmentNames[frame] = attachmentName;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet slot = skeleton.slots[this.slotIndex];\n\t\tif (!slot.bone.active) return;\n\n\t\tif (direction == MixDirection.mixOut) {\n\t\t\tif (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n\t\t\treturn;\n\t\t}\n\n\t\tif (time < this.frames[0]) {\n\t\t\tif (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);\n\t}\n\n\tsetAttachment (skeleton: Skeleton, slot: Slot, attachmentName: string | null) {\n\t\tslot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n\t}\n}\n\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}. */\nexport class DeformTimeline extends CurveTimeline implements SlotTimeline {\n\tslotIndex = 0;\n\n\t/** The attachment that will be deformed. */\n\tattachment: VertexAttachment;\n\n\t/** The vertices for each key frame. */\n\tvertices: Array<NumberArrayLike>;\n\n\tconstructor (frameCount: number, bezierCount: number, slotIndex: number, attachment: VertexAttachment) {\n\t\tsuper(frameCount, bezierCount, [\n\t\t\tProperty.deform + \"|\" + slotIndex + \"|\" + attachment.id\n\t\t]);\n\t\tthis.slotIndex = slotIndex;\n\t\tthis.attachment = attachment;\n\t\tthis.vertices = new Array<NumberArrayLike>(frameCount);\n\t}\n\n\tgetFrameCount () {\n\t\treturn this.frames.length;\n\t}\n\n\t/** Sets the time in seconds and the vertices for the specified key frame.\n\t * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\n\tsetFrame (frame: number, time: number, vertices: NumberArrayLike) {\n\t\tthis.frames[frame] = time;\n\t\tthis.vertices[frame] = vertices;\n\t}\n\n\t/** @param value1 Ignored (0 is used for a deform timeline).\n\t * @param value2 Ignored (1 is used for a deform timeline). */\n\tsetBezier (bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number,\n\t\tcy2: number, time2: number, value2: number) {\n\t\tlet curves = this.curves;\n\t\tlet i = this.getFrameCount() + bezier * 18/*BEZIER_SIZE*/;\n\t\tif (value == 0) curves[frame] = 2/*BEZIER*/ + i;\n\t\tlet tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = cy2 * 0.03 - cy1 * 0.06;\n\t\tlet dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006, dddy = (cy1 - cy2 + 0.33333333) * 0.018;\n\t\tlet ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;\n\t\tlet dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667, dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;\n\t\tlet x = time1 + dx, y = dy;\n\t\tfor (let n = i + 18/*BEZIER_SIZE*/; i < n; i += 2) {\n\t\t\tcurves[i] = x;\n\t\t\tcurves[i + 1] = y;\n\t\t\tdx += ddx;\n\t\t\tdy += ddy;\n\t\t\tddx += dddx;\n\t\t\tddy += dddy;\n\t\t\tx += dx;\n\t\t\ty += dy;\n\t\t}\n\t}\n\n\tgetCurvePercent (time: number, frame: number) {\n\t\tlet curves = this.curves;\n\t\tlet i = curves[frame];\n\t\tswitch (i) {\n\t\t\tcase 0/*LINEAR*/:\n\t\t\t\tlet x = this.frames[frame];\n\t\t\t\treturn (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\n\t\t\tcase 1/*STEPPED*/:\n\t\t\t\treturn 0;\n\t\t}\n\t\ti -= 2/*BEZIER*/;\n\t\tif (curves[i] > time) {\n\t\t\tlet x = this.frames[frame];\n\t\t\treturn curves[i + 1] * (time - x) / (curves[i] - x);\n\t\t}\n\t\tlet n = i + 18/*BEZIER_SIZE*/;\n\t\tfor (i += 2; i < n; i += 2) {\n\t\t\tif (curves[i] >= time) {\n\t\t\t\tlet x = curves[i - 2], y = curves[i - 1];\n\t\t\t\treturn y + (time - x) / (curves[i] - x) * (curves[i + 1] - y);\n\t\t\t}\n\t\t}\n\t\tlet x = curves[n - 2], y = curves[n - 1];\n\t\treturn y + (1 - y) * (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet slot: Slot = skeleton.slots[this.slotIndex];\n\t\tif (!slot.bone.active) return;\n\t\tlet slotAttachment: Attachment | null = slot.getAttachment();\n\t\tif (!slotAttachment) return;\n\t\tif (!(slotAttachment instanceof VertexAttachment) || (<VertexAttachment>slotAttachment).timelineAttachment != this.attachment) return;\n\n\t\tlet deform: Array<number> = slot.deform;\n\t\tif (deform.length == 0) blend = MixBlend.setup;\n\n\t\tlet vertices = this.vertices;\n\t\tlet vertexCount = vertices[0].length;\n\n\t\tlet frames = this.frames;\n\t\tif (time < frames[0]) {\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tdeform.length = 0;\n\t\t\t\t\treturn;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tif (alpha == 1) {\n\t\t\t\t\t\tdeform.length = 0;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdeform.length = vertexCount;\n\t\t\t\t\tlet vertexAttachment = <VertexAttachment>slotAttachment;\n\t\t\t\t\tif (!vertexAttachment.bones) {\n\t\t\t\t\t\t// Unweighted vertex positions.\n\t\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\n\t\t\t\t\t\tfor (var i = 0; i < vertexCount; i++)\n\t\t\t\t\t\t\tdeform[i] += (setupVertices[i] - deform[i]) * alpha;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Weighted deform offsets.\n\t\t\t\t\t\talpha = 1 - alpha;\n\t\t\t\t\t\tfor (var i = 0; i < vertexCount; i++)\n\t\t\t\t\t\t\tdeform[i] *= alpha;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tdeform.length = vertexCount;\n\t\tif (time >= frames[frames.length - 1]) {\n\t\t\tlet lastVertices = vertices[frames.length - 1];\n\t\t\tif (alpha == 1) {\n\t\t\t\tif (blend == MixBlend.add) {\n\t\t\t\t\tlet vertexAttachment = slotAttachment as VertexAttachment;\n\t\t\t\t\tif (!vertexAttachment.bones) {\n\t\t\t\t\t\t// Unweighted vertex positions, with alpha.\n\t\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\n\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++)\n\t\t\t\t\t\t\tdeform[i] += lastVertices[i] - setupVertices[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Weighted deform offsets, with alpha.\n\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++)\n\t\t\t\t\t\t\tdeform[i] += lastVertices[i];\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tUtils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\n\t\t\t} else {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup: {\n\t\t\t\t\t\tlet vertexAttachment = slotAttachment as VertexAttachment;\n\t\t\t\t\t\tif (!vertexAttachment.bones) {\n\t\t\t\t\t\t\t// Unweighted vertex positions, with alpha.\n\t\t\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\n\t\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\t\t\t\t\tlet setup = setupVertices[i];\n\t\t\t\t\t\t\t\tdeform[i] = setup + (lastVertices[i] - setup) * alpha;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Weighted deform offsets, with alpha.\n\t\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++)\n\t\t\t\t\t\t\t\tdeform[i] = lastVertices[i] * alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++)\n\t\t\t\t\t\t\tdeform[i] += (lastVertices[i] - deform[i]) * alpha;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MixBlend.add:\n\t\t\t\t\t\tlet vertexAttachment = slotAttachment as VertexAttachment;\n\t\t\t\t\t\tif (!vertexAttachment.bones) {\n\t\t\t\t\t\t\t// Unweighted vertex positions, with alpha.\n\t\t\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\n\t\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++)\n\t\t\t\t\t\t\t\tdeform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Weighted deform offsets, with alpha.\n\t\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++)\n\t\t\t\t\t\t\t\tdeform[i] += lastVertices[i] * alpha;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Interpolate between the previous frame and the current frame.\n\t\tlet frame = Timeline.search1(frames, time);\n\t\tlet percent = this.getCurvePercent(time, frame);\n\t\tlet prevVertices = vertices[frame];\n\t\tlet nextVertices = vertices[frame + 1];\n\n\t\tif (alpha == 1) {\n\t\t\tif (blend == MixBlend.add) {\n\t\t\t\tlet vertexAttachment = slotAttachment as VertexAttachment;\n\t\t\t\tif (!vertexAttachment.bones) {\n\t\t\t\t\t// Unweighted vertex positions, with alpha.\n\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\n\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\t\t\tlet prev = prevVertices[i];\n\t\t\t\t\t\tdeform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Weighted deform offsets, with alpha.\n\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\t\t\tlet prev = prevVertices[i];\n\t\t\t\t\t\tdeform[i] += prev + (nextVertices[i] - prev) * percent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\t\tlet prev = prevVertices[i];\n\t\t\t\t\tdeform[i] = prev + (nextVertices[i] - prev) * percent;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup: {\n\t\t\t\t\tlet vertexAttachment = slotAttachment as VertexAttachment;\n\t\t\t\t\tif (!vertexAttachment.bones) {\n\t\t\t\t\t\t// Unweighted vertex positions, with alpha.\n\t\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\n\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\t\t\t\tlet prev = prevVertices[i], setup = setupVertices[i];\n\t\t\t\t\t\t\tdeform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Weighted deform offsets, with alpha.\n\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\t\t\t\tlet prev = prevVertices[i];\n\t\t\t\t\t\t\tdeform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase MixBlend.first:\n\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\t\t\tlet prev = prevVertices[i];\n\t\t\t\t\t\tdeform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MixBlend.add:\n\t\t\t\t\tlet vertexAttachment = slotAttachment as VertexAttachment;\n\t\t\t\t\tif (!vertexAttachment.bones) {\n\t\t\t\t\t\t// Unweighted vertex positions, with alpha.\n\t\t\t\t\t\tlet setupVertices = vertexAttachment.vertices;\n\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\t\t\t\tlet prev = prevVertices[i];\n\t\t\t\t\t\t\tdeform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Weighted deform offsets, with alpha.\n\t\t\t\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\t\t\t\tlet prev = prevVertices[i];\n\t\t\t\t\t\t\tdeform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** Fires an {@link Event} when specific animation times are reached. */\nexport class EventTimeline extends Timeline {\n\tstatic propertyIds = [\"\" + Property.event];\n\n\t/** The event for each key frame. */\n\tevents: Array<Event>;\n\n\tconstructor (frameCount: number) {\n\t\tsuper(frameCount, EventTimeline.propertyIds);\n\n\t\tthis.events = new Array<Event>(frameCount);\n\t}\n\n\tgetFrameCount () {\n\t\treturn this.frames.length;\n\t}\n\n\t/** Sets the time in seconds and the event for the specified key frame. */\n\tsetFrame (frame: number, event: Event) {\n\t\tthis.frames[frame] = event.time;\n\t\tthis.events[frame] = event;\n\t}\n\n\t/** Fires events for frames > `lastTime` and <= `time`. */\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tif (!firedEvents) return;\n\n\t\tlet frames = this.frames;\n\t\tlet frameCount = this.frames.length;\n\n\t\tif (lastTime > time) { // Apply after lastTime for looped animations.\n\t\t\tthis.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n\t\t\tlastTime = -1;\n\t\t} else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\n\t\t\treturn;\n\t\tif (time < frames[0]) return;\n\n\t\tlet i = 0;\n\t\tif (lastTime < frames[0])\n\t\t\ti = 0;\n\t\telse {\n\t\t\ti = Timeline.search1(frames, lastTime) + 1;\n\t\t\tlet frameTime = frames[i];\n\t\t\twhile (i > 0) { // Fire multiple events with the same frame.\n\t\t\t\tif (frames[i - 1] != frameTime) break;\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tfor (; i < frameCount && time >= frames[i]; i++)\n\t\t\tfiredEvents.push(this.events[i]);\n\t}\n}\n\n/** Changes a skeleton's {@link Skeleton#drawOrder}. */\nexport class DrawOrderTimeline extends Timeline {\n\tstatic propertyIds = [\"\" + Property.drawOrder];\n\n\t/** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\n\tdrawOrders: Array<Array<number> | null>;\n\n\tconstructor (frameCount: number) {\n\t\tsuper(frameCount, DrawOrderTimeline.propertyIds);\n\t\tthis.drawOrders = new Array<Array<number> | null>(frameCount);\n\t}\n\n\tgetFrameCount () {\n\t\treturn this.frames.length;\n\t}\n\n\t/** Sets the time in seconds and the draw order for the specified key frame.\n\t * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\n\t *           draw order. */\n\tsetFrame (frame: number, time: number, drawOrder: Array<number> | null) {\n\t\tthis.frames[frame] = time;\n\t\tthis.drawOrders[frame] = drawOrder;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tif (direction == MixDirection.mixOut) {\n\t\t\tif (blend == MixBlend.setup) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\t\t\treturn;\n\t\t}\n\n\t\tif (time < this.frames[0]) {\n\t\t\tif (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\t\t\treturn;\n\t\t}\n\n\t\tlet idx = Timeline.search1(this.frames, time);\n\t\tlet drawOrderToSetupIndex = this.drawOrders[idx];\n\t\tif (!drawOrderToSetupIndex)\n\t\t\tUtils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\t\telse {\n\t\t\tlet drawOrder: Array<Slot> = skeleton.drawOrder;\n\t\t\tlet slots: Array<Slot> = skeleton.slots;\n\t\t\tfor (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n\t\t\t\tdrawOrder[i] = slots[drawOrderToSetupIndex[i]];\n\t\t}\n\t}\n}\n\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}. */\nexport class IkConstraintTimeline extends CurveTimeline {\n\t/** The index of the IK constraint in {@link Skeleton#getIkConstraints()} that will be changed when this timeline is applied */\n\tconstraintIndex: number = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, ikConstraintIndex: number) {\n\t\tsuper(frameCount, bezierCount, [\n\t\t\tProperty.ikConstraint + \"|\" + ikConstraintIndex\n\t\t]);\n\t\tthis.constraintIndex = ikConstraintIndex;\n\t}\n\n\tgetFrameEntries () {\n\t\treturn 6/*ENTRIES*/;\n\t}\n\n\t/** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\n\tsetFrame (frame: number, time: number, mix: number, softness: number, bendDirection: number, compress: boolean, stretch: boolean) {\n\t\tframe *= 6/*ENTRIES*/;\n\t\tthis.frames[frame] = time;\n\t\tthis.frames[frame + 1/*MIX*/] = mix;\n\t\tthis.frames[frame + 2/*SOFTNESS*/] = softness;\n\t\tthis.frames[frame + 3/*BEND_DIRECTION*/] = bendDirection;\n\t\tthis.frames[frame + 4/*COMPRESS*/] = compress ? 1 : 0;\n\t\tthis.frames[frame + 5/*STRETCH*/] = stretch ? 1 : 0;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet constraint: IkConstraint = skeleton.ikConstraints[this.constraintIndex];\n\t\tif (!constraint.active) return;\n\n\t\tlet frames = this.frames;\n\t\tif (time < frames[0]) {\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tconstraint.mix = constraint.data.mix;\n\t\t\t\t\tconstraint.softness = constraint.data.softness;\n\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\n\t\t\t\t\tconstraint.compress = constraint.data.compress;\n\t\t\t\t\tconstraint.stretch = constraint.data.stretch;\n\t\t\t\t\treturn;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tconstraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n\t\t\t\t\tconstraint.softness += (constraint.data.softness - constraint.softness) * alpha;\n\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\n\t\t\t\t\tconstraint.compress = constraint.data.compress;\n\t\t\t\t\tconstraint.stretch = constraint.data.stretch;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet mix = 0, softness = 0;\n\t\tlet i = Timeline.search(frames, time, 6/*ENTRIES*/)\n\t\tlet curveType = this.curves[i / 6/*ENTRIES*/];\n\t\tswitch (curveType) {\n\t\t\tcase 0/*LINEAR*/:\n\t\t\t\tlet before = frames[i];\n\t\t\t\tmix = frames[i + 1/*MIX*/];\n\t\t\t\tsoftness = frames[i + 2/*SOFTNESS*/];\n\t\t\t\tlet t = (time - before) / (frames[i + 6/*ENTRIES*/] - before);\n\t\t\t\tmix += (frames[i + 6/*ENTRIES*/ + 1/*MIX*/] - mix) * t;\n\t\t\t\tsoftness += (frames[i + 6/*ENTRIES*/ + 2/*SOFTNESS*/] - softness) * t;\n\t\t\t\tbreak;\n\t\t\tcase 1/*STEPPED*/:\n\t\t\t\tmix = frames[i + 1/*MIX*/];\n\t\t\t\tsoftness = frames[i + 2/*SOFTNESS*/];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmix = this.getBezierValue(time, i, 1/*MIX*/, curveType - 2/*BEZIER*/);\n\t\t\t\tsoftness = this.getBezierValue(time, i, 2/*SOFTNESS*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\n\t\t}\n\n\t\tif (blend == MixBlend.setup) {\n\t\t\tconstraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;\n\t\t\tconstraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;\n\n\t\t\tif (direction == MixDirection.mixOut) {\n\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\n\t\t\t\tconstraint.compress = constraint.data.compress;\n\t\t\t\tconstraint.stretch = constraint.data.stretch;\n\t\t\t} else {\n\t\t\t\tconstraint.bendDirection = frames[i + 3/*BEND_DIRECTION*/];\n\t\t\t\tconstraint.compress = frames[i + 4/*COMPRESS*/] != 0;\n\t\t\t\tconstraint.stretch = frames[i + 5/*STRETCH*/] != 0;\n\t\t\t}\n\t\t} else {\n\t\t\tconstraint.mix += (mix - constraint.mix) * alpha;\n\t\t\tconstraint.softness += (softness - constraint.softness) * alpha;\n\t\t\tif (direction == MixDirection.mixIn) {\n\t\t\t\tconstraint.bendDirection = frames[i + 3/*BEND_DIRECTION*/];\n\t\t\t\tconstraint.compress = frames[i + 4/*COMPRESS*/] != 0;\n\t\t\t\tconstraint.stretch = frames[i + 5/*STRETCH*/] != 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}. */\nexport class TransformConstraintTimeline extends CurveTimeline {\n\t/** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\n\tconstraintIndex: number = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, transformConstraintIndex: number) {\n\t\tsuper(frameCount, bezierCount, [\n\t\t\tProperty.transformConstraint + \"|\" + transformConstraintIndex\n\t\t]);\n\t\tthis.constraintIndex = transformConstraintIndex;\n\t}\n\n\tgetFrameEntries () {\n\t\treturn 7/*ENTRIES*/;\n\t}\n\n\t/** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\n\tsetFrame (frame: number, time: number, mixRotate: number, mixX: number, mixY: number, mixScaleX: number, mixScaleY: number,\n\t\tmixShearY: number) {\n\t\tlet frames = this.frames;\n\t\tframe *= 7/*ENTRIES*/;\n\t\tframes[frame] = time;\n\t\tframes[frame + 1/*ROTATE*/] = mixRotate;\n\t\tframes[frame + 2/*X*/] = mixX;\n\t\tframes[frame + 3/*Y*/] = mixY;\n\t\tframes[frame + 4/*SCALEX*/] = mixScaleX;\n\t\tframes[frame + 5/*SCALEY*/] = mixScaleY;\n\t\tframes[frame + 6/*SHEARY*/] = mixShearY;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet constraint: TransformConstraint = skeleton.transformConstraints[this.constraintIndex];\n\t\tif (!constraint.active) return;\n\n\t\tlet frames = this.frames;\n\t\tif (time < frames[0]) {\n\t\t\tlet data = constraint.data;\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tconstraint.mixRotate = data.mixRotate;\n\t\t\t\t\tconstraint.mixX = data.mixX;\n\t\t\t\t\tconstraint.mixY = data.mixY;\n\t\t\t\t\tconstraint.mixScaleX = data.mixScaleX;\n\t\t\t\t\tconstraint.mixScaleY = data.mixScaleY;\n\t\t\t\t\tconstraint.mixShearY = data.mixShearY;\n\t\t\t\t\treturn;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tconstraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;\n\t\t\t\t\tconstraint.mixX += (data.mixX - constraint.mixX) * alpha;\n\t\t\t\t\tconstraint.mixY += (data.mixY - constraint.mixY) * alpha;\n\t\t\t\t\tconstraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;\n\t\t\t\t\tconstraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;\n\t\t\t\t\tconstraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet rotate, x, y, scaleX, scaleY, shearY;\n\t\tlet i = Timeline.search(frames, time, 7/*ENTRIES*/);\n\t\tlet curveType = this.curves[i / 7/*ENTRIES*/];\n\t\tswitch (curveType) {\n\t\t\tcase 0/*LINEAR*/:\n\t\t\t\tlet before = frames[i];\n\t\t\t\trotate = frames[i + 1/*ROTATE*/];\n\t\t\t\tx = frames[i + 2/*X*/];\n\t\t\t\ty = frames[i + 3/*Y*/];\n\t\t\t\tscaleX = frames[i + 4/*SCALEX*/];\n\t\t\t\tscaleY = frames[i + 5/*SCALEY*/];\n\t\t\t\tshearY = frames[i + 6/*SHEARY*/];\n\t\t\t\tlet t = (time - before) / (frames[i + 7/*ENTRIES*/] - before);\n\t\t\t\trotate += (frames[i + 7/*ENTRIES*/ + 1/*ROTATE*/] - rotate) * t;\n\t\t\t\tx += (frames[i + 7/*ENTRIES*/ + 2/*X*/] - x) * t;\n\t\t\t\ty += (frames[i + 7/*ENTRIES*/ + 3/*Y*/] - y) * t;\n\t\t\t\tscaleX += (frames[i + 7/*ENTRIES*/ + 4/*SCALEX*/] - scaleX) * t;\n\t\t\t\tscaleY += (frames[i + 7/*ENTRIES*/ + 5/*SCALEY*/] - scaleY) * t;\n\t\t\t\tshearY += (frames[i + 7/*ENTRIES*/ + 6/*SHEARY*/] - shearY) * t;\n\t\t\t\tbreak;\n\t\t\tcase 1/*STEPPED*/:\n\t\t\t\trotate = frames[i + 1/*ROTATE*/];\n\t\t\t\tx = frames[i + 2/*X*/];\n\t\t\t\ty = frames[i + 3/*Y*/];\n\t\t\t\tscaleX = frames[i + 4/*SCALEX*/];\n\t\t\t\tscaleY = frames[i + 5/*SCALEY*/];\n\t\t\t\tshearY = frames[i + 6/*SHEARY*/];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trotate = this.getBezierValue(time, i, 1/*ROTATE*/, curveType - 2/*BEZIER*/);\n\t\t\t\tx = this.getBezierValue(time, i, 2/*X*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\n\t\t\t\ty = this.getBezierValue(time, i, 3/*Y*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\n\t\t\t\tscaleX = this.getBezierValue(time, i, 4/*SCALEX*/, curveType + 18/*BEZIER_SIZE*/ * 3 - 2/*BEZIER*/);\n\t\t\t\tscaleY = this.getBezierValue(time, i, 5/*SCALEY*/, curveType + 18/*BEZIER_SIZE*/ * 4 - 2/*BEZIER*/);\n\t\t\t\tshearY = this.getBezierValue(time, i, 6/*SHEARY*/, curveType + 18/*BEZIER_SIZE*/ * 5 - 2/*BEZIER*/);\n\t\t}\n\n\t\tif (blend == MixBlend.setup) {\n\t\t\tlet data = constraint.data;\n\t\t\tconstraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n\t\t\tconstraint.mixX = data.mixX + (x - data.mixX) * alpha;\n\t\t\tconstraint.mixY = data.mixY + (y - data.mixY) * alpha;\n\t\t\tconstraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;\n\t\t\tconstraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;\n\t\t\tconstraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;\n\t\t} else {\n\t\t\tconstraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n\t\t\tconstraint.mixX += (x - constraint.mixX) * alpha;\n\t\t\tconstraint.mixY += (y - constraint.mixY) * alpha;\n\t\t\tconstraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;\n\t\t\tconstraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;\n\t\t\tconstraint.mixShearY += (shearY - constraint.mixShearY) * alpha;\n\t\t}\n\t}\n}\n\n/** Changes a path constraint's {@link PathConstraint#position}. */\nexport class PathConstraintPositionTimeline extends CurveTimeline1 {\n\t/** The index of the path constraint in {@link Skeleton#getPathConstraints()} that will be changed when this timeline is\n\t * applied. */\n\tconstraintIndex: number = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n\t\tsuper(frameCount, bezierCount, Property.pathConstraintPosition + \"|\" + pathConstraintIndex);\n\t\tthis.constraintIndex = pathConstraintIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet constraint: PathConstraint = skeleton.pathConstraints[this.constraintIndex];\n\t\tif (constraint.active)\n\t\t\tconstraint.position = this.getAbsoluteValue(time, alpha, blend, constraint.position, constraint.data.position);\n\t}\n}\n\n/** Changes a path constraint's {@link PathConstraint#spacing}. */\nexport class PathConstraintSpacingTimeline extends CurveTimeline1 {\n\t/** The index of the path constraint in {@link Skeleton#getPathConstraints()} that will be changed when this timeline is\n\t * applied. */\n\tconstraintIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n\t\tsuper(frameCount, bezierCount, Property.pathConstraintSpacing + \"|\" + pathConstraintIndex);\n\t\tthis.constraintIndex = pathConstraintIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet constraint: PathConstraint = skeleton.pathConstraints[this.constraintIndex];\n\t\tif (constraint.active)\n\t\t\tconstraint.spacing = this.getAbsoluteValue(time, alpha, blend, constraint.spacing, constraint.data.spacing);\n\t}\n}\n\n/** Changes a transform constraint's {@link PathConstraint#getMixRotate()}, {@link PathConstraint#getMixX()}, and\n * {@link PathConstraint#getMixY()}. */\nexport class PathConstraintMixTimeline extends CurveTimeline {\n\t/** The index of the path constraint in {@link Skeleton#getPathConstraints()} that will be changed when this timeline is\n\t * applied. */\n\tconstraintIndex = 0;\n\n\tconstructor (frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n\t\tsuper(frameCount, bezierCount, [\n\t\t\tProperty.pathConstraintMix + \"|\" + pathConstraintIndex\n\t\t]);\n\t\tthis.constraintIndex = pathConstraintIndex;\n\t}\n\n\tgetFrameEntries () {\n\t\treturn 4/*ENTRIES*/;\n\t}\n\n\tsetFrame (frame: number, time: number, mixRotate: number, mixX: number, mixY: number) {\n\t\tlet frames = this.frames;\n\t\tframe <<= 2;\n\t\tframes[frame] = time;\n\t\tframes[frame + 1/*ROTATE*/] = mixRotate;\n\t\tframes[frame + 2/*X*/] = mixX;\n\t\tframes[frame + 3/*Y*/] = mixY;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet constraint: PathConstraint = skeleton.pathConstraints[this.constraintIndex];\n\t\tif (!constraint.active) return;\n\n\t\tlet frames = this.frames;\n\t\tif (time < frames[0]) {\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tconstraint.mixRotate = constraint.data.mixRotate;\n\t\t\t\t\tconstraint.mixX = constraint.data.mixX;\n\t\t\t\t\tconstraint.mixY = constraint.data.mixY;\n\t\t\t\t\treturn;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tconstraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;\n\t\t\t\t\tconstraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;\n\t\t\t\t\tconstraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet rotate, x, y;\n\t\tlet i = Timeline.search(frames, time, 4/*ENTRIES*/);\n\t\tlet curveType = this.curves[i >> 2];\n\t\tswitch (curveType) {\n\t\t\tcase 0/*LINEAR*/:\n\t\t\t\tlet before = frames[i];\n\t\t\t\trotate = frames[i + 1/*ROTATE*/];\n\t\t\t\tx = frames[i + 2/*X*/];\n\t\t\t\ty = frames[i + 3/*Y*/];\n\t\t\t\tlet t = (time - before) / (frames[i + 4/*ENTRIES*/] - before);\n\t\t\t\trotate += (frames[i + 4/*ENTRIES*/ + 1/*ROTATE*/] - rotate) * t;\n\t\t\t\tx += (frames[i + 4/*ENTRIES*/ + 2/*X*/] - x) * t;\n\t\t\t\ty += (frames[i + 4/*ENTRIES*/ + 3/*Y*/] - y) * t;\n\t\t\t\tbreak;\n\t\t\tcase 1/*STEPPED*/:\n\t\t\t\trotate = frames[i + 1/*ROTATE*/];\n\t\t\t\tx = frames[i + 2/*X*/];\n\t\t\t\ty = frames[i + 3/*Y*/];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trotate = this.getBezierValue(time, i, 1/*ROTATE*/, curveType - 2/*BEZIER*/);\n\t\t\t\tx = this.getBezierValue(time, i, 2/*X*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\n\t\t\t\ty = this.getBezierValue(time, i, 3/*Y*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\n\t\t}\n\n\t\tif (blend == MixBlend.setup) {\n\t\t\tlet data = constraint.data;\n\t\t\tconstraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n\t\t\tconstraint.mixX = data.mixX + (x - data.mixX) * alpha;\n\t\t\tconstraint.mixY = data.mixY + (y - data.mixY) * alpha;\n\t\t} else {\n\t\t\tconstraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n\t\t\tconstraint.mixX += (x - constraint.mixX) * alpha;\n\t\t\tconstraint.mixY += (y - constraint.mixY) * alpha;\n\t\t}\n\t}\n}\n\n/** The base class for most {@link PhysicsConstraint} timelines. */\nexport abstract class PhysicsConstraintTimeline extends CurveTimeline1 {\n\t/** The index of the physics constraint in {@link Skeleton#getPhysicsConstraints()} that will be changed when this timeline\n\t * is applied, or -1 if all physics constraints in the skeleton will be changed. */\n\tconstraintIndex = 0;\n\n\t/** @param physicsConstraintIndex -1 for all physics constraints in the skeleton. */\n\tconstructor (frameCount: number, bezierCount: number, physicsConstraintIndex: number, property: number) {\n\t\tsuper(frameCount, bezierCount, property + \"|\" + physicsConstraintIndex);\n\t\tthis.constraintIndex = physicsConstraintIndex;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet constraint: PhysicsConstraint;\n\t\tif (this.constraintIndex == -1) {\n\t\t\tconst value = time >= this.frames[0] ? this.getCurveValue(time) : 0;\n\n\t\t\tfor (const constraint of skeleton.physicsConstraints) {\n\t\t\t\tif (constraint.active && this.global(constraint.data))\n\t\t\t\t\tthis.set(constraint, this.getAbsoluteValue2(time, alpha, blend, this.get(constraint), this.setup(constraint), value));\n\t\t\t}\n\t\t} else {\n\t\t\tconstraint = skeleton.physicsConstraints[this.constraintIndex];\n\t\t\tif (constraint.active) this.set(constraint, this.getAbsoluteValue(time, alpha, blend, this.get(constraint), this.setup(constraint)));\n\t\t}\n\t}\n\n\tabstract setup (constraint: PhysicsConstraint): number;\n\n\tabstract get (constraint: PhysicsConstraint): number;\n\n\tabstract set (constraint: PhysicsConstraint, value: number): void;\n\n\tabstract global (constraint: PhysicsConstraintData): boolean;\n}\n\n/** Changes a physics constraint's {@link PhysicsConstraint#getInertia()}. */\nexport class PhysicsConstraintInertiaTimeline extends PhysicsConstraintTimeline {\n\tconstructor (frameCount: number, bezierCount: number, physicsConstraintIndex: number) {\n\t\tsuper(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintInertia);\n\t}\n\n\tsetup (constraint: PhysicsConstraint): number {\n\t\treturn constraint.data.inertia;\n\t}\n\n\tget (constraint: PhysicsConstraint): number {\n\t\treturn constraint.inertia;\n\t}\n\n\tset (constraint: PhysicsConstraint, value: number): void {\n\t\tconstraint.inertia = value;\n\t}\n\n\tglobal (constraint: PhysicsConstraintData): boolean {\n\t\treturn constraint.inertiaGlobal;\n\t}\n}\n\n/** Changes a physics constraint's {@link PhysicsConstraint#getStrength()}. */\nexport class PhysicsConstraintStrengthTimeline extends PhysicsConstraintTimeline {\n\tconstructor (frameCount: number, bezierCount: number, physicsConstraintIndex: number) {\n\t\tsuper(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintStrength);\n\t}\n\n\tsetup (constraint: PhysicsConstraint): number {\n\t\treturn constraint.data.strength;\n\t}\n\n\tget (constraint: PhysicsConstraint): number {\n\t\treturn constraint.strength;\n\t}\n\n\tset (constraint: PhysicsConstraint, value: number): void {\n\t\tconstraint.strength = value;\n\t}\n\n\tglobal (constraint: PhysicsConstraintData): boolean {\n\t\treturn constraint.strengthGlobal;\n\t}\n}\n\n/** Changes a physics constraint's {@link PhysicsConstraint#getDamping()}. */\nexport class PhysicsConstraintDampingTimeline extends PhysicsConstraintTimeline {\n\tconstructor (frameCount: number, bezierCount: number, physicsConstraintIndex: number) {\n\t\tsuper(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintDamping);\n\t}\n\n\tsetup (constraint: PhysicsConstraint): number {\n\t\treturn constraint.data.damping;\n\t}\n\n\tget (constraint: PhysicsConstraint): number {\n\t\treturn constraint.damping;\n\t}\n\n\tset (constraint: PhysicsConstraint, value: number): void {\n\t\tconstraint.damping = value;\n\t}\n\n\tglobal (constraint: PhysicsConstraintData): boolean {\n\t\treturn constraint.dampingGlobal;\n\t}\n}\n\n/** Changes a physics constraint's {@link PhysicsConstraint#getMassInverse()}. The timeline values are not inverted. */\nexport class PhysicsConstraintMassTimeline extends PhysicsConstraintTimeline {\n\tconstructor (frameCount: number, bezierCount: number, physicsConstraintIndex: number) {\n\t\tsuper(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintMass);\n\t}\n\n\tsetup (constraint: PhysicsConstraint): number {\n\t\treturn 1 / constraint.data.massInverse;\n\t}\n\n\tget (constraint: PhysicsConstraint): number {\n\t\treturn 1 / constraint.massInverse;\n\t}\n\n\tset (constraint: PhysicsConstraint, value: number): void {\n\t\tconstraint.massInverse = 1 / value;\n\t}\n\n\tglobal (constraint: PhysicsConstraintData): boolean {\n\t\treturn constraint.massGlobal;\n\t}\n}\n\n/** Changes a physics constraint's {@link PhysicsConstraint#getWind()}. */\nexport class PhysicsConstraintWindTimeline extends PhysicsConstraintTimeline {\n\tconstructor (frameCount: number, bezierCount: number, physicsConstraintIndex: number) {\n\t\tsuper(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintWind);\n\t}\n\n\tsetup (constraint: PhysicsConstraint): number {\n\t\treturn constraint.data.wind;\n\t}\n\n\tget (constraint: PhysicsConstraint): number {\n\t\treturn constraint.wind;\n\t}\n\n\tset (constraint: PhysicsConstraint, value: number): void {\n\t\tconstraint.wind = value;\n\t}\n\n\tglobal (constraint: PhysicsConstraintData): boolean {\n\t\treturn constraint.windGlobal;\n\t}\n}\n\n/** Changes a physics constraint's {@link PhysicsConstraint#getGravity()}. */\nexport class PhysicsConstraintGravityTimeline extends PhysicsConstraintTimeline {\n\tconstructor (frameCount: number, bezierCount: number, physicsConstraintIndex: number) {\n\t\tsuper(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintGravity);\n\t}\n\n\tsetup (constraint: PhysicsConstraint): number {\n\t\treturn constraint.data.gravity;\n\t}\n\n\tget (constraint: PhysicsConstraint): number {\n\t\treturn constraint.gravity;\n\t}\n\n\tset (constraint: PhysicsConstraint, value: number): void {\n\t\tconstraint.gravity = value;\n\t}\n\n\tglobal (constraint: PhysicsConstraintData): boolean {\n\t\treturn constraint.gravityGlobal;\n\t}\n}\n\n/** Changes a physics constraint's {@link PhysicsConstraint#getMix()}. */\nexport class PhysicsConstraintMixTimeline extends PhysicsConstraintTimeline {\n\tconstructor (frameCount: number, bezierCount: number, physicsConstraintIndex: number) {\n\t\tsuper(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintMix);\n\t}\n\n\tsetup (constraint: PhysicsConstraint): number {\n\t\treturn constraint.data.mix;\n\t}\n\n\tget (constraint: PhysicsConstraint): number {\n\t\treturn constraint.mix;\n\t}\n\n\tset (constraint: PhysicsConstraint, value: number): void {\n\t\tconstraint.mix = value;\n\t}\n\n\tglobal (constraint: PhysicsConstraintData): boolean {\n\t\treturn constraint.mixGlobal;\n\t}\n}\n\n/** Resets a physics constraint when specific animation times are reached. */\nexport class PhysicsConstraintResetTimeline extends Timeline {\n\tprivate static propertyIds: string[] = [Property.physicsConstraintReset.toString()];\n\n\t/** The index of the physics constraint in {@link Skeleton#getPhysicsConstraints()} that will be reset when this timeline is\n\t* applied, or -1 if all physics constraints in the skeleton will be reset. */\n\tconstraintIndex: number;\n\n\t/** @param physicsConstraintIndex -1 for all physics constraints in the skeleton. */\n\tconstructor (frameCount: number, physicsConstraintIndex: number) {\n\t\tsuper(frameCount, PhysicsConstraintResetTimeline.propertyIds);\n\t\tthis.constraintIndex = physicsConstraintIndex;\n\t}\n\n\tgetFrameCount () {\n\t\treturn this.frames.length;\n\t}\n\n\t/** Sets the time for the specified frame.\n\t * @param frame Between 0 and <code>frameCount</code>, inclusive. */\n\tsetFrame (frame: number, time: number) {\n\t\tthis.frames[frame] = time;\n\t}\n\n\t/** Resets the physics constraint when frames > <code>lastTime</code> and <= <code>time</code>. */\n\tapply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\n\t\tlet constraint: PhysicsConstraint | undefined;\n\t\tif (this.constraintIndex != -1) {\n\t\t\tconstraint = skeleton.physicsConstraints[this.constraintIndex];\n\t\t\tif (!constraint.active) return;\n\t\t}\n\n\t\tconst frames = this.frames;\n\n\t\tif (lastTime > time) { // Apply after lastTime for looped animations.\n\t\t\tthis.apply(skeleton, lastTime, Number.MAX_VALUE, [], alpha, blend, direction);\n\t\t\tlastTime = -1;\n\t\t} else if (lastTime >= frames[frames.length - 1]) // Last time is after last frame.\n\t\t\treturn;\n\t\tif (time < frames[0]) return;\n\n\t\tif (lastTime < frames[0] || time >= frames[Timeline.search1(frames, lastTime) + 1]) {\n\t\t\tif (constraint != null)\n\t\t\t\tconstraint.reset();\n\t\t\telse {\n\t\t\t\tfor (const constraint of skeleton.physicsConstraints) {\n\t\t\t\t\tif (constraint.active) constraint.reset();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** Changes a slot's {@link Slot#getSequenceIndex()} for an attachment's {@link Sequence}. */\nexport class SequenceTimeline extends Timeline implements SlotTimeline {\n\tstatic ENTRIES = 3;\n\tstatic MODE = 1;\n\tstatic DELAY = 2;\n\n\tslotIndex: number;\n\tattachment: HasTextureRegion;\n\n\tconstructor (frameCount: number, slotIndex: number, attachment: HasTextureRegion) {\n\t\tsuper(frameCount, [\n\t\t\tProperty.sequence + \"|\" + slotIndex + \"|\" + attachment.sequence!.id\n\t\t]);\n\t\tthis.slotIndex = slotIndex;\n\t\tthis.attachment = attachment;\n\t}\n\n\tgetFrameEntries () {\n\t\treturn SequenceTimeline.ENTRIES;\n\t}\n\n\tgetSlotIndex () {\n\t\treturn this.slotIndex;\n\t}\n\n\tgetAttachment () {\n\t\treturn this.attachment as unknown as Attachment;\n\t}\n\n\t/** Sets the time, mode, index, and frame time for the specified frame.\n\t * @param frame Between 0 and <code>frameCount</code>, inclusive.\n\t * @param time Seconds between frames. */\n\tsetFrame (frame: number, time: number, mode: SequenceMode, index: number, delay: number) {\n\t\tlet frames = this.frames;\n\t\tframe *= SequenceTimeline.ENTRIES;\n\t\tframes[frame] = time;\n\t\tframes[frame + SequenceTimeline.MODE] = mode | (index << 4);\n\t\tframes[frame + SequenceTimeline.DELAY] = delay;\n\t}\n\n\tapply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n\t\tlet slot = skeleton.slots[this.slotIndex];\n\t\tif (!slot.bone.active) return;\n\t\tlet slotAttachment = slot.attachment;\n\t\tlet attachment = this.attachment as unknown as Attachment;\n\t\tif (slotAttachment != attachment) {\n\t\t\tif (!(slotAttachment instanceof VertexAttachment)\n\t\t\t\t|| (slotAttachment as VertexAttachment).timelineAttachment != attachment) return;\n\t\t}\n\n\t\tif (direction == MixDirection.mixOut) {\n\t\t\tif (blend == MixBlend.setup) slot.sequenceIndex = -1;\n\t\t\treturn;\n\t\t}\n\n\t\tlet frames = this.frames;\n\t\tif (time < frames[0]) {\n\t\t\tif (blend == MixBlend.setup || blend == MixBlend.first) slot.sequenceIndex = -1;\n\t\t\treturn;\n\t\t}\n\n\t\tlet i = Timeline.search(frames, time, SequenceTimeline.ENTRIES);\n\t\tlet before = frames[i];\n\t\tlet modeAndIndex = frames[i + SequenceTimeline.MODE];\n\t\tlet delay = frames[i + SequenceTimeline.DELAY];\n\n\t\tif (!this.attachment.sequence) return;\n\t\tlet index = modeAndIndex >> 4, count = this.attachment.sequence!.regions.length;\n\t\tlet mode = SequenceModeValues[modeAndIndex & 0xf];\n\t\tif (mode != SequenceMode.hold) {\n\t\t\tindex += (((time - before) / delay + 0.00001) | 0);\n\t\t\tswitch (mode) {\n\t\t\t\tcase SequenceMode.once:\n\t\t\t\t\tindex = Math.min(count - 1, index);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SequenceMode.loop:\n\t\t\t\t\tindex %= count;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SequenceMode.pingpong: {\n\t\t\t\t\tlet n = (count << 1) - 2;\n\t\t\t\t\tindex = n == 0 ? 0 : index % n;\n\t\t\t\t\tif (index >= count) index = n - index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase SequenceMode.onceReverse:\n\t\t\t\t\tindex = Math.max(count - 1 - index, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SequenceMode.loopReverse:\n\t\t\t\t\tindex = count - 1 - (index % count);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SequenceMode.pingpongReverse: {\n\t\t\t\t\tlet n = (count << 1) - 2;\n\t\t\t\t\tindex = n == 0 ? 0 : (index + count - 1) % n;\n\t\t\t\t\tif (index >= count) index = n - index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tslot.sequenceIndex = index;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Animation, MixBlend, AttachmentTimeline, MixDirection, RotateTimeline, DrawOrderTimeline, Timeline, EventTimeline } from \"./Animation.js\";\nimport { AnimationStateData } from \"./AnimationStateData.js\";\nimport { Skeleton } from \"./Skeleton.js\";\nimport { Slot } from \"./Slot.js\";\nimport { StringSet, Pool, Utils, MathUtils } from \"./Utils.js\";\nimport { Event } from \"./Event.js\";\n\n\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\n * multiple animations on top of each other (layering).\n *\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide. */\nexport class AnimationState {\n\tstatic _emptyAnimation = new Animation(\"<empty>\", [], 0);\n\tprivate static emptyAnimation (): Animation {\n\t\treturn AnimationState._emptyAnimation;\n\t}\n\n\t/** The AnimationStateData to look up mix durations. */\n\tdata: AnimationStateData;\n\n\t/** The list of tracks that currently have animations, which may contain null entries. */\n\ttracks = new Array<TrackEntry | null>();\n\n\t/** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\n\t * or faster. Defaults to 1.\n\t *\n\t * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\n\ttimeScale = 1;\n\tunkeyedState = 0;\n\n\tevents = new Array<Event>();\n\tlisteners = new Array<AnimationStateListener>();\n\tqueue = new EventQueue(this);\n\tpropertyIDs = new StringSet();\n\tanimationsChanged = false;\n\n\ttrackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\n\n\tconstructor (data: AnimationStateData) {\n\t\tthis.data = data;\n\t}\n\n\t/** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\n\tupdate (delta: number) {\n\t\tdelta *= this.timeScale;\n\t\tlet tracks = this.tracks;\n\t\tfor (let i = 0, n = tracks.length; i < n; i++) {\n\t\t\tlet current = tracks[i];\n\t\t\tif (!current) continue;\n\n\t\t\tcurrent.animationLast = current.nextAnimationLast;\n\t\t\tcurrent.trackLast = current.nextTrackLast;\n\n\t\t\tlet currentDelta = delta * current.timeScale;\n\n\t\t\tif (current.delay > 0) {\n\t\t\t\tcurrent.delay -= currentDelta;\n\t\t\t\tif (current.delay > 0) continue;\n\t\t\t\tcurrentDelta = -current.delay;\n\t\t\t\tcurrent.delay = 0;\n\t\t\t}\n\n\t\t\tlet next = current.next;\n\t\t\tif (next) {\n\t\t\t\t// When the next entry's delay is passed, change to the next entry, preserving leftover time.\n\t\t\t\tlet nextTime = current.trackLast - next.delay;\n\t\t\t\tif (nextTime >= 0) {\n\t\t\t\t\tnext.delay = 0;\n\t\t\t\t\tnext.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n\t\t\t\t\tcurrent.trackTime += currentDelta;\n\t\t\t\t\tthis.setCurrent(i, next, true);\n\t\t\t\t\twhile (next.mixingFrom) {\n\t\t\t\t\t\tnext.mixTime += delta;\n\t\t\t\t\t\tnext = next.mixingFrom;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {\n\t\t\t\ttracks[i] = null;\n\t\t\t\tthis.queue.end(current);\n\t\t\t\tthis.clearNext(current);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (current.mixingFrom && this.updateMixingFrom(current, delta)) {\n\t\t\t\t// End mixing from entries once all have completed.\n\t\t\t\tlet from: TrackEntry | null = current.mixingFrom;\n\t\t\t\tcurrent.mixingFrom = null;\n\t\t\t\tif (from) from.mixingTo = null;\n\t\t\t\twhile (from) {\n\t\t\t\t\tthis.queue.end(from);\n\t\t\t\t\tfrom = from.mixingFrom;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrent.trackTime += currentDelta;\n\t\t}\n\n\t\tthis.queue.drain();\n\t}\n\n\t/** Returns true when all mixing from entries are complete. */\n\tupdateMixingFrom (to: TrackEntry, delta: number): boolean {\n\t\tlet from = to.mixingFrom;\n\t\tif (!from) return true;\n\n\t\tlet finished = this.updateMixingFrom(from, delta);\n\n\t\tfrom.animationLast = from.nextAnimationLast;\n\t\tfrom.trackLast = from.nextTrackLast;\n\n\t\tif (to.nextTrackLast != -1) { // The from entry was applied at least once.\n\t\t\tconst discard = to.mixTime == 0 && from.mixTime == 0; // Discard the from entry when neither have advanced yet.\n\t\t\tif (to.mixTime >= to.mixDuration || discard) {\n\t\t\t\t// Require totalAlpha == 0 to ensure mixing is complete or the transition is a single frame or discarded.\n\t\t\t\tif (from.totalAlpha == 0 || to.mixDuration == 0 || discard) {\n\t\t\t\t\tto.mixingFrom = from.mixingFrom;\n\t\t\t\t\tif (from.mixingFrom != null) from.mixingFrom.mixingTo = to;\n\t\t\t\t\tto.interruptAlpha = from.interruptAlpha;\n\t\t\t\t\tthis.queue.end(from);\n\t\t\t\t}\n\t\t\t\treturn finished;\n\t\t\t}\n\t\t}\n\n\t\tfrom.trackTime += delta * from.timeScale;\n\t\tto.mixTime += delta;\n\t\treturn false;\n\t}\n\n\t/** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\n\t * animation state can be applied to multiple skeletons to pose them identically.\n\t * @returns True if any animations were applied. */\n\tapply (skeleton: Skeleton): boolean {\n\t\tif (!skeleton) throw new Error(\"skeleton cannot be null.\");\n\t\tif (this.animationsChanged) this._animationsChanged();\n\n\t\tlet events = this.events;\n\t\tlet tracks = this.tracks;\n\t\tlet applied = false;\n\n\t\tfor (let i = 0, n = tracks.length; i < n; i++) {\n\t\t\tlet current = tracks[i];\n\t\t\tif (!current || current.delay > 0) continue;\n\t\t\tapplied = true;\n\t\t\tlet blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\n\n\t\t\t// Apply mixing from entries first.\n\t\t\tlet alpha = current.alpha;\n\t\t\tif (current.mixingFrom)\n\t\t\t\talpha *= this.applyMixingFrom(current, skeleton, blend);\n\t\t\telse if (current.trackTime >= current.trackEnd && !current.next)\n\t\t\t\talpha = 0;\n\t\t\tlet attachments = alpha >= current.alphaAttachmentThreshold;\n\n\n\t\t\t// Apply current entry.\n\t\t\tlet animationLast = current.animationLast, animationTime = current.getAnimationTime(), applyTime = animationTime;\n\t\t\tlet applyEvents: Event[] | null = events;\n\t\t\tif (current.reverse) {\n\t\t\t\tapplyTime = current.animation!.duration - applyTime;\n\t\t\t\tapplyEvents = null;\n\t\t\t}\n\t\t\tlet timelines = current.animation!.timelines;\n\t\t\tlet timelineCount = timelines.length;\n\t\t\tif ((i == 0 && alpha == 1) || blend == MixBlend.add) {\n\t\t\t\tif (i == 0) attachments = true;\n\t\t\t\tfor (let ii = 0; ii < timelineCount; ii++) {\n\t\t\t\t\t// Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\n\t\t\t\t\t// to sometimes stop rendering when using color correction, as their RGBA values become NaN.\n\t\t\t\t\t// (https://github.com/pixijs/pixi-spine/issues/302)\n\t\t\t\t\tUtils.webkit602BugfixHelper(alpha, blend);\n\t\t\t\t\tvar timeline = timelines[ii];\n\t\t\t\t\tif (timeline instanceof AttachmentTimeline)\n\t\t\t\t\t\tthis.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, attachments);\n\t\t\t\t\telse\n\t\t\t\t\t\ttimeline.apply(skeleton, animationLast, applyTime, applyEvents, alpha, blend, MixDirection.mixIn);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet timelineMode = current.timelineMode;\n\n\t\t\t\tlet shortestRotation = current.shortestRotation;\n\t\t\t\tlet firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;\n\t\t\t\tif (firstFrame) current.timelinesRotation.length = timelineCount << 1;\n\n\t\t\t\tfor (let ii = 0; ii < timelineCount; ii++) {\n\t\t\t\t\tlet timeline = timelines[ii];\n\t\t\t\t\tlet timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;\n\t\t\t\t\tif (!shortestRotation && timeline instanceof RotateTimeline) {\n\t\t\t\t\t\tthis.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);\n\t\t\t\t\t} else if (timeline instanceof AttachmentTimeline) {\n\t\t\t\t\t\tthis.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, attachments);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n\t\t\t\t\t\tUtils.webkit602BugfixHelper(alpha, blend);\n\t\t\t\t\t\ttimeline.apply(skeleton, animationLast, applyTime, applyEvents, alpha, timelineBlend, MixDirection.mixIn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.queueEvents(current, animationTime);\n\t\t\tevents.length = 0;\n\t\t\tcurrent.nextAnimationLast = animationTime;\n\t\t\tcurrent.nextTrackLast = current.trackTime;\n\t\t}\n\n\t\t// Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\n\t\t// subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\n\t\t// the time is before the first key).\n\t\tvar setupState = this.unkeyedState + SETUP;\n\t\tvar slots = skeleton.slots;\n\t\tfor (var i = 0, n = skeleton.slots.length; i < n; i++) {\n\t\t\tvar slot = slots[i];\n\t\t\tif (slot.attachmentState == setupState) {\n\t\t\t\tvar attachmentName = slot.data.attachmentName;\n\t\t\t\tslot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n\t\t\t}\n\t\t}\n\t\tthis.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\n\n\t\tthis.queue.drain();\n\t\treturn applied;\n\t}\n\n\tapplyMixingFrom (to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\n\t\tlet from = to.mixingFrom!;\n\t\tif (from.mixingFrom) this.applyMixingFrom(from, skeleton, blend);\n\n\t\tlet mix = 0;\n\t\tif (to.mixDuration == 0) { // Single frame mix to undo mixingFrom changes.\n\t\t\tmix = 1;\n\t\t\tif (blend == MixBlend.first) blend = MixBlend.setup;\n\t\t} else {\n\t\t\tmix = to.mixTime / to.mixDuration;\n\t\t\tif (mix > 1) mix = 1;\n\t\t\tif (blend != MixBlend.first) blend = from.mixBlend;\n\t\t}\n\n\t\tlet attachments = mix < from.mixAttachmentThreshold, drawOrder = mix < from.mixDrawOrderThreshold;\n\t\tlet timelines = from.animation!.timelines;\n\t\tlet timelineCount = timelines.length;\n\t\tlet alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);\n\t\tlet animationLast = from.animationLast, animationTime = from.getAnimationTime(), applyTime = animationTime;\n\t\tlet events = null;\n\t\tif (from.reverse)\n\t\t\tapplyTime = from.animation!.duration - applyTime;\n\t\telse if (mix < from.eventThreshold)\n\t\t\tevents = this.events;\n\n\t\tif (blend == MixBlend.add) {\n\t\t\tfor (let i = 0; i < timelineCount; i++)\n\t\t\t\ttimelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);\n\t\t} else {\n\t\t\tlet timelineMode = from.timelineMode;\n\t\t\tlet timelineHoldMix = from.timelineHoldMix;\n\n\t\t\tlet shortestRotation = from.shortestRotation;\n\t\t\tlet firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;\n\t\t\tif (firstFrame) from.timelinesRotation.length = timelineCount << 1;\n\n\t\t\tfrom.totalAlpha = 0;\n\t\t\tfor (let i = 0; i < timelineCount; i++) {\n\t\t\t\tlet timeline = timelines[i];\n\t\t\t\tlet direction = MixDirection.mixOut;\n\t\t\t\tlet timelineBlend: MixBlend;\n\t\t\t\tlet alpha = 0;\n\t\t\t\tswitch (timelineMode[i]) {\n\t\t\t\t\tcase SUBSEQUENT:\n\t\t\t\t\t\tif (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n\t\t\t\t\t\ttimelineBlend = blend;\n\t\t\t\t\t\talpha = alphaMix;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FIRST:\n\t\t\t\t\t\ttimelineBlend = MixBlend.setup;\n\t\t\t\t\t\talpha = alphaMix;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase HOLD_SUBSEQUENT:\n\t\t\t\t\t\ttimelineBlend = blend;\n\t\t\t\t\t\talpha = alphaHold;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase HOLD_FIRST:\n\t\t\t\t\t\ttimelineBlend = MixBlend.setup;\n\t\t\t\t\t\talpha = alphaHold;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttimelineBlend = MixBlend.setup;\n\t\t\t\t\t\tlet holdMix = timelineHoldMix[i];\n\t\t\t\t\t\talpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfrom.totalAlpha += alpha;\n\n\t\t\t\tif (!shortestRotation && timeline instanceof RotateTimeline)\n\t\t\t\t\tthis.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);\n\t\t\t\telse if (timeline instanceof AttachmentTimeline)\n\t\t\t\t\tthis.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments && alpha >= from.alphaAttachmentThreshold);\n\t\t\t\telse {\n\t\t\t\t\t// This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n\t\t\t\t\tUtils.webkit602BugfixHelper(alpha, blend);\n\t\t\t\t\tif (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)\n\t\t\t\t\t\tdirection = MixDirection.mixIn;\n\t\t\t\t\ttimeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (to.mixDuration > 0) this.queueEvents(from, animationTime);\n\t\tthis.events.length = 0;\n\t\tfrom.nextAnimationLast = animationTime;\n\t\tfrom.nextTrackLast = from.trackTime;\n\n\t\treturn mix;\n\t}\n\n\tapplyAttachmentTimeline (timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\n\t\tvar slot = skeleton.slots[timeline.slotIndex];\n\t\tif (!slot.bone.active) return;\n\n\t\tif (time < timeline.frames[0]) { // Time is before first frame.\n\t\t\tif (blend == MixBlend.setup || blend == MixBlend.first)\n\t\t\t\tthis.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n\t\t} else\n\t\t\tthis.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);\n\n\t\t// If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\n\t\tif (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + SETUP;\n\t}\n\n\tsetAttachment (skeleton: Skeleton, slot: Slot, attachmentName: string | null, attachments: boolean) {\n\t\tslot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n\t\tif (attachments) slot.attachmentState = this.unkeyedState + CURRENT;\n\t}\n\n\tapplyRotateTimeline (timeline: RotateTimeline, skeleton: Skeleton, time: number, alpha: number, blend: MixBlend,\n\t\ttimelinesRotation: Array<number>, i: number, firstFrame: boolean) {\n\n\t\tif (firstFrame) timelinesRotation[i] = 0;\n\n\t\tif (alpha == 1) {\n\t\t\ttimeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n\t\t\treturn;\n\t\t}\n\n\t\tlet bone = skeleton.bones[timeline.boneIndex];\n\t\tif (!bone.active) return;\n\t\tlet frames = timeline.frames;\n\t\tlet r1 = 0, r2 = 0;\n\t\tif (time < frames[0]) {\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tbone.rotation = bone.data.rotation;\n\t\t\t\tdefault:\n\t\t\t\t\treturn;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tr1 = bone.rotation;\n\t\t\t\t\tr2 = bone.data.rotation;\n\t\t\t}\n\t\t} else {\n\t\t\tr1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n\t\t\tr2 = bone.data.rotation + timeline.getCurveValue(time);\n\t\t}\n\n\t\t// Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\n\t\tlet total = 0, diff = r2 - r1;\n\t\tdiff -= Math.ceil(diff / 360 - 0.5) * 360;\n\t\tif (diff == 0) {\n\t\t\ttotal = timelinesRotation[i];\n\t\t} else {\n\t\t\tlet lastTotal = 0, lastDiff = 0;\n\t\t\tif (firstFrame) {\n\t\t\t\tlastTotal = 0;\n\t\t\t\tlastDiff = diff;\n\t\t\t} else {\n\t\t\t\tlastTotal = timelinesRotation[i];\n\t\t\t\tlastDiff = timelinesRotation[i + 1];\n\t\t\t}\n\t\t\tlet loops = lastTotal - lastTotal % 360;\n\t\t\ttotal = diff + loops;\n\t\t\tlet current = diff >= 0, dir = lastTotal >= 0;\n\t\t\tif (Math.abs(lastDiff) <= 90 && MathUtils.signum(lastDiff) != MathUtils.signum(diff)) {\n\t\t\t\tif (Math.abs(lastTotal - loops) > 180) {\n\t\t\t\t\ttotal += 360 * MathUtils.signum(lastTotal);\n\t\t\t\t\tdir = current;\n\t\t\t\t} else if (loops != 0)\n\t\t\t\t\ttotal -= 360 * MathUtils.signum(lastTotal);\n\t\t\t\telse\n\t\t\t\t\tdir = current;\n\t\t\t}\n\t\t\tif (dir != current) total += 360 * MathUtils.signum(lastTotal);\n\t\t\ttimelinesRotation[i] = total;\n\t\t}\n\t\ttimelinesRotation[i + 1] = diff;\n\t\tbone.rotation = r1 + total * alpha;\n\t}\n\n\tqueueEvents (entry: TrackEntry, animationTime: number) {\n\t\tlet animationStart = entry.animationStart, animationEnd = entry.animationEnd;\n\t\tlet duration = animationEnd - animationStart;\n\t\tlet trackLastWrapped = entry.trackLast % duration;\n\n\t\t// Queue events before complete.\n\t\tlet events = this.events;\n\t\tlet i = 0, n = events.length;\n\t\tfor (; i < n; i++) {\n\t\t\tlet event = events[i];\n\t\t\tif (event.time < trackLastWrapped) break;\n\t\t\tif (event.time > animationEnd) continue; // Discard events outside animation start/end.\n\t\t\tthis.queue.event(entry, event);\n\t\t}\n\n\t\t// Queue complete if completed a loop iteration or the animation.\n\t\tlet complete = false;\n\t\tif (entry.loop) {\n\t\t\tif (duration == 0)\n\t\t\t\tcomplete = true;\n\t\t\telse {\n\t\t\t\tconst cycles = Math.floor(entry.trackTime / duration);\n\t\t\t\tcomplete = cycles > 0 && cycles > Math.floor(entry.trackLast / duration);\n\t\t\t}\n\t\t} else\n\t\t\tcomplete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n\t\tif (complete) this.queue.complete(entry);\n\n\t\t// Queue events after complete.\n\t\tfor (; i < n; i++) {\n\t\t\tlet event = events[i];\n\t\t\tif (event.time < animationStart) continue; // Discard events outside animation start/end.\n\t\t\tthis.queue.event(entry, event);\n\t\t}\n\t}\n\n\t/** Removes all animations from all tracks, leaving skeletons in their current pose.\n\t *\n\t * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n\t * rather than leaving them in their current pose. */\n\tclearTracks () {\n\t\tlet oldDrainDisabled = this.queue.drainDisabled;\n\t\tthis.queue.drainDisabled = true;\n\t\tfor (let i = 0, n = this.tracks.length; i < n; i++)\n\t\t\tthis.clearTrack(i);\n\t\tthis.tracks.length = 0;\n\t\tthis.queue.drainDisabled = oldDrainDisabled;\n\t\tthis.queue.drain();\n\t}\n\n\t/** Removes all animations from the track, leaving skeletons in their current pose.\n\t *\n\t * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n\t * rather than leaving them in their current pose. */\n\tclearTrack (trackIndex: number) {\n\t\tif (trackIndex >= this.tracks.length) return;\n\t\tlet current = this.tracks[trackIndex];\n\t\tif (!current) return;\n\n\t\tthis.queue.end(current);\n\n\t\tthis.clearNext(current);\n\n\t\tlet entry = current;\n\t\twhile (true) {\n\t\t\tlet from = entry.mixingFrom;\n\t\t\tif (!from) break;\n\t\t\tthis.queue.end(from);\n\t\t\tentry.mixingFrom = null;\n\t\t\tentry.mixingTo = null;\n\t\t\tentry = from;\n\t\t}\n\n\t\tthis.tracks[current.trackIndex] = null;\n\n\t\tthis.queue.drain();\n\t}\n\n\tsetCurrent (index: number, current: TrackEntry, interrupt: boolean) {\n\t\tlet from = this.expandToIndex(index);\n\t\tthis.tracks[index] = current;\n\t\tcurrent.previous = null;\n\n\t\tif (from) {\n\t\t\tif (interrupt) this.queue.interrupt(from);\n\t\t\tcurrent.mixingFrom = from;\n\t\t\tfrom.mixingTo = current;\n\t\t\tcurrent.mixTime = 0;\n\n\t\t\t// Store the interrupted mix percentage.\n\t\t\tif (from.mixingFrom && from.mixDuration > 0)\n\t\t\t\tcurrent.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n\n\t\t\tfrom.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\n\t\t}\n\n\t\tthis.queue.start(current);\n\t}\n\n\t/** Sets an animation by name.\n\t  *\n\t  * See {@link #setAnimationWith()}. */\n\tsetAnimation (trackIndex: number, animationName: string, loop: boolean = false) {\n\t\tlet animation = this.data.skeletonData.findAnimation(animationName);\n\t\tif (!animation) throw new Error(\"Animation not found: \" + animationName);\n\t\treturn this.setAnimationWith(trackIndex, animation, loop);\n\t}\n\n\t/** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\n\t * applied to a skeleton, it is replaced (not mixed from).\n\t * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n\t *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\n\t * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n\t *         after the {@link AnimationStateListener#dispose()} event occurs. */\n\tsetAnimationWith (trackIndex: number, animation: Animation, loop: boolean = false) {\n\t\tif (!animation) throw new Error(\"animation cannot be null.\");\n\t\tlet interrupt = true;\n\t\tlet current = this.expandToIndex(trackIndex);\n\t\tif (current) {\n\t\t\tif (current.nextTrackLast == -1) {\n\t\t\t\t// Don't mix from an entry that was never applied.\n\t\t\t\tthis.tracks[trackIndex] = current.mixingFrom;\n\t\t\t\tthis.queue.interrupt(current);\n\t\t\t\tthis.queue.end(current);\n\t\t\t\tthis.clearNext(current);\n\t\t\t\tcurrent = current.mixingFrom;\n\t\t\t\tinterrupt = false;\n\t\t\t} else\n\t\t\t\tthis.clearNext(current);\n\t\t}\n\t\tlet entry = this.trackEntry(trackIndex, animation, loop, current);\n\t\tthis.setCurrent(trackIndex, entry, interrupt);\n\t\tthis.queue.drain();\n\t\treturn entry;\n\t}\n\n\t/** Queues an animation by name.\n\t *\n\t * See {@link #addAnimationWith()}. */\n\taddAnimation (trackIndex: number, animationName: string, loop: boolean = false, delay: number = 0) {\n\t\tlet animation = this.data.skeletonData.findAnimation(animationName);\n\t\tif (!animation) throw new Error(\"Animation not found: \" + animationName);\n\t\treturn this.addAnimationWith(trackIndex, animation, loop, delay);\n\t}\n\n\t/** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\n\t * equivalent to calling {@link #setAnimationWith()}.\n\t * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n\t *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\n\t *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\n\t *           previous entry is looping, its next loop completion is used instead of its duration.\n\t * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n\t *         after the {@link AnimationStateListener#dispose()} event occurs. */\n\taddAnimationWith (trackIndex: number, animation: Animation, loop: boolean = false, delay: number = 0) {\n\t\tif (!animation) throw new Error(\"animation cannot be null.\");\n\n\t\tlet last = this.expandToIndex(trackIndex);\n\t\tif (last) {\n\t\t\twhile (last.next)\n\t\t\t\tlast = last.next;\n\t\t}\n\n\t\tlet entry = this.trackEntry(trackIndex, animation, loop, last);\n\n\t\tif (!last) {\n\t\t\tthis.setCurrent(trackIndex, entry, true);\n\t\t\tthis.queue.drain();\n\t\t} else {\n\t\t\tlast.next = entry;\n\t\t\tentry.previous = last;\n\t\t\tif (delay <= 0) delay += last.getTrackComplete() - entry.mixDuration;\n\t\t}\n\n\t\tentry.delay = delay;\n\t\treturn entry;\n\t}\n\n\t/** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\n\t * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\n\t *\n\t * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\n\t * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\n\t * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\n\t * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\n\t * 0 still mixes out over one frame.\n\t *\n\t * Mixing in is done by first setting an empty animation, then adding an animation using\n\t * {@link #addAnimation()} and on the returned track entry, set the\n\t * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\n\t * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\n\t * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\n\tsetEmptyAnimation (trackIndex: number, mixDuration: number = 0) {\n\t\tlet entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation(), false);\n\t\tentry.mixDuration = mixDuration;\n\t\tentry.trackEnd = mixDuration;\n\t\treturn entry;\n\t}\n\n\t/** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\n\t * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\n\t * {@link #setEmptyAnimation()}.\n\t *\n\t * See {@link #setEmptyAnimation()}.\n\t * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n\t *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\n\t *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\n\t *           loop completion is used instead of its duration.\n\t * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\n\t *         after the {@link AnimationStateListener#dispose()} event occurs. */\n\taddEmptyAnimation (trackIndex: number, mixDuration: number = 0, delay: number = 0) {\n\t\tlet entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation(), false, delay);\n\t\tif (delay <= 0) entry.delay += entry.mixDuration - mixDuration;\n\t\tentry.mixDuration = mixDuration;\n\t\tentry.trackEnd = mixDuration;\n\t\treturn entry;\n\t}\n\n\t/** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\n\t  * duration. */\n\tsetEmptyAnimations (mixDuration: number = 0) {\n\t\tlet oldDrainDisabled = this.queue.drainDisabled;\n\t\tthis.queue.drainDisabled = true;\n\t\tfor (let i = 0, n = this.tracks.length; i < n; i++) {\n\t\t\tlet current = this.tracks[i];\n\t\t\tif (current) this.setEmptyAnimation(current.trackIndex, mixDuration);\n\t\t}\n\t\tthis.queue.drainDisabled = oldDrainDisabled;\n\t\tthis.queue.drain();\n\t}\n\n\texpandToIndex (index: number) {\n\t\tif (index < this.tracks.length) return this.tracks[index];\n\t\tUtils.ensureArrayCapacity(this.tracks, index + 1, null);\n\t\tthis.tracks.length = index + 1;\n\t\treturn null;\n\t}\n\n\t/** @param last May be null. */\n\ttrackEntry (trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry | null) {\n\t\tlet entry = this.trackEntryPool.obtain();\n\t\tentry.reset();\n\t\tentry.trackIndex = trackIndex;\n\t\tentry.animation = animation;\n\t\tentry.loop = loop;\n\t\tentry.holdPrevious = false;\n\n\t\tentry.reverse = false;\n\t\tentry.shortestRotation = false;\n\n\t\tentry.eventThreshold = 0;\n\t\tentry.alphaAttachmentThreshold = 0;\n\t\tentry.mixAttachmentThreshold = 0;\n\t\tentry.mixDrawOrderThreshold = 0;\n\n\t\tentry.animationStart = 0;\n\t\tentry.animationEnd = animation.duration;\n\t\tentry.animationLast = -1;\n\t\tentry.nextAnimationLast = -1;\n\n\t\tentry.delay = 0;\n\t\tentry.trackTime = 0;\n\t\tentry.trackLast = -1;\n\t\tentry.nextTrackLast = -1;\n\t\tentry.trackEnd = Number.MAX_VALUE;\n\t\tentry.timeScale = 1;\n\n\t\tentry.alpha = 1;\n\t\tentry.mixTime = 0;\n\t\tentry.mixDuration = !last ? 0 : this.data.getMix(last.animation!, animation);\n\t\tentry.interruptAlpha = 1;\n\t\tentry.totalAlpha = 0;\n\t\tentry.mixBlend = MixBlend.replace;\n\t\treturn entry;\n\t}\n\n\t/** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */\n\tclearNext (entry: TrackEntry) {\n\t\tlet next = entry.next;\n\t\twhile (next) {\n\t\t\tthis.queue.dispose(next);\n\t\t\tnext = next.next;\n\t\t}\n\t\tentry.next = null;\n\t}\n\n\t_animationsChanged () {\n\t\tthis.animationsChanged = false;\n\n\t\tthis.propertyIDs.clear();\n\t\tlet tracks = this.tracks;\n\t\tfor (let i = 0, n = tracks.length; i < n; i++) {\n\t\t\tlet entry = tracks[i];\n\t\t\tif (!entry) continue;\n\t\t\twhile (entry.mixingFrom)\n\t\t\t\tentry = entry.mixingFrom;\n\t\t\tdo {\n\t\t\t\tif (!entry.mixingTo || entry.mixBlend != MixBlend.add) this.computeHold(entry);\n\t\t\t\tentry = entry.mixingTo;\n\t\t\t} while (entry);\n\t\t}\n\t}\n\n\tcomputeHold (entry: TrackEntry) {\n\t\tlet to = entry.mixingTo;\n\t\tlet timelines = entry.animation!.timelines;\n\t\tlet timelinesCount = entry.animation!.timelines.length;\n\t\tlet timelineMode = entry.timelineMode;\n\t\ttimelineMode.length = timelinesCount;\n\t\tlet timelineHoldMix = entry.timelineHoldMix;\n\t\ttimelineHoldMix.length = 0;\n\t\tlet propertyIDs = this.propertyIDs;\n\n\t\tif (to && to.holdPrevious) {\n\t\t\tfor (let i = 0; i < timelinesCount; i++)\n\t\t\t\ttimelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;\n\t\t\treturn;\n\t\t}\n\n\t\touter:\n\t\tfor (let i = 0; i < timelinesCount; i++) {\n\t\t\tlet timeline = timelines[i];\n\t\t\tlet ids = timeline.getPropertyIds();\n\t\t\tif (!propertyIDs.addAll(ids))\n\t\t\t\ttimelineMode[i] = SUBSEQUENT;\n\t\t\telse if (!to || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline\n\t\t\t\t|| timeline instanceof EventTimeline || !to.animation!.hasTimeline(ids)) {\n\t\t\t\ttimelineMode[i] = FIRST;\n\t\t\t} else {\n\t\t\t\tfor (let next = to.mixingTo; next; next = next!.mixingTo) {\n\t\t\t\t\tif (next.animation!.hasTimeline(ids)) continue;\n\t\t\t\t\tif (entry.mixDuration > 0) {\n\t\t\t\t\t\ttimelineMode[i] = HOLD_MIX;\n\t\t\t\t\t\ttimelineHoldMix[i] = next;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttimelineMode[i] = HOLD_FIRST;\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\n\tgetCurrent (trackIndex: number) {\n\t\tif (trackIndex >= this.tracks.length) return null;\n\t\treturn this.tracks[trackIndex];\n\t}\n\n\t/** Adds a listener to receive events for all track entries. */\n\taddListener (listener: AnimationStateListener) {\n\t\tif (!listener) throw new Error(\"listener cannot be null.\");\n\t\tthis.listeners.push(listener);\n\t}\n\n\t/** Removes the listener added with {@link #addListener()}. */\n\tremoveListener (listener: AnimationStateListener) {\n\t\tlet index = this.listeners.indexOf(listener);\n\t\tif (index >= 0) this.listeners.splice(index, 1);\n\t}\n\n\t/** Removes all listeners added with {@link #addListener()}. */\n\tclearListeners () {\n\t\tthis.listeners.length = 0;\n\t}\n\n\t/** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\n\t * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\n\t * are not wanted because new animations are being set. */\n\tclearListenerNotifications () {\n\t\tthis.queue.clear();\n\t}\n}\n\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\n *\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs. */\nexport class TrackEntry {\n\t/** The animation to apply for this track entry. */\n\tanimation: Animation | null = null;\n\n\tprevious: TrackEntry | null = null;\n\n\t/** The animation queued to start after this animation, or null. `next` makes up a linked list. */\n\tnext: TrackEntry | null = null;\n\n\t/** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\n\t * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\n\tmixingFrom: TrackEntry | null = null;\n\n\t/** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\n\t * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\n\tmixingTo: TrackEntry | null = null;\n\n\t/** The listener for events generated by this track entry, or null.\n\t *\n\t * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\n\t * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\n\tlistener: AnimationStateListener | null = null;\n\n\t/** The index of the track where this track entry is either current or queued.\n\t *\n\t * See {@link AnimationState#getCurrent()}. */\n\ttrackIndex: number = 0;\n\n\t/** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n\t * duration. */\n\tloop: boolean = false;\n\n\t/** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\n\t * of being mixed out.\n\t *\n\t * When mixing between animations that key the same property, if a lower track also keys that property then the value will\n\t * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\n\t * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\n\t * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\n\t * keys the property, only when a higher track also keys the property.\n\t *\n\t * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\n\t * previous animation. */\n\tholdPrevious: boolean = false;\n\n\treverse: boolean = false;\n\n\tshortestRotation: boolean = false;\n\n\t/** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n\t * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\n\t * timelines are not applied while this animation is being mixed out. */\n\teventThreshold: number = 0;\n\n\t/** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\n\t * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\n\t * 0, so attachment timelines are not applied while this animation is being mixed out. */\n\tmixAttachmentThreshold: number = 0;\n\n\t/** When {@link #getAlpha()} is greater than <code>alphaAttachmentThreshold</code>, attachment timelines are applied.\n\t * Defaults to 0, so attachment timelines are always applied. */\n\talphaAttachmentThreshold: number = 0;\n\n\t/** When the mix percentage ({@link #getMixTime()} / {@link #getMixDuration()}) is less than the\n\t * <code>mixDrawOrderThreshold</code>, draw order timelines are applied while this animation is being mixed out. Defaults to\n\t * 0, so draw order timelines are not applied while this animation is being mixed out. */\n\tmixDrawOrderThreshold: number = 0;\n\n\t/** Seconds when this animation starts, both initially and after looping. Defaults to 0.\n\t *\n\t * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\n\t * value to prevent timeline keys before the start time from triggering. */\n\tanimationStart: number = 0;\n\n\t/** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\n\t * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\n\tanimationEnd: number = 0;\n\n\n\t/** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\n\t * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\n\t * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\n\t * is applied. */\n\tanimationLast: number = 0;\n\n\tnextAnimationLast: number = 0;\n\n\t/** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\n\t * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\n\t * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\n\t * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\n\t *\n\t * {@link #timeScale} affects the delay. */\n\tdelay: number = 0;\n\n\t/** Current time in seconds this track entry has been the current track entry. The track time determines\n\t * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\n\t * looping. */\n\ttrackTime: number = 0;\n\n\ttrackLast: number = 0; nextTrackLast: number = 0;\n\n\t/** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\n\t * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\n\t * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\n\t * properties keyed by the animation are set to the setup pose and the track is cleared.\n\t *\n\t * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\n\t * abruptly cease being applied. */\n\ttrackEnd: number = 0;\n\n\t/** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\n\t * faster. Defaults to 1.\n\t *\n\t * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\n\t * match the animation speed.\n\t *\n\t * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n\t * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\n\t * the time scale is not 1, the delay may need to be adjusted.\n\t *\n\t * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\n\ttimeScale: number = 0;\n\n\t/** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\n\t * to 1, which overwrites the skeleton's current pose with this animation.\n\t *\n\t * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\n\t * use alpha on track 0 if the skeleton pose is from the last frame render. */\n\talpha: number = 0;\n\n\t/** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\n\t * slightly more than `mixDuration` when the mix is complete. */\n\tmixTime: number = 0;\n\n\t/** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\n\t * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\n\t *\n\t * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\n\t * properties it was animating.\n\t *\n\t * The `mixDuration` can be set manually rather than use the value from\n\t * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\n\t * track entry only before {@link AnimationState#update(float)} is first called.\n\t *\n\t * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n\t * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\n\t * afterward. */\n\t_mixDuration: number = 0; interruptAlpha: number = 0; totalAlpha: number = 0;\n\n\tget mixDuration () {\n\t\treturn this._mixDuration;\n\t}\n\n\tset mixDuration (mixDuration: number) {\n\t\tthis._mixDuration = mixDuration;\n\t}\n\n\tsetMixDurationWithDelay (mixDuration: number, delay: number) {\n\t\tthis._mixDuration = mixDuration;\n\t\tif (this.previous != null && delay <= 0) delay += this.previous.getTrackComplete() - mixDuration;\n\t\tthis.delay = delay;\n\t}\n\n\t/** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\n\t * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\n\t * the values from the lower tracks.\n\t *\n\t * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\n\t * called. */\n\tmixBlend = MixBlend.replace;\n\ttimelineMode = new Array<number>();\n\ttimelineHoldMix = new Array<TrackEntry>();\n\ttimelinesRotation = new Array<number>();\n\n\treset () {\n\t\tthis.next = null;\n\t\tthis.previous = null;\n\t\tthis.mixingFrom = null;\n\t\tthis.mixingTo = null;\n\t\tthis.animation = null;\n\t\tthis.listener = null;\n\t\tthis.timelineMode.length = 0;\n\t\tthis.timelineHoldMix.length = 0;\n\t\tthis.timelinesRotation.length = 0;\n\t}\n\n\t/** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\n\t * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\n\t * `animationStart` time. */\n\tgetAnimationTime () {\n\t\tif (this.loop) {\n\t\t\tlet duration = this.animationEnd - this.animationStart;\n\t\t\tif (duration == 0) return this.animationStart;\n\t\t\treturn (this.trackTime % duration) + this.animationStart;\n\t\t}\n\t\treturn Math.min(this.trackTime + this.animationStart, this.animationEnd);\n\t}\n\n\tsetAnimationLast (animationLast: number) {\n\t\tthis.animationLast = animationLast;\n\t\tthis.nextAnimationLast = animationLast;\n\t}\n\n\t/** Returns true if at least one loop has been completed.\n\t *\n\t * See {@link AnimationStateListener#complete()}. */\n\tisComplete () {\n\t\treturn this.trackTime >= this.animationEnd - this.animationStart;\n\t}\n\n\t/** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\n\t * long way around when using {@link #alpha} and starting animations on other tracks.\n\t *\n\t * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\n\t * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\n\t * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\n\t * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\n\tresetRotationDirections () {\n\t\tthis.timelinesRotation.length = 0;\n\t}\n\n\tgetTrackComplete () {\n\t\tlet duration = this.animationEnd - this.animationStart;\n\t\tif (duration != 0) {\n\t\t\tif (this.loop) return duration * (1 + ((this.trackTime / duration) | 0)); // Completion of next loop.\n\t\t\tif (this.trackTime < duration) return duration; // Before duration.\n\t\t}\n\t\treturn this.trackTime; // Next update.\n\t}\n\n\t/** Returns true if this track entry has been applied at least once.\n\t * <p>\n\t * See {@link AnimationState#apply(Skeleton)}. */\n\twasApplied () {\n\t\treturn this.nextTrackLast != -1;\n\t}\n\n\t/** Returns true if there is a {@link #getNext()} track entry and it will become the current track entry during the next\n\t * {@link AnimationState#update(float)}. */\n\tisNextReady () {\n\t\treturn this.next != null && this.nextTrackLast - this.next.delay >= 0;\n\t}\n}\n\nexport class EventQueue {\n\tobjects: Array<any> = [];\n\tdrainDisabled = false;\n\tanimState: AnimationState;\n\n\tconstructor (animState: AnimationState) {\n\t\tthis.animState = animState;\n\t}\n\n\tstart (entry: TrackEntry) {\n\t\tthis.objects.push(EventType.start);\n\t\tthis.objects.push(entry);\n\t\tthis.animState.animationsChanged = true;\n\t}\n\n\tinterrupt (entry: TrackEntry) {\n\t\tthis.objects.push(EventType.interrupt);\n\t\tthis.objects.push(entry);\n\t}\n\n\tend (entry: TrackEntry) {\n\t\tthis.objects.push(EventType.end);\n\t\tthis.objects.push(entry);\n\t\tthis.animState.animationsChanged = true;\n\t}\n\n\tdispose (entry: TrackEntry) {\n\t\tthis.objects.push(EventType.dispose);\n\t\tthis.objects.push(entry);\n\t}\n\n\tcomplete (entry: TrackEntry) {\n\t\tthis.objects.push(EventType.complete);\n\t\tthis.objects.push(entry);\n\t}\n\n\tevent (entry: TrackEntry, event: Event) {\n\t\tthis.objects.push(EventType.event);\n\t\tthis.objects.push(entry);\n\t\tthis.objects.push(event);\n\t}\n\n\tdrain () {\n\t\tif (this.drainDisabled) return;\n\t\tthis.drainDisabled = true;\n\n\t\tlet objects = this.objects;\n\t\tlet listeners = this.animState.listeners;\n\n\t\tfor (let i = 0; i < objects.length; i += 2) {\n\t\t\tlet type = objects[i] as EventType;\n\t\t\tlet entry = objects[i + 1] as TrackEntry;\n\t\t\tswitch (type) {\n\t\t\t\tcase EventType.start:\n\t\t\t\t\tif (entry.listener && entry.listener.start) entry.listener.start(entry);\n\t\t\t\t\tfor (let ii = 0; ii < listeners.length; ii++) {\n\t\t\t\t\t\tlet listener = listeners[ii];\n\t\t\t\t\t\tif (listener.start) listener.start(entry);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase EventType.interrupt:\n\t\t\t\t\tif (entry.listener && entry.listener.interrupt) entry.listener.interrupt(entry);\n\t\t\t\t\tfor (let ii = 0; ii < listeners.length; ii++) {\n\t\t\t\t\t\tlet listener = listeners[ii];\n\t\t\t\t\t\tif (listener.interrupt) listener.interrupt(entry);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase EventType.end:\n\t\t\t\t\tif (entry.listener && entry.listener.end) entry.listener.end(entry);\n\t\t\t\t\tfor (let ii = 0; ii < listeners.length; ii++) {\n\t\t\t\t\t\tlet listener = listeners[ii];\n\t\t\t\t\t\tif (listener.end) listener.end(entry);\n\t\t\t\t\t}\n\t\t\t\t// Fall through.\n\t\t\t\tcase EventType.dispose:\n\t\t\t\t\tif (entry.listener && entry.listener.dispose) entry.listener.dispose(entry);\n\t\t\t\t\tfor (let ii = 0; ii < listeners.length; ii++) {\n\t\t\t\t\t\tlet listener = listeners[ii];\n\t\t\t\t\t\tif (listener.dispose) listener.dispose(entry);\n\t\t\t\t\t}\n\t\t\t\t\tthis.animState.trackEntryPool.free(entry);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EventType.complete:\n\t\t\t\t\tif (entry.listener && entry.listener.complete) entry.listener.complete(entry);\n\t\t\t\t\tfor (let ii = 0; ii < listeners.length; ii++) {\n\t\t\t\t\t\tlet listener = listeners[ii];\n\t\t\t\t\t\tif (listener.complete) listener.complete(entry);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase EventType.event:\n\t\t\t\t\tlet event = objects[i++ + 2] as Event;\n\t\t\t\t\tif (entry.listener && entry.listener.event) entry.listener.event(entry, event);\n\t\t\t\t\tfor (let ii = 0; ii < listeners.length; ii++) {\n\t\t\t\t\t\tlet listener = listeners[ii];\n\t\t\t\t\t\tif (listener.event) listener.event(entry, event);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.clear();\n\n\t\tthis.drainDisabled = false;\n\t}\n\n\tclear () {\n\t\tthis.objects.length = 0;\n\t}\n}\n\nexport enum EventType {\n\tstart, interrupt, end, dispose, complete, event\n}\n\n/** The interface to implement for receiving TrackEntry events. It is always safe to call AnimationState methods when receiving\n * events.\n *\n * See TrackEntry {@link TrackEntry#listener} and AnimationState\n * {@link AnimationState#addListener()}. */\nexport interface AnimationStateListener {\n\t/** Invoked when this entry has been set as the current entry. */\n\tstart?: (entry: TrackEntry) => void;\n\n\t/** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\n\t * mixing. */\n\tinterrupt?: (entry: TrackEntry) => void;\n\n\t/** Invoked when this entry is no longer the current entry and will never be applied again. */\n\tend?: (entry: TrackEntry) => void;\n\n\t/** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\n\t * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\n\tdispose?: (entry: TrackEntry) => void;\n\n\t/** Invoked every time this entry's animation completes a loop. */\n\tcomplete?: (entry: TrackEntry) => void;\n\n\t/** Invoked when this entry's animation triggers an event. */\n\tevent?: (entry: TrackEntry, event: Event) => void;\n}\n\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\n\tstart (entry: TrackEntry) {\n\t}\n\n\tinterrupt (entry: TrackEntry) {\n\t}\n\n\tend (entry: TrackEntry) {\n\t}\n\n\tdispose (entry: TrackEntry) {\n\t}\n\n\tcomplete (entry: TrackEntry) {\n\t}\n\n\tevent (entry: TrackEntry, event: Event) {\n\t}\n}\n\n/** 1. A previously applied timeline has set this property.\n *\n * Result: Mix from the current pose to the timeline pose. */\nexport const SUBSEQUENT = 0;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry applied after this one does not have a timeline to set this property.\n *\n * Result: Mix from the setup pose to the timeline pose. */\nexport const FIRST = 1;\n/** 1) A previously applied timeline has set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\n * animations that key the same property. A subsequent timeline will set this property using a mix. */\nexport const HOLD_SUBSEQUENT = 2;\n/** 1) This is the first timeline to set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\n * that key the same property. A subsequent timeline will set this property using a mix. */\nexport const HOLD_FIRST = 3;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry to be applied does have a timeline to set this property.\n * 3. The next track entry after that one does have a timeline to set this property.\n * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\n *\n * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\n * 2 track entries in a row have a timeline that sets the same property.\n *\n * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\n * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\n * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\n * place. */\nexport const HOLD_MIX = 4;\n\nexport const SETUP = 1;\nexport const CURRENT = 2;\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Animation } from \"./Animation.js\";\nimport { SkeletonData } from \"./SkeletonData.js\";\nimport { StringMap } from \"./Utils.js\";\n\n\n/** Stores mix (crossfade) durations to be applied when {@link AnimationState} animations are changed. */\nexport class AnimationStateData {\n\t/** The SkeletonData to look up animations when they are specified by name. */\n\tskeletonData: SkeletonData;\n\n\tanimationToMixTime: StringMap<number> = {};\n\n\t/** The mix duration to use when no mix duration has been defined between two animations. */\n\tdefaultMix = 0;\n\n\tconstructor (skeletonData: SkeletonData) {\n\t\tif (!skeletonData) throw new Error(\"skeletonData cannot be null.\");\n\t\tthis.skeletonData = skeletonData;\n\t}\n\n\t/** Sets a mix duration by animation name.\n\t *\n\t * See {@link #setMixWith()}. */\n\tsetMix (fromName: string, toName: string, duration: number) {\n\t\tlet from = this.skeletonData.findAnimation(fromName);\n\t\tif (!from) throw new Error(\"Animation not found: \" + fromName);\n\t\tlet to = this.skeletonData.findAnimation(toName);\n\t\tif (!to) throw new Error(\"Animation not found: \" + toName);\n\t\tthis.setMixWith(from, to, duration);\n\t}\n\n\t/** Sets the mix duration when changing from the specified animation to the other.\n\t *\n\t * See {@link TrackEntry#mixDuration}. */\n\tsetMixWith (from: Animation, to: Animation, duration: number) {\n\t\tif (!from) throw new Error(\"from cannot be null.\");\n\t\tif (!to) throw new Error(\"to cannot be null.\");\n\t\tlet key = from.name + \".\" + to.name;\n\t\tthis.animationToMixTime[key] = duration;\n\t}\n\n\t/** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if\n\t  * no mix duration has been set. */\n\tgetMix (from: Animation, to: Animation) {\n\t\tlet key = from.name + \".\" + to.name;\n\t\tlet value = this.animationToMixTime[key];\n\t\treturn value === undefined ? this.defaultMix : value;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Color } from \"../Utils.js\";\nimport { VertexAttachment, Attachment } from \"./Attachment.js\";\n\n/** An attachment with vertices that make up a polygon. Can be used for hit detection, creating physics bodies, spawning particle\n * effects, and more.\n *\n * See {@link SkeletonBounds} and [Bounding Boxes](http://esotericsoftware.com/spine-bounding-boxes) in the Spine User\n * Guide. */\nexport class BoundingBoxAttachment extends VertexAttachment {\n\tcolor = new Color(1, 1, 1, 1);\n\n\tconstructor (name: string) {\n\t\tsuper(name);\n\t}\n\n\tcopy (): Attachment {\n\t\tlet copy = new BoundingBoxAttachment(this.name);\n\t\tthis.copyTo(copy);\n\t\tcopy.color.setFromColor(this.color);\n\t\treturn copy;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { SlotData } from \"../SlotData.js\";\nimport { Color } from \"../Utils.js\";\nimport { VertexAttachment, Attachment } from \"./Attachment.js\";\n\n/** An attachment with vertices that make up a polygon used for clipping the rendering of other attachments. */\nexport class ClippingAttachment extends VertexAttachment {\n\t/** Clipping is performed between the clipping polygon's slot and the end slot. Returns null if clipping is done until the end of\n\t * the skeleton's rendering. */\n\tendSlot: SlotData | null = null;\n\n\t// Nonessential.\n\t/** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons\n\t * are not usually rendered at runtime. */\n\tcolor = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\n\n\tconstructor (name: string) {\n\t\tsuper(name);\n\t}\n\n\tcopy (): Attachment {\n\t\tlet copy = new ClippingAttachment(this.name);\n\t\tthis.copyTo(copy);\n\t\tcopy.endSlot = this.endSlot;\n\t\tcopy.color.setFromColor(this.color);\n\t\treturn copy;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport abstract class Texture {\n\tprotected _image: HTMLImageElement | ImageBitmap | any;\n\n\tconstructor (image: HTMLImageElement | ImageBitmap | any) {\n\t\tthis._image = image;\n\t}\n\n\tgetImage (): HTMLImageElement | ImageBitmap | any {\n\t\treturn this._image;\n\t}\n\n\tabstract setFilters (minFilter: TextureFilter, magFilter: TextureFilter): void;\n\tabstract setWraps (uWrap: TextureWrap, vWrap: TextureWrap): void;\n\tabstract dispose (): void;\n}\n\nexport enum TextureFilter {\n\tNearest = 9728, // WebGLRenderingContext.NEAREST\n\tLinear = 9729, // WebGLRenderingContext.LINEAR\n\tMipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n\tMipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\n\tMipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\n\tMipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\n\tMipMapLinearLinear = 9987 // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n}\n\nexport enum TextureWrap {\n\tMirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\n\tClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\n\tRepeat = 10497 // WebGLRenderingContext.REPEAT\n}\n\nexport class TextureRegion {\n\ttexture: any;\n\tu = 0; v = 0;\n\tu2 = 0; v2 = 0;\n\twidth = 0; height = 0;\n\tdegrees = 0;\n\toffsetX = 0; offsetY = 0;\n\toriginalWidth = 0; originalHeight = 0;\n}\n\nexport class FakeTexture extends Texture {\n\tsetFilters (minFilter: TextureFilter, magFilter: TextureFilter) { }\n\tsetWraps (uWrap: TextureWrap, vWrap: TextureWrap) { }\n\tdispose () { }\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { AssetManagerBase } from \"./AssetManagerBase.js\";\nimport { TextureFilter, TextureWrap, Texture, TextureRegion } from \"./Texture.js\";\nimport { Disposable, Utils, StringMap } from \"./Utils.js\";\n\nexport class TextureAtlas implements Disposable {\n\tpages = new Array<TextureAtlasPage>();\n\tregions = new Array<TextureAtlasRegion>();\n\n\tconstructor (atlasText: string) {\n\t\tlet reader = new TextureAtlasReader(atlasText);\n\t\tlet entry = new Array<string>(4);\n\n\t\tlet pageFields: StringMap<(page: TextureAtlasPage) => void> = {};\n\t\tpageFields[\"size\"] = (page: TextureAtlasPage) => {\n\t\t\tpage!.width = parseInt(entry[1]);\n\t\t\tpage!.height = parseInt(entry[2]);\n\t\t};\n\t\tpageFields[\"format\"] = () => {\n\t\t\t// page.format = Format[tuple[0]]; we don't need format in WebGL\n\t\t};\n\t\tpageFields[\"filter\"] = (page: TextureAtlasPage) => {\n\t\t\tpage!.minFilter = Utils.enumValue(TextureFilter, entry[1]);\n\t\t\tpage!.magFilter = Utils.enumValue(TextureFilter, entry[2]);\n\t\t};\n\t\tpageFields[\"repeat\"] = (page: TextureAtlasPage) => {\n\t\t\tif (entry[1].indexOf('x') != -1) page!.uWrap = TextureWrap.Repeat;\n\t\t\tif (entry[1].indexOf('y') != -1) page!.vWrap = TextureWrap.Repeat;\n\t\t};\n\t\tpageFields[\"pma\"] = (page: TextureAtlasPage) => {\n\t\t\tpage!.pma = entry[1] == \"true\";\n\t\t};\n\n\t\tvar regionFields: StringMap<(region: TextureAtlasRegion) => void> = {};\n\t\tregionFields[\"xy\"] = (region: TextureAtlasRegion) => { // Deprecated, use bounds.\n\t\t\tregion.x = parseInt(entry[1]);\n\t\t\tregion.y = parseInt(entry[2]);\n\t\t};\n\t\tregionFields[\"size\"] = (region: TextureAtlasRegion) => { // Deprecated, use bounds.\n\t\t\tregion.width = parseInt(entry[1]);\n\t\t\tregion.height = parseInt(entry[2]);\n\t\t};\n\t\tregionFields[\"bounds\"] = (region: TextureAtlasRegion) => {\n\t\t\tregion.x = parseInt(entry[1]);\n\t\t\tregion.y = parseInt(entry[2]);\n\t\t\tregion.width = parseInt(entry[3]);\n\t\t\tregion.height = parseInt(entry[4]);\n\t\t};\n\t\tregionFields[\"offset\"] = (region: TextureAtlasRegion) => { // Deprecated, use offsets.\n\t\t\tregion.offsetX = parseInt(entry[1]);\n\t\t\tregion.offsetY = parseInt(entry[2]);\n\t\t};\n\t\tregionFields[\"orig\"] = (region: TextureAtlasRegion) => { // Deprecated, use offsets.\n\t\t\tregion.originalWidth = parseInt(entry[1]);\n\t\t\tregion.originalHeight = parseInt(entry[2]);\n\t\t};\n\t\tregionFields[\"offsets\"] = (region: TextureAtlasRegion) => {\n\t\t\tregion.offsetX = parseInt(entry[1]);\n\t\t\tregion.offsetY = parseInt(entry[2]);\n\t\t\tregion.originalWidth = parseInt(entry[3]);\n\t\t\tregion.originalHeight = parseInt(entry[4]);\n\t\t};\n\t\tregionFields[\"rotate\"] = (region: TextureAtlasRegion) => {\n\t\t\tlet value = entry[1];\n\t\t\tif (value == \"true\")\n\t\t\t\tregion.degrees = 90;\n\t\t\telse if (value != \"false\")\n\t\t\t\tregion.degrees = parseInt(value);\n\t\t};\n\t\tregionFields[\"index\"] = (region: TextureAtlasRegion) => {\n\t\t\tregion.index = parseInt(entry[1]);\n\t\t};\n\n\t\tlet line = reader.readLine();\n\t\t// Ignore empty lines before first entry.\n\t\twhile (line && line.trim().length == 0)\n\t\t\tline = reader.readLine();\n\t\t// Header entries.\n\t\twhile (true) {\n\t\t\tif (!line || line.trim().length == 0) break;\n\t\t\tif (reader.readEntry(entry, line) == 0) break; // Silently ignore all header fields.\n\t\t\tline = reader.readLine();\n\t\t}\n\n\t\t// Page and region entries.\n\t\tlet page: TextureAtlasPage | null = null;\n\t\tlet names: string[] | null = null;\n\t\tlet values: number[][] | null = null;\n\t\twhile (true) {\n\t\t\tif (line === null) break;\n\t\t\tif (line.trim().length == 0) {\n\t\t\t\tpage = null;\n\t\t\t\tline = reader.readLine();\n\t\t\t} else if (!page) {\n\t\t\t\tpage = new TextureAtlasPage(line.trim());\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (reader.readEntry(entry, line = reader.readLine()) == 0) break;\n\t\t\t\t\tlet field = pageFields[entry[0]];\n\t\t\t\t\tif (field) field(page);\n\t\t\t\t}\n\t\t\t\tthis.pages.push(page);\n\t\t\t} else {\n\t\t\t\tlet region = new TextureAtlasRegion(page, line);\n\n\t\t\t\twhile (true) {\n\t\t\t\t\tlet count = reader.readEntry(entry, line = reader.readLine());\n\t\t\t\t\tif (count == 0) break;\n\t\t\t\t\tlet field = regionFields[entry[0]];\n\t\t\t\t\tif (field)\n\t\t\t\t\t\tfield(region);\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!names) names = [];\n\t\t\t\t\t\tif (!values) values = [];\n\t\t\t\t\t\tnames.push(entry[0]);\n\t\t\t\t\t\tlet entryValues: number[] = [];\n\t\t\t\t\t\tfor (let i = 0; i < count; i++)\n\t\t\t\t\t\t\tentryValues.push(parseInt(entry[i + 1]));\n\t\t\t\t\t\tvalues.push(entryValues);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (region.originalWidth == 0 && region.originalHeight == 0) {\n\t\t\t\t\tregion.originalWidth = region.width;\n\t\t\t\t\tregion.originalHeight = region.height;\n\t\t\t\t}\n\t\t\t\tif (names && names.length > 0 && values && values.length > 0) {\n\t\t\t\t\tregion.names = names;\n\t\t\t\t\tregion.values = values;\n\t\t\t\t\tnames = null;\n\t\t\t\t\tvalues = null;\n\t\t\t\t}\n\t\t\t\tregion.u = region.x / page.width;\n\t\t\t\tregion.v = region.y / page.height;\n\t\t\t\tif (region.degrees == 90) {\n\t\t\t\t\tregion.u2 = (region.x + region.height) / page.width;\n\t\t\t\t\tregion.v2 = (region.y + region.width) / page.height;\n\t\t\t\t} else {\n\t\t\t\t\tregion.u2 = (region.x + region.width) / page.width;\n\t\t\t\t\tregion.v2 = (region.y + region.height) / page.height;\n\t\t\t\t}\n\t\t\t\tthis.regions.push(region);\n\t\t\t}\n\t\t}\n\t}\n\n\tfindRegion (name: string): TextureAtlasRegion | null {\n\t\tfor (let i = 0; i < this.regions.length; i++) {\n\t\t\tif (this.regions[i].name == name) {\n\t\t\t\treturn this.regions[i];\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tsetTextures (assetManager: AssetManagerBase, pathPrefix: string = \"\") {\n\t\tfor (let page of this.pages)\n\t\t\tpage.setTexture(assetManager.get(pathPrefix + page.name));\n\t}\n\n\tdispose () {\n\t\tfor (let i = 0; i < this.pages.length; i++) {\n\t\t\tthis.pages[i].texture?.dispose();\n\t\t}\n\t}\n}\n\nclass TextureAtlasReader {\n\tlines: Array<string>;\n\tindex: number = 0;\n\n\tconstructor (text: string) {\n\t\tthis.lines = text.split(/\\r\\n|\\r|\\n/);\n\t}\n\n\treadLine (): string | null {\n\t\tif (this.index >= this.lines.length)\n\t\t\treturn null;\n\t\treturn this.lines[this.index++];\n\t}\n\n\treadEntry (entry: string[], line: string | null): number {\n\t\tif (!line) return 0;\n\t\tline = line.trim();\n\t\tif (line.length == 0) return 0;\n\n\t\tlet colon = line.indexOf(':');\n\t\tif (colon == -1) return 0;\n\t\tentry[0] = line.substr(0, colon).trim();\n\t\tfor (let i = 1, lastMatch = colon + 1; ; i++) {\n\t\t\tlet comma = line.indexOf(',', lastMatch);\n\t\t\tif (comma == -1) {\n\t\t\t\tentry[i] = line.substr(lastMatch).trim();\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tentry[i] = line.substr(lastMatch, comma - lastMatch).trim();\n\t\t\tlastMatch = comma + 1;\n\t\t\tif (i == 4) return 4;\n\t\t}\n\t}\n}\n\nexport class TextureAtlasPage {\n\tname: string;\n\tminFilter: TextureFilter = TextureFilter.Nearest;\n\tmagFilter: TextureFilter = TextureFilter.Nearest;\n\tuWrap: TextureWrap = TextureWrap.ClampToEdge;\n\tvWrap: TextureWrap = TextureWrap.ClampToEdge;\n\ttexture: Texture | null = null;\n\twidth: number = 0;\n\theight: number = 0;\n\tpma: boolean = false;\n\tregions = new Array<TextureAtlasRegion>();\n\n\tconstructor (name: string) {\n\t\tthis.name = name;\n\t}\n\n\tsetTexture (texture: Texture) {\n\t\tthis.texture = texture;\n\t\ttexture.setFilters(this.minFilter, this.magFilter);\n\t\ttexture.setWraps(this.uWrap, this.vWrap);\n\t\tfor (let region of this.regions)\n\t\t\tregion.texture = texture;\n\t}\n}\n\nexport class TextureAtlasRegion extends TextureRegion {\n\tpage: TextureAtlasPage;\n\tname: string;\n\tx: number = 0;\n\ty: number = 0;\n\toffsetX: number = 0;\n\toffsetY: number = 0;\n\toriginalWidth: number = 0;\n\toriginalHeight: number = 0;\n\tindex: number = 0;\n\tdegrees: number = 0;\n\tnames: string[] | null = null;\n\tvalues: number[][] | null = null;\n\n\tconstructor (page: TextureAtlasPage, name: string) {\n\t\tsuper();\n\t\tthis.page = page;\n\t\tthis.name = name;\n\t\tpage.regions.push(this);\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { TextureRegion } from \"../Texture.js\";\nimport { TextureAtlasRegion } from \"../TextureAtlas.js\";\nimport { Color, NumberArrayLike, Utils } from \"../Utils.js\";\nimport { VertexAttachment, Attachment } from \"./Attachment.js\";\nimport { HasTextureRegion } from \"./HasTextureRegion.js\";\nimport { Sequence } from \"./Sequence.js\";\nimport { Slot } from \"../Slot.js\";\n\n/** An attachment that displays a textured mesh. A mesh has hull vertices and internal vertices within the hull. Holes are not\n * supported. Each vertex has UVs (texture coordinates) and triangles are used to map an image on to the mesh.\n *\n * See [Mesh attachments](http://esotericsoftware.com/spine-meshes) in the Spine User Guide. */\nexport class MeshAttachment extends VertexAttachment implements HasTextureRegion {\n\tregion: TextureRegion | null = null;\n\n\t/** The name of the texture region for this attachment. */\n\tpath: string;\n\n\t/** The UV pair for each vertex, normalized within the texture region. */\n\tregionUVs: NumberArrayLike = [];\n\n\t/** The UV pair for each vertex, normalized within the entire texture.\n\t *\n\t * See {@link #updateUVs}. */\n\tuvs: NumberArrayLike = [];\n\n\t/** Triplets of vertex indices which describe the mesh's triangulation. */\n\ttriangles: Array<number> = [];\n\n\t/** The color to tint the mesh. */\n\tcolor = new Color(1, 1, 1, 1);\n\n\t/** The width of the mesh's image. Available only when nonessential data was exported. */\n\twidth: number = 0;\n\n\t/** The height of the mesh's image. Available only when nonessential data was exported. */\n\theight: number = 0;\n\n\t/** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\n\thullLength: number = 0;\n\n\t/** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\n\t * nonessential data was exported. Triangulation is not performed at runtime. */\n\tedges: Array<number> = [];\n\n\tprivate parentMesh: MeshAttachment | null = null;\n\n\tsequence: Sequence | null = null;\n\n\ttempColor = new Color(0, 0, 0, 0);\n\n\tconstructor (name: string, path: string) {\n\t\tsuper(name);\n\t\tthis.path = path;\n\t}\n\n\t/** Calculates {@link #uvs} using the {@link #regionUVs} and region. Must be called if the region, the region's properties, or\n\t * the {@link #regionUVs} are changed. */\n\tupdateRegion () {\n\t\tif (!this.region) throw new Error(\"Region not set.\");\n\t\tlet regionUVs = this.regionUVs;\n\t\tif (!this.uvs || this.uvs.length != regionUVs.length) this.uvs = Utils.newFloatArray(regionUVs.length);\n\t\tlet uvs = this.uvs;\n\t\tlet n = this.uvs.length;\n\t\tlet u = this.region.u, v = this.region.v, width = 0, height = 0;\n\t\tif (this.region instanceof TextureAtlasRegion) {\n\t\t\tlet region = this.region, page = region.page;\n\t\t\tlet textureWidth = page.width, textureHeight = page.height;\n\t\t\tswitch (region.degrees) {\n\t\t\t\tcase 90:\n\t\t\t\t\tu -= (region.originalHeight - region.offsetY - region.height) / textureWidth;\n\t\t\t\t\tv -= (region.originalWidth - region.offsetX - region.width) / textureHeight;\n\t\t\t\t\twidth = region.originalHeight / textureWidth;\n\t\t\t\t\theight = region.originalWidth / textureHeight;\n\t\t\t\t\tfor (let i = 0; i < n; i += 2) {\n\t\t\t\t\t\tuvs[i] = u + regionUVs[i + 1] * width;\n\t\t\t\t\t\tuvs[i + 1] = v + (1 - regionUVs[i]) * height;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\tcase 180:\n\t\t\t\t\tu -= (region.originalWidth - region.offsetX - region.width) / textureWidth;\n\t\t\t\t\tv -= region.offsetY / textureHeight;\n\t\t\t\t\twidth = region.originalWidth / textureWidth;\n\t\t\t\t\theight = region.originalHeight / textureHeight;\n\t\t\t\t\tfor (let i = 0; i < n; i += 2) {\n\t\t\t\t\t\tuvs[i] = u + (1 - regionUVs[i]) * width;\n\t\t\t\t\t\tuvs[i + 1] = v + (1 - regionUVs[i + 1]) * height;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\tcase 270:\n\t\t\t\t\tu -= region.offsetY / textureWidth;\n\t\t\t\t\tv -= region.offsetX / textureHeight;\n\t\t\t\t\twidth = region.originalHeight / textureWidth;\n\t\t\t\t\theight = region.originalWidth / textureHeight;\n\t\t\t\t\tfor (let i = 0; i < n; i += 2) {\n\t\t\t\t\t\tuvs[i] = u + (1 - regionUVs[i + 1]) * width;\n\t\t\t\t\t\tuvs[i + 1] = v + regionUVs[i] * height;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tu -= region.offsetX / textureWidth;\n\t\t\tv -= (region.originalHeight - region.offsetY - region.height) / textureHeight;\n\t\t\twidth = region.originalWidth / textureWidth;\n\t\t\theight = region.originalHeight / textureHeight;\n\t\t} else if (!this.region) {\n\t\t\tu = v = 0;\n\t\t\twidth = height = 1;\n\t\t} else {\n\t\t\twidth = this.region.u2 - u;\n\t\t\theight = this.region.v2 - v;\n\t\t}\n\n\t\tfor (let i = 0; i < n; i += 2) {\n\t\t\tuvs[i] = u + regionUVs[i] * width;\n\t\t\tuvs[i + 1] = v + regionUVs[i + 1] * height;\n\t\t}\n\t}\n\n\t/** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\n\t * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\n\t * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\n\tgetParentMesh () {\n\t\treturn this.parentMesh;\n\t}\n\n\t/** @param parentMesh May be null. */\n\tsetParentMesh (parentMesh: MeshAttachment) {\n\t\tthis.parentMesh = parentMesh;\n\t\tif (parentMesh) {\n\t\t\tthis.bones = parentMesh.bones;\n\t\t\tthis.vertices = parentMesh.vertices;\n\t\t\tthis.worldVerticesLength = parentMesh.worldVerticesLength;\n\t\t\tthis.regionUVs = parentMesh.regionUVs;\n\t\t\tthis.triangles = parentMesh.triangles;\n\t\t\tthis.hullLength = parentMesh.hullLength;\n\t\t\tthis.worldVerticesLength = parentMesh.worldVerticesLength\n\t\t}\n\t}\n\n\tcopy (): Attachment {\n\t\tif (this.parentMesh) return this.newLinkedMesh();\n\n\t\tlet copy = new MeshAttachment(this.name, this.path);\n\t\tcopy.region = this.region;\n\t\tcopy.color.setFromColor(this.color);\n\n\t\tthis.copyTo(copy);\n\t\tcopy.regionUVs = new Array<number>(this.regionUVs.length);\n\t\tUtils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n\t\tcopy.uvs = new Array<number>(this.uvs.length);\n\t\tUtils.arrayCopy(this.uvs, 0, copy.uvs, 0, this.uvs.length);\n\t\tcopy.triangles = new Array<number>(this.triangles.length);\n\t\tUtils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n\t\tcopy.hullLength = this.hullLength;\n\n\t\tcopy.sequence = this.sequence != null ? this.sequence.copy() : null;\n\n\t\t// Nonessential.\n\t\tif (this.edges) {\n\t\t\tcopy.edges = new Array<number>(this.edges.length);\n\t\t\tUtils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n\t\t}\n\t\tcopy.width = this.width;\n\t\tcopy.height = this.height;\n\n\t\treturn copy;\n\t}\n\n\tcomputeWorldVertices (slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\n\t\tif (this.sequence != null) this.sequence.apply(slot, this);\n\t\tsuper.computeWorldVertices(slot, start, count, worldVertices, offset, stride);\n\t}\n\n\t/** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\n\tnewLinkedMesh (): MeshAttachment {\n\t\tlet copy = new MeshAttachment(this.name, this.path);\n\t\tcopy.region = this.region;\n\t\tcopy.color.setFromColor(this.color);\n\t\tcopy.timelineAttachment = this.timelineAttachment;\n\t\tcopy.setParentMesh(this.parentMesh ? this.parentMesh : this);\n\t\tif (copy.region != null) copy.updateRegion();\n\t\treturn copy;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Color, Utils } from \"../Utils.js\";\nimport { VertexAttachment, Attachment } from \"./Attachment.js\";\n\n/** An attachment whose vertices make up a composite Bezier curve.\n *\n * See {@link PathConstraint} and [Paths](http://esotericsoftware.com/spine-paths) in the Spine User Guide. */\nexport class PathAttachment extends VertexAttachment {\n\n\t/** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */\n\tlengths: Array<number> = [];\n\n\t/** If true, the start and end knots are connected. */\n\tclosed = false;\n\n\t/** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer\n\t * calculations are performed but calculating positions along the path is less accurate. */\n\tconstantSpeed = false;\n\n\t/** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually\n\t * rendered at runtime. */\n\tcolor = new Color(1, 1, 1, 1);\n\n\tconstructor (name: string) {\n\t\tsuper(name);\n\t}\n\n\tcopy (): Attachment {\n\t\tlet copy = new PathAttachment(this.name);\n\t\tthis.copyTo(copy);\n\t\tcopy.lengths = new Array<number>(this.lengths.length);\n\t\tUtils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\n\t\tcopy.closed = closed;\n\t\tcopy.constantSpeed = this.constantSpeed;\n\t\tcopy.color.setFromColor(this.color);\n\t\treturn copy;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Bone } from \"../Bone.js\";\nimport { Color, Vector2, MathUtils } from \"../Utils.js\";\nimport { VertexAttachment, Attachment } from \"./Attachment.js\";\n\n/** An attachment which is a single point and a rotation. This can be used to spawn projectiles, particles, etc. A bone can be\n * used in similar ways, but a PointAttachment is slightly less expensive to compute and can be hidden, shown, and placed in a\n * skin.\n *\n * See [Point Attachments](http://esotericsoftware.com/spine-point-attachments) in the Spine User Guide. */\nexport class PointAttachment extends VertexAttachment {\n\tx: number = 0;\n\ty: number = 0;\n\trotation: number = 0;\n\n\t/** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments\n\t * are not usually rendered at runtime. */\n\tcolor = new Color(0.38, 0.94, 0, 1);\n\n\tconstructor (name: string) {\n\t\tsuper(name);\n\t}\n\n\tcomputeWorldPosition (bone: Bone, point: Vector2) {\n\t\tpoint.x = this.x * bone.a + this.y * bone.b + bone.worldX;\n\t\tpoint.y = this.x * bone.c + this.y * bone.d + bone.worldY;\n\t\treturn point;\n\t}\n\n\tcomputeWorldRotation (bone: Bone) {\n\t\tconst r = this.rotation * MathUtils.degRad, cos = Math.cos(r), sin = Math.sin(r);\n\t\tconst x = cos * bone.a + sin * bone.b;\n\t\tconst y = cos * bone.c + sin * bone.d;\n\t\treturn MathUtils.atan2Deg(y, x);\t\t\n\t}\n\n\tcopy (): Attachment {\n\t\tlet copy = new PointAttachment(this.name);\n\t\tcopy.x = this.x;\n\t\tcopy.y = this.y;\n\t\tcopy.rotation = this.rotation;\n\t\tcopy.color.setFromColor(this.color);\n\t\treturn copy;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Bone } from \"../Bone.js\";\nimport { TextureRegion } from \"../Texture.js\";\nimport { Color, MathUtils, NumberArrayLike, Utils } from \"../Utils.js\";\nimport { Attachment } from \"./Attachment.js\";\nimport { HasTextureRegion } from \"./HasTextureRegion.js\";\nimport { Sequence } from \"./Sequence.js\";\nimport { Slot } from \"../Slot.js\";\n\n/** An attachment that displays a textured quadrilateral.\n *\n * See [Region attachments](http://esotericsoftware.com/spine-regions) in the Spine User Guide. */\nexport class RegionAttachment extends Attachment implements HasTextureRegion {\n\t/** The local x translation. */\n\tx = 0;\n\n\t/** The local y translation. */\n\ty = 0;\n\n\t/** The local scaleX. */\n\tscaleX = 1;\n\n\t/** The local scaleY. */\n\tscaleY = 1;\n\n\t/** The local rotation. */\n\trotation = 0;\n\n\t/** The width of the region attachment in Spine. */\n\twidth = 0;\n\n\t/** The height of the region attachment in Spine. */\n\theight = 0;\n\n\t/** The color to tint the region attachment. */\n\tcolor = new Color(1, 1, 1, 1);\n\n\t/** The name of the texture region for this attachment. */\n\tpath: string;\n\n\tregion: TextureRegion | null = null;\n\tsequence: Sequence | null = null;\n\n\t/** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.\n\t *\n\t * See {@link #updateOffset()}. */\n\toffset = Utils.newFloatArray(8);\n\n\tuvs = Utils.newFloatArray(8);\n\n\ttempColor = new Color(1, 1, 1, 1);\n\n\tconstructor (name: string, path: string) {\n\t\tsuper(name);\n\t\tthis.path = path;\n\t}\n\n\t/** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */\n\tupdateRegion (): void {\n\t\tif (!this.region) throw new Error(\"Region not set.\");\n\t\tlet region = this.region;\n\t\tlet uvs = this.uvs;\n\n\t\tif (region == null) {\n\t\t\tuvs[0] = 0;\n\t\t\tuvs[1] = 0;\n\t\t\tuvs[2] = 0;\n\t\t\tuvs[3] = 1;\n\t\t\tuvs[4] = 1;\n\t\t\tuvs[5] = 1;\n\t\t\tuvs[6] = 1;\n\t\t\tuvs[7] = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tlet regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n\t\tlet regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n\t\tlet localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n\t\tlet localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n\t\tlet localX2 = localX + this.region.width * regionScaleX;\n\t\tlet localY2 = localY + this.region.height * regionScaleY;\n\t\tlet radians = this.rotation * MathUtils.degRad;\n\t\tlet cos = Math.cos(radians);\n\t\tlet sin = Math.sin(radians);\n\t\tlet x = this.x, y = this.y;\n\t\tlet localXCos = localX * cos + x;\n\t\tlet localXSin = localX * sin;\n\t\tlet localYCos = localY * cos + y;\n\t\tlet localYSin = localY * sin;\n\t\tlet localX2Cos = localX2 * cos + x;\n\t\tlet localX2Sin = localX2 * sin;\n\t\tlet localY2Cos = localY2 * cos + y;\n\t\tlet localY2Sin = localY2 * sin;\n\t\tlet offset = this.offset;\n\t\toffset[0] = localXCos - localYSin;\n\t\toffset[1] = localYCos + localXSin;\n\t\toffset[2] = localXCos - localY2Sin;\n\t\toffset[3] = localY2Cos + localXSin;\n\t\toffset[4] = localX2Cos - localY2Sin;\n\t\toffset[5] = localY2Cos + localX2Sin;\n\t\toffset[6] = localX2Cos - localYSin;\n\t\toffset[7] = localYCos + localX2Sin;\n\n\t\tif (region.degrees == 90) {\n\t\t\tuvs[0] = region.u2;\n\t\t\tuvs[1] = region.v2;\n\t\t\tuvs[2] = region.u;\n\t\t\tuvs[3] = region.v2;\n\t\t\tuvs[4] = region.u;\n\t\t\tuvs[5] = region.v;\n\t\t\tuvs[6] = region.u2;\n\t\t\tuvs[7] = region.v;\n\t\t} else {\n\t\t\tuvs[0] = region.u;\n\t\t\tuvs[1] = region.v2;\n\t\t\tuvs[2] = region.u;\n\t\t\tuvs[3] = region.v;\n\t\t\tuvs[4] = region.u2;\n\t\t\tuvs[5] = region.v;\n\t\t\tuvs[6] = region.u2;\n\t\t\tuvs[7] = region.v2;\n\t\t}\n\t}\n\n\t/** Transforms the attachment's four vertices to world coordinates. If the attachment has a {@link #sequence}, the region may\n\t * be changed.\n\t * <p>\n\t * See <a href=\"http://esotericsoftware.com/spine-runtime-skeletons#World-transforms\">World transforms</a> in the Spine\n\t * Runtimes Guide.\n\t * @param worldVertices The output world vertices. Must have a length >= <code>offset</code> + 8.\n\t * @param offset The <code>worldVertices</code> index to begin writing values.\n\t * @param stride The number of <code>worldVertices</code> entries between the value pairs written. */\n\tcomputeWorldVertices (slot: Slot, worldVertices: NumberArrayLike, offset: number, stride: number) {\n\t\tif (this.sequence != null)\n\t\t\tthis.sequence.apply(slot, this);\n\n\t\tlet bone = slot.bone;\n\t\tlet vertexOffset = this.offset;\n\t\tlet x = bone.worldX, y = bone.worldY;\n\t\tlet a = bone.a, b = bone.b, c = bone.c, d = bone.d;\n\t\tlet offsetX = 0, offsetY = 0;\n\n\t\toffsetX = vertexOffset[0];\n\t\toffsetY = vertexOffset[1];\n\t\tworldVertices[offset] = offsetX * a + offsetY * b + x; // br\n\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n\t\toffset += stride;\n\n\t\toffsetX = vertexOffset[2];\n\t\toffsetY = vertexOffset[3];\n\t\tworldVertices[offset] = offsetX * a + offsetY * b + x; // bl\n\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n\t\toffset += stride;\n\n\t\toffsetX = vertexOffset[4];\n\t\toffsetY = vertexOffset[5];\n\t\tworldVertices[offset] = offsetX * a + offsetY * b + x; // ul\n\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n\t\toffset += stride;\n\n\t\toffsetX = vertexOffset[6];\n\t\toffsetY = vertexOffset[7];\n\t\tworldVertices[offset] = offsetX * a + offsetY * b + x; // ur\n\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n\t}\n\n\tcopy (): Attachment {\n\t\tlet copy = new RegionAttachment(this.name, this.path);\n\t\tcopy.region = this.region;\n\t\tcopy.x = this.x;\n\t\tcopy.y = this.y;\n\t\tcopy.scaleX = this.scaleX;\n\t\tcopy.scaleY = this.scaleY;\n\t\tcopy.rotation = this.rotation;\n\t\tcopy.width = this.width;\n\t\tcopy.height = this.height;\n\t\tUtils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\n\t\tUtils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\n\t\tcopy.color.setFromColor(this.color);\n\t\tcopy.sequence = this.sequence != null ? this.sequence.copy() : null;\n\t\treturn copy;\n\t}\n\n\tstatic X1 = 0;\n\tstatic Y1 = 1;\n\tstatic C1R = 2;\n\tstatic C1G = 3;\n\tstatic C1B = 4;\n\tstatic C1A = 5;\n\tstatic U1 = 6;\n\tstatic V1 = 7;\n\n\tstatic X2 = 8;\n\tstatic Y2 = 9;\n\tstatic C2R = 10;\n\tstatic C2G = 11;\n\tstatic C2B = 12;\n\tstatic C2A = 13;\n\tstatic U2 = 14;\n\tstatic V2 = 15;\n\n\tstatic X3 = 16;\n\tstatic Y3 = 17;\n\tstatic C3R = 18;\n\tstatic C3G = 19;\n\tstatic C3B = 20;\n\tstatic C3A = 21;\n\tstatic U3 = 22;\n\tstatic V3 = 23;\n\n\tstatic X4 = 24;\n\tstatic Y4 = 25;\n\tstatic C4R = 26;\n\tstatic C4G = 27;\n\tstatic C4B = 28;\n\tstatic C4A = 29;\n\tstatic U4 = 30;\n\tstatic V4 = 31;\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { AttachmentLoader } from \"./attachments/AttachmentLoader.js\";\nimport { BoundingBoxAttachment } from \"./attachments/BoundingBoxAttachment.js\";\nimport { ClippingAttachment } from \"./attachments/ClippingAttachment.js\";\nimport { MeshAttachment } from \"./attachments/MeshAttachment.js\";\nimport { PathAttachment } from \"./attachments/PathAttachment.js\";\nimport { PointAttachment } from \"./attachments/PointAttachment.js\";\nimport { RegionAttachment } from \"./attachments/RegionAttachment.js\";\nimport { Skin } from \"./Skin.js\";\nimport { TextureAtlas } from \"./TextureAtlas.js\";\nimport { Sequence } from \"./attachments/Sequence.js\"\n\n/** An {@link AttachmentLoader} that configures attachments using texture regions from an {@link TextureAtlas}.\n *\n * See [Loading skeleton data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the\n * Spine Runtimes Guide. */\nexport class AtlasAttachmentLoader implements AttachmentLoader {\n\tatlas: TextureAtlas;\n\n\tconstructor (atlas: TextureAtlas) {\n\t\tthis.atlas = atlas;\n\t}\n\n\tloadSequence (name: string, basePath: string, sequence: Sequence) {\n\t\tlet regions = sequence.regions;\n\t\tfor (let i = 0, n = regions.length; i < n; i++) {\n\t\t\tlet path = sequence.getPath(basePath, i);\n\t\t\tlet region = this.atlas.findRegion(path);\n\t\t\tif (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (sequence: \" + name + \")\");\n\t\t\tregions[i] = region;\n\t\t}\n\t}\n\n\tnewRegionAttachment (skin: Skin, name: string, path: string, sequence: Sequence): RegionAttachment {\n\t\tlet attachment = new RegionAttachment(name, path);\n\t\tif (sequence != null) {\n\t\t\tthis.loadSequence(name, path, sequence);\n\t\t} else {\n\t\t\tlet region = this.atlas.findRegion(path);\n\t\t\tif (!region) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\n\t\t\tattachment.region = region;\n\t\t}\n\t\treturn attachment;\n\t}\n\n\tnewMeshAttachment (skin: Skin, name: string, path: string, sequence: Sequence): MeshAttachment {\n\t\tlet attachment = new MeshAttachment(name, path);\n\t\tif (sequence != null) {\n\t\t\tthis.loadSequence(name, path, sequence);\n\t\t} else {\n\t\t\tlet region = this.atlas.findRegion(path);\n\t\t\tif (!region) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\n\t\t\tattachment.region = region;\n\t\t}\n\t\treturn attachment;\n\t}\n\n\tnewBoundingBoxAttachment (skin: Skin, name: string): BoundingBoxAttachment {\n\t\treturn new BoundingBoxAttachment(name);\n\t}\n\n\tnewPathAttachment (skin: Skin, name: string): PathAttachment {\n\t\treturn new PathAttachment(name);\n\t}\n\n\tnewPointAttachment (skin: Skin, name: string): PointAttachment {\n\t\treturn new PointAttachment(name);\n\t}\n\n\tnewClippingAttachment (skin: Skin, name: string): ClippingAttachment {\n\t\treturn new ClippingAttachment(name);\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Color } from \"./Utils.js\";\n\n/** Stores the setup pose for a {@link Bone}. */\nexport class BoneData {\n\t/** The index of the bone in {@link Skeleton#getBones()}. */\n\tindex: number = 0;\n\n\t/** The name of the bone, which is unique across all bones in the skeleton. */\n\tname: string;\n\n\t/** @returns May be null. */\n\tparent: BoneData | null = null;\n\n\t/** The bone's length. */\n\tlength: number = 0;\n\n\t/** The local x translation. */\n\tx = 0;\n\n\t/** The local y translation. */\n\ty = 0;\n\n\t/** The local rotation in degrees, counter clockwise. */\n\trotation = 0;\n\n\t/** The local scaleX. */\n\tscaleX = 1;\n\n\t/** The local scaleY. */\n\tscaleY = 1;\n\n\t/** The local shearX. */\n\tshearX = 0;\n\n\t/** The local shearX. */\n\tshearY = 0;\n\n\t/** The transform mode for how parent world transforms affect this bone. */\n\tinherit = Inherit.Normal;\n\n\t/** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this\n\t  * bone.\n\t  * @see Skin#bones */\n\tskinRequired = false;\n\n\t/** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually\n\t * rendered at runtime. */\n\tcolor = new Color();\n\n\t/** The bone icon as it was in Spine, or null if nonessential data was not exported. */\n\ticon?: string;\n\n\t/** False if the bone was hidden in Spine and nonessential data was exported. Does not affect runtime rendering. */\n\tvisible = false;\n\n\tconstructor (index: number, name: string, parent: BoneData | null) {\n\t\tif (index < 0) throw new Error(\"index must be >= 0.\");\n\t\tif (!name) throw new Error(\"name cannot be null.\");\n\t\tthis.index = index;\n\t\tthis.name = name;\n\t\tthis.parent = parent;\n\t}\n}\n\n/** Determines how a bone inherits world transforms from parent bones. */\nexport enum Inherit { Normal, OnlyTranslation, NoRotationOrReflection, NoScale, NoScaleOrReflection }\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { BoneData, Inherit } from \"./BoneData.js\";\nimport { Physics, Skeleton } from \"./Skeleton.js\";\nimport { Updatable } from \"./Updatable.js\";\nimport { MathUtils, Vector2 } from \"./Utils.js\";\n\n/** Stores a bone's current pose.\n *\n * A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a\n * local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a\n * constraint or application code modifies the world transform after it was computed from the local transform. */\nexport class Bone implements Updatable {\n\t/** The bone's setup pose data. */\n\tdata: BoneData;\n\n\t/** The skeleton this bone belongs to. */\n\tskeleton: Skeleton;\n\n\t/** The parent bone, or null if this is the root bone. */\n\tparent: Bone | null = null;\n\n\t/** The immediate children of this bone. */\n\tchildren = new Array<Bone>();\n\n\t/** The local x translation. */\n\tx = 0;\n\n\t/** The local y translation. */\n\ty = 0;\n\n\t/** The local rotation in degrees, counter clockwise. */\n\trotation = 0;\n\n\t/** The local scaleX. */\n\tscaleX = 0;\n\n\t/** The local scaleY. */\n\tscaleY = 0;\n\n\t/** The local shearX. */\n\tshearX = 0;\n\n\t/** The local shearY. */\n\tshearY = 0;\n\n\t/** The applied local x translation. */\n\tax = 0;\n\n\t/** The applied local y translation. */\n\tay = 0;\n\n\t/** The applied local rotation in degrees, counter clockwise. */\n\tarotation = 0;\n\n\t/** The applied local scaleX. */\n\tascaleX = 0;\n\n\t/** The applied local scaleY. */\n\tascaleY = 0;\n\n\t/** The applied local shearX. */\n\tashearX = 0;\n\n\t/** The applied local shearY. */\n\tashearY = 0;\n\n\t/** Part of the world transform matrix for the X axis. If changed, {@link #updateAppliedTransform()} should be called. */\n\ta = 0;\n\n\t/** Part of the world transform matrix for the Y axis. If changed, {@link #updateAppliedTransform()} should be called. */\n\tb = 0;\n\n\t/** Part of the world transform matrix for the X axis. If changed, {@link #updateAppliedTransform()} should be called. */\n\tc = 0;\n\n\t/** Part of the world transform matrix for the Y axis. If changed, {@link #updateAppliedTransform()} should be called. */\n\td = 0;\n\n\t/** The world X position. If changed, {@link #updateAppliedTransform()} should be called. */\n\tworldY = 0;\n\n\t/** The world Y position. If changed, {@link #updateAppliedTransform()} should be called. */\n\tworldX = 0;\n\n\tinherit: Inherit = Inherit.Normal;\n\n\tsorted = false;\n\tactive = false;\n\n\t/** @param parent May be null. */\n\tconstructor (data: BoneData, skeleton: Skeleton, parent: Bone | null) {\n\t\tif (!data) throw new Error(\"data cannot be null.\");\n\t\tif (!skeleton) throw new Error(\"skeleton cannot be null.\");\n\t\tthis.data = data;\n\t\tthis.skeleton = skeleton;\n\t\tthis.parent = parent;\n\t\tthis.setToSetupPose();\n\t}\n\n\t/** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the\n\t  * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */\n\tisActive () {\n\t\treturn this.active;\n\t}\n\n\t/** Computes the world transform using the parent bone and this bone's local applied transform. */\n\tupdate (physics: Physics) {\n\t\tthis.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);\n\t}\n\n\t/** Computes the world transform using the parent bone and this bone's local transform.\n\t *\n\t * See {@link #updateWorldTransformWith()}. */\n\tupdateWorldTransform () {\n\t\tthis.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n\t}\n\n\t/** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the\n\t * specified local transform. Child bones are not updated.\n\t *\n\t * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n\t * Runtimes Guide. */\n\tupdateWorldTransformWith (x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n\t\tthis.ax = x;\n\t\tthis.ay = y;\n\t\tthis.arotation = rotation;\n\t\tthis.ascaleX = scaleX;\n\t\tthis.ascaleY = scaleY;\n\t\tthis.ashearX = shearX;\n\t\tthis.ashearY = shearY;\n\n\t\tlet parent = this.parent;\n\t\tif (!parent) { // Root bone.\n\t\t\tlet skeleton = this.skeleton;\n\t\t\tconst sx = skeleton.scaleX, sy = skeleton.scaleY;\n\t\t\tconst rx = (rotation + shearX) * MathUtils.degRad;\n\t\t\tconst ry = (rotation + 90 + shearY) * MathUtils.degRad;\n\t\t\tthis.a = Math.cos(rx) * scaleX * sx;\n\t\t\tthis.b = Math.cos(ry) * scaleY * sx;\n\t\t\tthis.c = Math.sin(rx) * scaleX * sy;\n\t\t\tthis.d = Math.sin(ry) * scaleY * sy;\n\t\t\tthis.worldX = x * sx + skeleton.x;\n\t\t\tthis.worldY = y * sy + skeleton.y;\n\t\t\treturn;\n\t\t}\n\n\t\tlet pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\n\t\tthis.worldX = pa * x + pb * y + parent.worldX;\n\t\tthis.worldY = pc * x + pd * y + parent.worldY;\n\n\t\tswitch (this.inherit) {\n\t\t\tcase Inherit.Normal: {\n\t\t\t\tconst rx = (rotation + shearX) * MathUtils.degRad;\n\t\t\t\tconst ry = (rotation + 90 + shearY) * MathUtils.degRad;\n\t\t\t\tconst la = Math.cos(rx) * scaleX;\n\t\t\t\tconst lb = Math.cos(ry) * scaleY;\n\t\t\t\tconst lc = Math.sin(rx) * scaleX;\n\t\t\t\tconst ld = Math.sin(ry) * scaleY;\n\t\t\t\tthis.a = pa * la + pb * lc;\n\t\t\t\tthis.b = pa * lb + pb * ld;\n\t\t\t\tthis.c = pc * la + pd * lc;\n\t\t\t\tthis.d = pc * lb + pd * ld;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase Inherit.OnlyTranslation: {\n\t\t\t\tconst rx = (rotation + shearX) * MathUtils.degRad;\n\t\t\t\tconst ry = (rotation + 90 + shearY) * MathUtils.degRad;\n\t\t\t\tthis.a = Math.cos(rx) * scaleX;\n\t\t\t\tthis.b = Math.cos(ry) * scaleY;\n\t\t\t\tthis.c = Math.sin(rx) * scaleX;\n\t\t\t\tthis.d = Math.sin(ry) * scaleY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase Inherit.NoRotationOrReflection: {\n\t\t\t\tlet sx = 1 / this.skeleton.scaleX, sy = 1 / this.skeleton.scaleY;\n\t\t\t\tpa *= sx;\n\t\t\t\tpc *= sy;\n\t\t\t\tlet s = pa * pa + pc * pc;\n\t\t\t\tlet prx = 0;\n\t\t\t\tif (s > 0.0001) {\n\t\t\t\t\ts = Math.abs(pa * pd * sy - pb * sx * pc) / s;\n\t\t\t\t\tpb = pc * s;\n\t\t\t\t\tpd = pa * s;\n\t\t\t\t\tprx = Math.atan2(pc, pa) * MathUtils.radDeg;\n\t\t\t\t} else {\n\t\t\t\t\tpa = 0;\n\t\t\t\t\tpc = 0;\n\t\t\t\t\tprx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n\t\t\t\t}\n\t\t\t\tconst rx = (rotation + shearX - prx) * MathUtils.degRad;\n\t\t\t\tconst ry = (rotation + shearY - prx + 90) * MathUtils.degRad;\n\t\t\t\tconst la = Math.cos(rx) * scaleX;\n\t\t\t\tconst lb = Math.cos(ry) * scaleY;\n\t\t\t\tconst lc = Math.sin(rx) * scaleX;\n\t\t\t\tconst ld = Math.sin(ry) * scaleY;\n\t\t\t\tthis.a = pa * la - pb * lc;\n\t\t\t\tthis.b = pa * lb - pb * ld;\n\t\t\t\tthis.c = pc * la + pd * lc;\n\t\t\t\tthis.d = pc * lb + pd * ld;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase Inherit.NoScale:\n\t\t\tcase Inherit.NoScaleOrReflection: {\n\t\t\t\trotation *= MathUtils.degRad;\n\t\t\t\tconst cos = Math.cos(rotation), sin = Math.sin(rotation);\n\t\t\t\tlet za = (pa * cos + pb * sin) / this.skeleton.scaleX;\n\t\t\t\tlet zc = (pc * cos + pd * sin) / this.skeleton.scaleY;\n\t\t\t\tlet s = Math.sqrt(za * za + zc * zc);\n\t\t\t\tif (s > 0.00001) s = 1 / s;\n\t\t\t\tza *= s;\n\t\t\t\tzc *= s;\n\t\t\t\ts = Math.sqrt(za * za + zc * zc);\n\t\t\t\tif (this.inherit == Inherit.NoScale\n\t\t\t\t\t&& (pa * pd - pb * pc < 0) != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)) s = -s;\n\t\t\t\trotation = Math.PI / 2 + Math.atan2(zc, za);\n\t\t\t\tconst zb = Math.cos(rotation) * s;\n\t\t\t\tconst zd = Math.sin(rotation) * s;\n\t\t\t\tshearX *= MathUtils.degRad;\n\t\t\t\tshearY = (90 + shearY) * MathUtils.degRad;\n\t\t\t\tconst la = Math.cos(shearX) * scaleX;\n\t\t\t\tconst lb = Math.cos(shearY) * scaleY;\n\t\t\t\tconst lc = Math.sin(shearX) * scaleX;\n\t\t\t\tconst ld = Math.sin(shearY) * scaleY;\n\t\t\t\tthis.a = za * la + zb * lc;\n\t\t\t\tthis.b = za * lb + zb * ld;\n\t\t\t\tthis.c = zc * la + zd * lc;\n\t\t\t\tthis.d = zc * lb + zd * ld;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.a *= this.skeleton.scaleX;\n\t\tthis.b *= this.skeleton.scaleX;\n\t\tthis.c *= this.skeleton.scaleY;\n\t\tthis.d *= this.skeleton.scaleY;\n\t}\n\n\t/** Sets this bone's local transform to the setup pose. */\n\tsetToSetupPose () {\n\t\tlet data = this.data;\n\t\tthis.x = data.x;\n\t\tthis.y = data.y;\n\t\tthis.rotation = data.rotation;\n\t\tthis.scaleX = data.scaleX;\n\t\tthis.scaleY = data.scaleY;\n\t\tthis.shearX = data.shearX;\n\t\tthis.shearY = data.shearY;\n\t\tthis.inherit = data.inherit;\n\t}\n\n\t/** Computes the applied transform values from the world transform.\n\t *\n\t * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so\n\t * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other\n\t * constraints).\n\t *\n\t * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after\n\t * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */\n\tupdateAppliedTransform () {\n\t\tlet parent = this.parent;\n\t\tif (!parent) {\n\t\t\tthis.ax = this.worldX - this.skeleton.x;\n\t\t\tthis.ay = this.worldY - this.skeleton.y;\n\t\t\tthis.arotation = Math.atan2(this.c, this.a) * MathUtils.radDeg;\n\t\t\tthis.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);\n\t\t\tthis.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);\n\t\t\tthis.ashearX = 0;\n\t\t\tthis.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * MathUtils.radDeg;\n\t\t\treturn;\n\t\t}\n\t\tlet pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\n\t\tlet pid = 1 / (pa * pd - pb * pc);\n\t\tlet ia = pd * pid, ib = pb * pid, ic = pc * pid, id = pa * pid;\n\t\tlet dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;\n\t\tthis.ax = (dx * ia - dy * ib);\n\t\tthis.ay = (dy * id - dx * ic);\n\n\t\tlet ra, rb, rc, rd;\n\t\tif (this.inherit == Inherit.OnlyTranslation) {\n\t\t\tra = this.a;\n\t\t\trb = this.b;\n\t\t\trc = this.c;\n\t\t\trd = this.d;\n\t\t} else {\n\t\t\tswitch (this.inherit) {\n\t\t\t\tcase Inherit.NoRotationOrReflection: {\n\t\t\t\t\tlet s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\n\t\t\t\t\tpb = -pc * this.skeleton.scaleX * s / this.skeleton.scaleY;\n\t\t\t\t\tpd = pa * this.skeleton.scaleY * s / this.skeleton.scaleX;\n\t\t\t\t\tpid = 1 / (pa * pd - pb * pc);\n\t\t\t\t\tia = pd * pid;\n\t\t\t\t\tib = pb * pid;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase Inherit.NoScale:\n\t\t\t\tcase Inherit.NoScaleOrReflection:\n\t\t\t\t\tlet cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);\n\t\t\t\t\tpa = (pa * cos + pb * sin) / this.skeleton.scaleX;\n\t\t\t\t\tpc = (pc * cos + pd * sin) / this.skeleton.scaleY;\n\t\t\t\t\tlet s = Math.sqrt(pa * pa + pc * pc);\n\t\t\t\t\tif (s > 0.00001) s = 1 / s;\n\t\t\t\t\tpa *= s;\n\t\t\t\t\tpc *= s;\n\t\t\t\t\ts = Math.sqrt(pa * pa + pc * pc);\n\t\t\t\t\tif (this.inherit == Inherit.NoScale && pid < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)) s = -s;\n\t\t\t\t\tlet r = MathUtils.PI / 2 + Math.atan2(pc, pa);\n\t\t\t\t\tpb = Math.cos(r) * s;\n\t\t\t\t\tpd = Math.sin(r) * s;\n\t\t\t\t\tpid = 1 / (pa * pd - pb * pc);\n\t\t\t\t\tia = pd * pid;\n\t\t\t\t\tib = pb * pid;\n\t\t\t\t\tic = pc * pid;\n\t\t\t\t\tid = pa * pid;\n\t\t\t}\n\t\t\tra = ia * this.a - ib * this.c;\n\t\t\trb = ia * this.b - ib * this.d;\n\t\t\trc = id * this.c - ic * this.a;\n\t\t\trd = id * this.d - ic * this.b;\n\t\t}\n\n\t\tthis.ashearX = 0;\n\t\tthis.ascaleX = Math.sqrt(ra * ra + rc * rc);\n\t\tif (this.ascaleX > 0.0001) {\n\t\t\tlet det = ra * rd - rb * rc;\n\t\t\tthis.ascaleY = det / this.ascaleX;\n\t\t\tthis.ashearY = -Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n\t\t\tthis.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n\t\t} else {\n\t\t\tthis.ascaleX = 0;\n\t\t\tthis.ascaleY = Math.sqrt(rb * rb + rd * rd);\n\t\t\tthis.ashearY = 0;\n\t\t\tthis.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n\t\t}\n\t}\n\n\n\t/** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */\n\tgetWorldRotationX () {\n\t\treturn Math.atan2(this.c, this.a) * MathUtils.radDeg;\n\t}\n\n\t/** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */\n\tgetWorldRotationY () {\n\t\treturn Math.atan2(this.d, this.b) * MathUtils.radDeg;\n\t}\n\n\t/** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */\n\tgetWorldScaleX () {\n\t\treturn Math.sqrt(this.a * this.a + this.c * this.c);\n\t}\n\n\t/** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */\n\tgetWorldScaleY () {\n\t\treturn Math.sqrt(this.b * this.b + this.d * this.d);\n\t}\n\n\t/** Transforms a point from world coordinates to the bone's local coordinates. */\n\tworldToLocal (world: Vector2) {\n\t\tlet invDet = 1 / (this.a * this.d - this.b * this.c);\n\t\tlet x = world.x - this.worldX, y = world.y - this.worldY;\n\t\tworld.x = x * this.d * invDet - y * this.b * invDet;\n\t\tworld.y = y * this.a * invDet - x * this.c * invDet;\n\t\treturn world;\n\t}\n\n\t/** Transforms a point from the bone's local coordinates to world coordinates. */\n\tlocalToWorld (local: Vector2) {\n\t\tlet x = local.x, y = local.y;\n\t\tlocal.x = x * this.a + y * this.b + this.worldX;\n\t\tlocal.y = x * this.c + y * this.d + this.worldY;\n\t\treturn local;\n\t}\n\n\t/** Transforms a point from world coordinates to the parent bone's local coordinates. */\n\tworldToParent (world: Vector2) {\n\t\tif (world == null) throw new Error(\"world cannot be null.\");\n\t\treturn this.parent == null ? world : this.parent.worldToLocal(world);\n\t}\n\n\t/** Transforms a point from the parent bone's coordinates to world coordinates. */\n\tparentToWorld (world: Vector2) {\n\t\tif (world == null) throw new Error(\"world cannot be null.\");\n\t\treturn this.parent == null ? world : this.parent.localToWorld(world);\n\t}\n\n\t/** Transforms a world rotation to a local rotation. */\n\tworldToLocalRotation (worldRotation: number) {\n\t\tlet sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);\n\t\treturn Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * MathUtils.radDeg + this.rotation - this.shearX;\n\t}\n\n\t/** Transforms a local rotation to a world rotation. */\n\tlocalToWorldRotation (localRotation: number) {\n\t\tlocalRotation -= this.rotation - this.shearX;\n\t\tlet sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);\n\t\treturn Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * MathUtils.radDeg;\n\t}\n\n\t/** Rotates the world transform the specified amount.\n\t * <p>\n\t * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and\n\t * {@link #update(Physics)} will need to be called on any child bones, recursively. */\n\trotateWorld (degrees: number) {\n\t\tdegrees *= MathUtils.degRad;\n\t\tconst sin = Math.sin(degrees), cos = Math.cos(degrees);\n\t\tconst ra = this.a, rb = this.b;\n\t\tthis.a = cos * ra - sin * this.c;\n\t\tthis.b = cos * rb - sin * this.d;\n\t\tthis.c = sin * ra + cos * this.c;\n\t\tthis.d = sin * rb + cos * this.d;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\n/** The base class for all constraint datas. */\nexport abstract class ConstraintData {\n\tconstructor (public name: string, public order: number, public skinRequired: boolean) { }\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Texture } from \"./Texture.js\";\nimport { TextureAtlas } from \"./TextureAtlas.js\";\nimport { Disposable, StringMap } from \"./Utils.js\";\n\nexport class AssetManagerBase implements Disposable {\n\tprivate pathPrefix: string = \"\";\n\tprivate textureLoader: (image: HTMLImageElement | ImageBitmap) => Texture;\n\tprivate downloader: Downloader;\n\tprivate assets: StringMap<any> = {};\n\tprivate errors: StringMap<string> = {};\n\tprivate toLoad = 0;\n\tprivate loaded = 0;\n\n\tconstructor (textureLoader: (image: HTMLImageElement | ImageBitmap) => Texture, pathPrefix: string = \"\", downloader: Downloader = new Downloader()) {\n\t\tthis.textureLoader = textureLoader;\n\t\tthis.pathPrefix = pathPrefix;\n\t\tthis.downloader = downloader;\n\t}\n\n\tprivate start (path: string): string {\n\t\tthis.toLoad++;\n\t\treturn this.pathPrefix + path;\n\t}\n\n\tprivate success (callback: (path: string, data: any) => void, path: string, asset: any) {\n\t\tthis.toLoad--;\n\t\tthis.loaded++;\n\t\tthis.assets[path] = asset;\n\t\tif (callback) callback(path, asset);\n\t}\n\n\tprivate error (callback: (path: string, message: string) => void, path: string, message: string) {\n\t\tthis.toLoad--;\n\t\tthis.loaded++;\n\t\tthis.errors[path] = message;\n\t\tif (callback) callback(path, message);\n\t}\n\n\tloadAll () {\n\t\tlet promise = new Promise((resolve: (assetManager: AssetManagerBase) => void, reject: (errors: StringMap<string>) => void) => {\n\t\t\tlet check = () => {\n\t\t\t\tif (this.isLoadingComplete()) {\n\t\t\t\t\tif (this.hasErrors()) reject(this.errors);\n\t\t\t\t\telse resolve(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\trequestAnimationFrame(check);\n\t\t\t}\n\t\t\trequestAnimationFrame(check);\n\t\t});\n\t\treturn promise;\n\t}\n\n\tsetRawDataURI (path: string, data: string) {\n\t\tthis.downloader.rawDataUris[this.pathPrefix + path] = data;\n\t}\n\n\tloadBinary (path: string,\n\t\tsuccess: (path: string, binary: Uint8Array) => void = () => { },\n\t\terror: (path: string, message: string) => void = () => { }) {\n\t\tpath = this.start(path);\n\n\t\tthis.downloader.downloadBinary(path, (data: Uint8Array): void => {\n\t\t\tthis.success(success, path, data);\n\t\t}, (status: number, responseText: string): void => {\n\t\t\tthis.error(error, path, `Couldn't load binary ${path}: status ${status}, ${responseText}`);\n\t\t});\n\t}\n\n\tloadText (path: string,\n\t\tsuccess: (path: string, text: string) => void = () => { },\n\t\terror: (path: string, message: string) => void = () => { }) {\n\t\tpath = this.start(path);\n\n\t\tthis.downloader.downloadText(path, (data: string): void => {\n\t\t\tthis.success(success, path, data);\n\t\t}, (status: number, responseText: string): void => {\n\t\t\tthis.error(error, path, `Couldn't load text ${path}: status ${status}, ${responseText}`);\n\t\t});\n\t}\n\n\tloadJson (path: string,\n\t\tsuccess: (path: string, object: object) => void = () => { },\n\t\terror: (path: string, message: string) => void = () => { }) {\n\t\tpath = this.start(path);\n\n\t\tthis.downloader.downloadJson(path, (data: object): void => {\n\t\t\tthis.success(success, path, data);\n\t\t}, (status: number, responseText: string): void => {\n\t\t\tthis.error(error, path, `Couldn't load JSON ${path}: status ${status}, ${responseText}`);\n\t\t});\n\t}\n\n\tloadTexture (path: string,\n\t\tsuccess: (path: string, texture: Texture) => void = () => { },\n\t\terror: (path: string, message: string) => void = () => { }) {\n\t\tpath = this.start(path);\n\n\t\tlet isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document);\n\t\tlet isWebWorker = !isBrowser; // && typeof importScripts !== 'undefined';\n\t\tif (isWebWorker) {\n\t\t\tfetch(path, { mode: <RequestMode>\"cors\" }).then((response) => {\n\t\t\t\tif (response.ok) return response.blob();\n\t\t\t\tthis.error(error, path, `Couldn't load image: ${path}`);\n\t\t\t\treturn null;\n\t\t\t}).then((blob) => {\n\t\t\t\treturn blob ? createImageBitmap(blob, { premultiplyAlpha: \"none\", colorSpaceConversion: \"none\" }) : null;\n\t\t\t}).then((bitmap) => {\n\t\t\t\tif (bitmap) this.success(success, path, this.textureLoader(bitmap));\n\t\t\t});\n\t\t} else {\n\t\t\tlet image = new Image();\n\t\t\timage.crossOrigin = \"anonymous\";\n\t\t\timage.onload = () => {\n\t\t\t\tthis.success(success, path, this.textureLoader(image));\n\t\t\t};\n\t\t\timage.onerror = () => {\n\t\t\t\tthis.error(error, path, `Couldn't load image: ${path}`);\n\t\t\t};\n\t\t\tif (this.downloader.rawDataUris[path]) path = this.downloader.rawDataUris[path];\n\t\t\timage.src = path;\n\t\t}\n\t}\n\n\tloadTextureAtlas (path: string,\n\t\tsuccess: (path: string, atlas: TextureAtlas) => void = () => { },\n\t\terror: (path: string, message: string) => void = () => { },\n\t\tfileAlias?: { [keyword: string]: string }\n\t) {\n\t\tlet index = path.lastIndexOf(\"/\");\n\t\tlet parent = index >= 0 ? path.substring(0, index + 1) : \"\";\n\t\tpath = this.start(path);\n\n\t\tthis.downloader.downloadText(path, (atlasText: string): void => {\n\t\t\ttry {\n\t\t\t\tlet atlas = new TextureAtlas(atlasText);\n\t\t\t\tlet toLoad = atlas.pages.length, abort = false;\n\t\t\t\tfor (let page of atlas.pages) {\n\t\t\t\t\tthis.loadTexture(!fileAlias ? parent + page.name : fileAlias[page.name!],\n\t\t\t\t\t\t(imagePath: string, texture: Texture) => {\n\t\t\t\t\t\t\tif (!abort) {\n\t\t\t\t\t\t\t\tpage.setTexture(texture);\n\t\t\t\t\t\t\t\tif (--toLoad == 0) this.success(success, path, atlas);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(imagePath: string, message: string) => {\n\t\t\t\t\t\t\tif (!abort) this.error(error, path, `Couldn't load texture atlas ${path} page image: ${imagePath}`);\n\t\t\t\t\t\t\tabort = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthis.error(error, path, `Couldn't parse texture atlas ${path}: ${(e as any).message}`);\n\t\t\t}\n\t\t}, (status: number, responseText: string): void => {\n\t\t\tthis.error(error, path, `Couldn't load texture atlas ${path}: status ${status}, ${responseText}`);\n\t\t});\n\t}\n\n\tget (path: string) {\n\t\treturn this.assets[this.pathPrefix + path];\n\t}\n\n\trequire (path: string) {\n\t\tpath = this.pathPrefix + path;\n\t\tlet asset = this.assets[path];\n\t\tif (asset) return asset;\n\t\tlet error = this.errors[path];\n\t\tthrow Error(\"Asset not found: \" + path + (error ? \"\\n\" + error : \"\"));\n\t}\n\n\tremove (path: string) {\n\t\tpath = this.pathPrefix + path;\n\t\tlet asset = this.assets[path];\n\t\tif ((<any>asset).dispose) (<any>asset).dispose();\n\t\tdelete this.assets[path];\n\t\treturn asset;\n\t}\n\n\tremoveAll () {\n\t\tfor (let key in this.assets) {\n\t\t\tlet asset = this.assets[key];\n\t\t\tif ((<any>asset).dispose) (<any>asset).dispose();\n\t\t}\n\t\tthis.assets = {};\n\t}\n\n\tisLoadingComplete (): boolean {\n\t\treturn this.toLoad == 0;\n\t}\n\n\tgetToLoad (): number {\n\t\treturn this.toLoad;\n\t}\n\n\tgetLoaded (): number {\n\t\treturn this.loaded;\n\t}\n\n\tdispose () {\n\t\tthis.removeAll();\n\t}\n\n\thasErrors () {\n\t\treturn Object.keys(this.errors).length > 0;\n\t}\n\n\tgetErrors () {\n\t\treturn this.errors;\n\t}\n}\n\nexport class Downloader {\n\tprivate callbacks: StringMap<Array<Function>> = {};\n\trawDataUris: StringMap<string> = {};\n\n\tdataUriToString (dataUri: string) {\n\t\tif (!dataUri.startsWith(\"data:\")) {\n\t\t\tthrow new Error(\"Not a data URI.\");\n\t\t}\n\n\t\tlet base64Idx = dataUri.indexOf(\"base64,\");\n\t\tif (base64Idx != -1) {\n\t\t\tbase64Idx += \"base64,\".length;\n\t\t\treturn atob(dataUri.substr(base64Idx));\n\t\t} else {\n\t\t\treturn dataUri.substr(dataUri.indexOf(\",\") + 1);\n\t\t}\n\t}\n\n\tbase64ToUint8Array (base64: string) {\n\t\tvar binary_string = window.atob(base64);\n\t\tvar len = binary_string.length;\n\t\tvar bytes = new Uint8Array(len);\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tbytes[i] = binary_string.charCodeAt(i);\n\t\t}\n\t\treturn bytes;\n\t}\n\n\tdataUriToUint8Array (dataUri: string) {\n\t\tif (!dataUri.startsWith(\"data:\")) {\n\t\t\tthrow new Error(\"Not a data URI.\");\n\t\t}\n\n\t\tlet base64Idx = dataUri.indexOf(\"base64,\");\n\t\tif (base64Idx == -1) throw new Error(\"Not a binary data URI.\");\n\t\tbase64Idx += \"base64,\".length;\n\t\treturn this.base64ToUint8Array(dataUri.substr(base64Idx));\n\t}\n\n\tdownloadText (url: string, success: (data: string) => void, error: (status: number, responseText: string) => void) {\n\t\tif (this.start(url, success, error)) return;\n\t\tif (this.rawDataUris[url]) {\n\t\t\ttry {\n\t\t\t\tlet dataUri = this.rawDataUris[url];\n\t\t\t\tthis.finish(url, 200, this.dataUriToString(dataUri));\n\t\t\t} catch (e) {\n\t\t\t\tthis.finish(url, 400, JSON.stringify(e));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlet request = new XMLHttpRequest();\n\t\trequest.overrideMimeType(\"text/html\");\n\t\trequest.open(\"GET\", url, true);\n\t\tlet done = () => {\n\t\t\tthis.finish(url, request.status, request.responseText);\n\t\t};\n\t\trequest.onload = done;\n\t\trequest.onerror = done;\n\t\trequest.send();\n\t}\n\n\tdownloadJson (url: string, success: (data: object) => void, error: (status: number, responseText: string) => void) {\n\t\tthis.downloadText(url, (data: string): void => {\n\t\t\tsuccess(JSON.parse(data));\n\t\t}, error);\n\t}\n\n\tdownloadBinary (url: string, success: (data: Uint8Array) => void, error: (status: number, responseText: string) => void) {\n\t\tif (this.start(url, success, error)) return;\n\t\tif (this.rawDataUris[url]) {\n\t\t\ttry {\n\t\t\t\tlet dataUri = this.rawDataUris[url];\n\t\t\t\tthis.finish(url, 200, this.dataUriToUint8Array(dataUri));\n\t\t\t} catch (e) {\n\t\t\t\tthis.finish(url, 400, JSON.stringify(e));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlet request = new XMLHttpRequest();\n\t\trequest.open(\"GET\", url, true);\n\t\trequest.responseType = \"arraybuffer\";\n\t\tlet onerror = () => {\n\t\t\tthis.finish(url, request.status, request.response);\n\t\t};\n\t\trequest.onload = () => {\n\t\t\tif (request.status == 200 || request.status == 0)\n\t\t\t\tthis.finish(url, 200, new Uint8Array(request.response as ArrayBuffer));\n\t\t\telse\n\t\t\t\tonerror();\n\t\t};\n\t\trequest.onerror = onerror;\n\t\trequest.send();\n\t}\n\n\tprivate start (url: string, success: any, error: any) {\n\t\tlet callbacks = this.callbacks[url];\n\t\ttry {\n\t\t\tif (callbacks) return true;\n\t\t\tthis.callbacks[url] = callbacks = [];\n\t\t} finally {\n\t\t\tcallbacks.push(success, error);\n\t\t}\n\t}\n\n\tprivate finish (url: string, status: number, data: any) {\n\t\tlet callbacks = this.callbacks[url];\n\t\tdelete this.callbacks[url];\n\t\tlet args = status == 200 || status == 0 ? [data] : [status, data];\n\t\tfor (let i = args.length - 1, n = callbacks.length; i < n; i += 2)\n\t\t\tcallbacks[i].apply(null, args);\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { EventData } from \"./EventData.js\";\n\n/** Stores the current pose values for an {@link Event}.\n *\n * See Timeline {@link Timeline#apply()},\n * AnimationStateListener {@link AnimationStateListener#event()}, and\n * [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide. */\nexport class Event {\n\tdata: EventData;\n\tintValue: number = 0;\n\tfloatValue: number = 0;\n\tstringValue: string | null = null;\n\ttime: number = 0;\n\tvolume: number = 0;\n\tbalance: number = 0;\n\n\tconstructor (time: number, data: EventData) {\n\t\tif (!data) throw new Error(\"data cannot be null.\");\n\t\tthis.time = time;\n\t\tthis.data = data;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\n/** Stores the setup pose values for an {@link Event}.\n *\n * See [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide. */\nexport class EventData {\n\tname: string;\n\tintValue: number = 0;\n\tfloatValue: number = 0;\n\tstringValue: string | null = null;\n\taudioPath: string | null = null;\n\tvolume: number = 0;\n\tbalance: number = 0;\n\n\tconstructor (name: string) {\n\t\tthis.name = name;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Bone } from \"./Bone.js\";\nimport { Inherit } from \"./BoneData.js\";\nimport { IkConstraintData } from \"./IkConstraintData.js\";\nimport { Physics, Skeleton } from \"./Skeleton.js\";\nimport { Updatable } from \"./Updatable.js\";\nimport { MathUtils } from \"./Utils.js\";\n\n/** Stores the current pose for an IK constraint. An IK constraint adjusts the rotation of 1 or 2 constrained bones so the tip of\n * the last bone is as close to the target bone as possible.\n *\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide. */\nexport class IkConstraint implements Updatable {\n\t/** The IK constraint's setup pose data. */\n\tdata: IkConstraintData;\n\n\t/** The bones that will be modified by this IK constraint. */\n\tbones: Array<Bone>;\n\n\t/** The bone that is the IK target. */\n\ttarget: Bone;\n\n\t/** Controls the bend direction of the IK bones, either 1 or -1. */\n\tbendDirection = 0;\n\n\t/** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n\tcompress = false;\n\n\t/** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\n\t * and the parent bone has local nonuniform scale, stretch is not applied. */\n\tstretch = false;\n\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n\tmix = 1;\n\n\t/** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n\tsoftness = 0;\n\tactive = false;\n\n\tconstructor (data: IkConstraintData, skeleton: Skeleton) {\n\t\tif (!data) throw new Error(\"data cannot be null.\");\n\t\tif (!skeleton) throw new Error(\"skeleton cannot be null.\");\n\t\tthis.data = data;\n\n\t\tthis.bones = new Array<Bone>();\n\t\tfor (let i = 0; i < data.bones.length; i++) {\n\t\t\tlet bone = skeleton.findBone(data.bones[i].name);\n\t\t\tif (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}`);\n\t\t\tthis.bones.push(bone);\n\t\t}\n\t\tlet target = skeleton.findBone(data.target.name);\n\t\tif (!target) throw new Error(`Couldn't find bone ${data.target.name}`);\n\n\t\tthis.target = target;\n\t\tthis.mix = data.mix;\n\t\tthis.softness = data.softness;\n\t\tthis.bendDirection = data.bendDirection;\n\t\tthis.compress = data.compress;\n\t\tthis.stretch = data.stretch;\n\t}\n\n\tisActive () {\n\t\treturn this.active;\n\t}\n\n\tsetToSetupPose () {\n\t\tconst data = this.data;\n\t\tthis.mix = data.mix;\n\t\tthis.softness = data.softness;\n\t\tthis.bendDirection = data.bendDirection;\n\t\tthis.compress = data.compress;\n\t\tthis.stretch = data.stretch;\n\t}\n\n\tupdate (physics: Physics) {\n\t\tif (this.mix == 0) return;\n\t\tlet target = this.target;\n\t\tlet bones = this.bones;\n\t\tswitch (bones.length) {\n\t\t\tcase 1:\n\t\t\t\tthis.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/** Applies 1 bone IK. The target is specified in the world coordinate system. */\n\tapply1 (bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\n\t\tlet p = bone.parent;\n\t\tif (!p) throw new Error(\"IK bone must have parent.\");\n\t\tlet pa = p.a, pb = p.b, pc = p.c, pd = p.d;\n\t\tlet rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;\n\n\t\tswitch (bone.inherit) {\n\t\t\tcase Inherit.OnlyTranslation:\n\t\t\t\ttx = (targetX - bone.worldX) * MathUtils.signum(bone.skeleton.scaleX);\n\t\t\t\tty = (targetY - bone.worldY) * MathUtils.signum(bone.skeleton.scaleY);\n\t\t\t\tbreak;\n\t\t\tcase Inherit.NoRotationOrReflection:\n\t\t\t\tlet s = Math.abs(pa * pd - pb * pc) / Math.max(0.0001, pa * pa + pc * pc);\n\t\t\t\tlet sa = pa / bone.skeleton.scaleX;\n\t\t\t\tlet sc = pc / bone.skeleton.scaleY;\n\t\t\t\tpb = -sc * s * bone.skeleton.scaleX;\n\t\t\t\tpd = sa * s * bone.skeleton.scaleY;\n\t\t\t\trotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\n\t\t\t// Fall through\n\t\t\tdefault:\n\t\t\t\tlet x = targetX - p.worldX, y = targetY - p.worldY;\n\t\t\t\tlet d = pa * pd - pb * pc;\n\t\t\t\tif (Math.abs(d) <= 0.0001) {\n\t\t\t\t\ttx = 0;\n\t\t\t\t\tty = 0;\n\t\t\t\t} else {\n\t\t\t\t\ttx = (x * pd - y * pb) / d - bone.ax;\n\t\t\t\t\tty = (y * pa - x * pc) / d - bone.ay;\n\t\t\t\t}\n\t\t}\n\t\trotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\n\t\tif (bone.ascaleX < 0) rotationIK += 180;\n\t\tif (rotationIK > 180)\n\t\t\trotationIK -= 360;\n\t\telse if (rotationIK < -180)\n\t\t\trotationIK += 360;\n\t\tlet sx = bone.ascaleX, sy = bone.ascaleY;\n\t\tif (compress || stretch) {\n\t\t\tswitch (bone.inherit) {\n\t\t\t\tcase Inherit.NoScale:\n\t\t\t\tcase Inherit.NoScaleOrReflection:\n\t\t\t\t\ttx = targetX - bone.worldX;\n\t\t\t\t\tty = targetY - bone.worldY;\n\t\t\t}\n\t\t\tconst b = bone.data.length * sx;\n\t\t\tif (b > 0.0001) {\n\t\t\t\tconst dd = tx * tx + ty * ty;\n\t\t\t\tif ((compress && dd < b * b) || (stretch && dd > b * b)) {\n\t\t\t\t\tconst s = (Math.sqrt(dd) / b - 1) * alpha + 1;\n\t\t\t\t\tsx *= s;\n\t\t\t\t\tif (uniform) sy *= s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX,\n\t\t\tbone.ashearY);\n\t}\n\n\t/** Applies 2 bone IK. The target is specified in the world coordinate system.\n\t * @param child A direct descendant of the parent bone. */\n\tapply2 (parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, uniform: boolean, softness: number, alpha: number) {\n\t\tif (parent.inherit != Inherit.Normal || child.inherit != Inherit.Normal) return;\n\t\tlet px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, sx = psx, sy = psy, csx = child.ascaleX;\n\t\tlet os1 = 0, os2 = 0, s2 = 0;\n\t\tif (psx < 0) {\n\t\t\tpsx = -psx;\n\t\t\tos1 = 180;\n\t\t\ts2 = -1;\n\t\t} else {\n\t\t\tos1 = 0;\n\t\t\ts2 = 1;\n\t\t}\n\t\tif (psy < 0) {\n\t\t\tpsy = -psy;\n\t\t\ts2 = -s2;\n\t\t}\n\t\tif (csx < 0) {\n\t\t\tcsx = -csx;\n\t\t\tos2 = 180;\n\t\t} else\n\t\t\tos2 = 0;\n\t\tlet cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = parent.a, b = parent.b, c = parent.c, d = parent.d;\n\t\tlet u = Math.abs(psx - psy) <= 0.0001;\n\t\tif (!u || stretch) {\n\t\t\tcy = 0;\n\t\t\tcwx = a * cx + parent.worldX;\n\t\t\tcwy = c * cx + parent.worldY;\n\t\t} else {\n\t\t\tcy = child.ay;\n\t\t\tcwx = a * cx + b * cy + parent.worldX;\n\t\t\tcwy = c * cx + d * cy + parent.worldY;\n\t\t}\n\t\tlet pp = parent.parent;\n\t\tif (!pp) throw new Error(\"IK parent must itself have a parent.\");\n\t\ta = pp.a;\n\t\tb = pp.b;\n\t\tc = pp.c;\n\t\td = pp.d;\n\t\tlet id = a * d - b * c, x = cwx - pp.worldX, y = cwy - pp.worldY;\n\t\tid = Math.abs(id) <= 0.0001 ? 0 : 1 / id;\n\t\tlet dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\n\t\tlet l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\n\t\tif (l1 < 0.0001) {\n\t\t\tthis.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n\t\t\tchild.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n\t\t\treturn;\n\t\t}\n\t\tx = targetX - pp.worldX;\n\t\ty = targetY - pp.worldY;\n\t\tlet tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\n\t\tlet dd = tx * tx + ty * ty;\n\t\tif (softness != 0) {\n\t\t\tsoftness *= psx * (csx + 1) * 0.5;\n\t\t\tlet td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;\n\t\t\tif (sd > 0) {\n\t\t\t\tlet p = Math.min(1, sd / (softness * 2)) - 1;\n\t\t\t\tp = (sd - softness * (1 - p * p)) / td;\n\t\t\t\ttx -= p * tx;\n\t\t\t\tty -= p * ty;\n\t\t\t\tdd = tx * tx + ty * ty;\n\t\t\t}\n\t\t}\n\t\touter:\n\t\tif (u) {\n\t\t\tl2 *= psx;\n\t\t\tlet cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n\t\t\tif (cos < -1) {\n\t\t\t\tcos = -1;\n\t\t\t\ta2 = Math.PI * bendDir;\n\t\t\t} else if (cos > 1) {\n\t\t\t\tcos = 1;\n\t\t\t\ta2 = 0;\n\t\t\t\tif (stretch) {\n\t\t\t\t\ta = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n\t\t\t\t\tsx *= a;\n\t\t\t\t\tif (uniform) sy *= a;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ta2 = Math.acos(cos) * bendDir;\n\t\t\ta = l1 + l2 * cos;\n\t\t\tb = l2 * Math.sin(a2);\n\t\t\ta1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n\t\t} else {\n\t\t\ta = psx * l2;\n\t\t\tb = psy * l2;\n\t\t\tlet aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);\n\t\t\tc = bb * l1 * l1 + aa * dd - aa * bb;\n\t\t\tlet c1 = -2 * bb * l1, c2 = bb - aa;\n\t\t\td = c1 * c1 - 4 * c2 * c;\n\t\t\tif (d >= 0) {\n\t\t\t\tlet q = Math.sqrt(d);\n\t\t\t\tif (c1 < 0) q = -q;\n\t\t\t\tq = -(c1 + q) * 0.5;\n\t\t\t\tlet r0 = q / c2, r1 = c / q;\n\t\t\t\tlet r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n\t\t\t\tr0 = dd - r * r;\n\t\t\t\tif (r0 >= 0) {\n\t\t\t\t\ty = Math.sqrt(r0) * bendDir;\n\t\t\t\t\ta1 = ta - Math.atan2(y, r);\n\t\t\t\t\ta2 = Math.atan2(y / psy, (r - l1) / psx);\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet minAngle = MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\n\t\t\tlet maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\n\t\t\tc = -a * l1 / (aa - bb);\n\t\t\tif (c >= -1 && c <= 1) {\n\t\t\t\tc = Math.acos(c);\n\t\t\t\tx = a * Math.cos(c) + l1;\n\t\t\t\ty = b * Math.sin(c);\n\t\t\t\td = x * x + y * y;\n\t\t\t\tif (d < minDist) {\n\t\t\t\t\tminAngle = c;\n\t\t\t\t\tminDist = d;\n\t\t\t\t\tminX = x;\n\t\t\t\t\tminY = y;\n\t\t\t\t}\n\t\t\t\tif (d > maxDist) {\n\t\t\t\t\tmaxAngle = c;\n\t\t\t\t\tmaxDist = d;\n\t\t\t\t\tmaxX = x;\n\t\t\t\t\tmaxY = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dd <= (minDist + maxDist) * 0.5) {\n\t\t\t\ta1 = ta - Math.atan2(minY * bendDir, minX);\n\t\t\t\ta2 = minAngle * bendDir;\n\t\t\t} else {\n\t\t\t\ta1 = ta - Math.atan2(maxY * bendDir, maxX);\n\t\t\t\ta2 = maxAngle * bendDir;\n\t\t\t}\n\t\t}\n\t\tlet os = Math.atan2(cy, cx) * s2;\n\t\tlet rotation = parent.arotation;\n\t\ta1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n\t\tif (a1 > 180)\n\t\t\ta1 -= 360;\n\t\telse if (a1 < -180) //\n\t\t\ta1 += 360;\n\t\tparent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);\n\t\trotation = child.arotation;\n\t\ta2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n\t\tif (a2 > 180)\n\t\t\ta2 -= 360;\n\t\telse if (a2 < -180) //\n\t\t\ta2 += 360;\n\t\tchild.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { BoneData } from \"./BoneData.js\";\nimport { ConstraintData } from \"./ConstraintData.js\";\n\n\n/** Stores the setup pose for an {@link IkConstraint}.\n * <p>\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide. */\nexport class IkConstraintData extends ConstraintData {\n\t/** The bones that are constrained by this IK constraint. */\n\tbones = new Array<BoneData>();\n\n\t/** The bone that is the IK target. */\n\tprivate _target: BoneData | null = null;\n\tpublic set target (boneData: BoneData) { this._target = boneData; }\n\tpublic get target () {\n\t\tif (!this._target) throw new Error(\"BoneData not set.\")\n\t\telse return this._target;\n\t}\n\n\t/** Controls the bend direction of the IK bones, either 1 or -1. */\n\tbendDirection = 0;\n\n\t/** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n\tcompress = false;\n\n\t/** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\n\t * and the parent bone has local nonuniform scale, stretch is not applied. */\n\tstretch = false;\n\n\t/** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone\n\t * is scaled on both the X and Y axes. */\n\tuniform = false;\n\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n\tmix = 0;\n\n\t/** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n\tsoftness = 0;\n\n\tconstructor (name: string) {\n\t\tsuper(name, 0, false);\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { BoneData } from \"./BoneData.js\";\nimport { ConstraintData } from \"./ConstraintData.js\";\nimport { SlotData } from \"./SlotData.js\";\n\n\n/** Stores the setup pose for a {@link PathConstraint}.\n *\n * See [path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide. */\nexport class PathConstraintData extends ConstraintData {\n\n\t/** The bones that will be modified by this path constraint. */\n\tbones = new Array<BoneData>();\n\n\t/** The slot whose path attachment will be used to constrained the bones. */\n\tprivate _target: SlotData | null = null;\n\tpublic set target (slotData: SlotData) { this._target = slotData; }\n\tpublic get target () {\n\t\tif (!this._target) throw new Error(\"SlotData not set.\")\n\t\telse return this._target;\n\t}\n\n\t/** The mode for positioning the first bone on the path. */\n\tpositionMode: PositionMode = PositionMode.Fixed;\n\n\t/** The mode for positioning the bones after the first bone on the path. */\n\tspacingMode: SpacingMode = SpacingMode.Fixed;\n\n\t/** The mode for adjusting the rotation of the bones. */\n\trotateMode: RotateMode = RotateMode.Chain;\n\n\t/** An offset added to the constrained bone rotation. */\n\toffsetRotation: number = 0;\n\n\t/** The position along the path. */\n\tposition: number = 0;\n\n\t/** The spacing between bones. */\n\tspacing: number = 0;\n\n\tmixRotate = 0;\n\tmixX = 0;\n\tmixY = 0;\n\n\tconstructor (name: string) {\n\t\tsuper(name, 0, false);\n\t}\n}\n\n/** Controls how the first bone is positioned along the path.\n *\n * See [position](http://esotericsoftware.com/spine-path-constraints#Position) in the Spine User Guide. */\nexport enum PositionMode { Fixed, Percent }\n\n/** Controls how bones after the first bone are positioned along the path.\n *\n * See [spacing](http://esotericsoftware.com/spine-path-constraints#Spacing) in the Spine User Guide. */\nexport enum SpacingMode { Length, Fixed, Percent, Proportional }\n\n/** Controls how bones are rotated, translated, and scaled to match the path.\n *\n * See [rotate mix](http://esotericsoftware.com/spine-path-constraints#Rotate-mix) in the Spine User Guide. */\nexport enum RotateMode { Tangent, Chain, ChainScale }\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { PathAttachment } from \"./attachments/PathAttachment.js\";\nimport { Bone } from \"./Bone.js\";\nimport { PathConstraintData, RotateMode, SpacingMode, PositionMode } from \"./PathConstraintData.js\";\nimport { Physics, Skeleton } from \"./Skeleton.js\";\nimport { Slot } from \"./Slot.js\";\nimport { Updatable } from \"./Updatable.js\";\nimport { Utils, MathUtils } from \"./Utils.js\";\n\n\n/** Stores the current pose for a path constraint. A path constraint adjusts the rotation, translation, and scale of the\n * constrained bones so they follow a {@link PathAttachment}.\n *\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide. */\nexport class PathConstraint implements Updatable {\n\tstatic NONE = -1; static BEFORE = -2; static AFTER = -3;\n\tstatic epsilon = 0.00001;\n\n\t/** The path constraint's setup pose data. */\n\tdata: PathConstraintData;\n\n\t/** The bones that will be modified by this path constraint. */\n\tbones: Array<Bone>;\n\n\t/** The slot whose path attachment will be used to constrained the bones. */\n\ttarget: Slot;\n\n\t/** The position along the path. */\n\tposition = 0;\n\n\t/** The spacing between bones. */\n\tspacing = 0;\n\n\tmixRotate = 0;\n\n\tmixX = 0;\n\n\tmixY = 0;\n\n\tspaces = new Array<number>(); positions = new Array<number>();\n\tworld = new Array<number>(); curves = new Array<number>(); lengths = new Array<number>();\n\tsegments = new Array<number>();\n\n\tactive = false;\n\n\tconstructor (data: PathConstraintData, skeleton: Skeleton) {\n\t\tif (!data) throw new Error(\"data cannot be null.\");\n\t\tif (!skeleton) throw new Error(\"skeleton cannot be null.\");\n\t\tthis.data = data;\n\n\t\tthis.bones = new Array<Bone>();\n\t\tfor (let i = 0, n = data.bones.length; i < n; i++) {\n\t\t\tlet bone = skeleton.findBone(data.bones[i].name);\n\t\t\tif (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\n\t\t\tthis.bones.push(bone);\n\t\t}\n\t\tlet target = skeleton.findSlot(data.target.name);\n\t\tif (!target) throw new Error(`Couldn't find target bone ${data.target.name}`);\n\t\tthis.target = target;\n\n\t\tthis.position = data.position;\n\t\tthis.spacing = data.spacing;\n\t\tthis.mixRotate = data.mixRotate;\n\t\tthis.mixX = data.mixX;\n\t\tthis.mixY = data.mixY;\n\t}\n\n\tisActive () {\n\t\treturn this.active;\n\t}\n\n\tsetToSetupPose () {\n\t\tconst data = this.data;\n\t\tthis.position = data.position;\n\t\tthis.spacing = data.spacing;\n\t\tthis.mixRotate = data.mixRotate;\n\t\tthis.mixX = data.mixX;\n\t\tthis.mixY = data.mixY;\n\t}\n\n\tupdate (physics: Physics) {\n\t\tlet attachment = this.target.getAttachment();\n\t\tif (!(attachment instanceof PathAttachment)) return;\n\n\t\tlet mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY;\n\t\tif (mixRotate == 0 && mixX == 0 && mixY == 0) return;\n\n\t\tlet data = this.data;\n\t\tlet tangents = data.rotateMode == RotateMode.Tangent, scale = data.rotateMode == RotateMode.ChainScale;\n\n\t\tlet bones = this.bones;\n\t\tlet boneCount = bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\n\t\tlet spaces = Utils.setArraySize(this.spaces, spacesCount), lengths: Array<number> = scale ? this.lengths = Utils.setArraySize(this.lengths, boneCount) : [];\n\t\tlet spacing = this.spacing;\n\n\t\tswitch (data.spacingMode) {\n\t\t\tcase SpacingMode.Percent:\n\t\t\t\tif (scale) {\n\t\t\t\t\tfor (let i = 0, n = spacesCount - 1; i < n; i++) {\n\t\t\t\t\t\tlet bone = bones[i];\n\t\t\t\t\t\tlet setupLength = bone.data.length;\n\t\t\t\t\t\tlet x = setupLength * bone.a, y = setupLength * bone.c;\n\t\t\t\t\t\tlengths[i] = Math.sqrt(x * x + y * y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tUtils.arrayFill(spaces, 1, spacesCount, spacing);\n\t\t\t\tbreak;\n\t\t\tcase SpacingMode.Proportional:\n\t\t\t\tlet sum = 0;\n\t\t\t\tfor (let i = 0, n = spacesCount - 1; i < n;) {\n\t\t\t\t\tlet bone = bones[i];\n\t\t\t\t\tlet setupLength = bone.data.length;\n\t\t\t\t\tif (setupLength < PathConstraint.epsilon) {\n\t\t\t\t\t\tif (scale) lengths[i] = 0;\n\t\t\t\t\t\tspaces[++i] = spacing;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet x = setupLength * bone.a, y = setupLength * bone.c;\n\t\t\t\t\t\tlet length = Math.sqrt(x * x + y * y);\n\t\t\t\t\t\tif (scale) lengths[i] = length;\n\t\t\t\t\t\tspaces[++i] = length;\n\t\t\t\t\t\tsum += length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (sum > 0) {\n\t\t\t\t\tsum = spacesCount / sum * spacing;\n\t\t\t\t\tfor (let i = 1; i < spacesCount; i++)\n\t\t\t\t\t\tspaces[i] *= sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlet lengthSpacing = data.spacingMode == SpacingMode.Length;\n\t\t\t\tfor (let i = 0, n = spacesCount - 1; i < n;) {\n\t\t\t\t\tlet bone = bones[i];\n\t\t\t\t\tlet setupLength = bone.data.length;\n\t\t\t\t\tif (setupLength < PathConstraint.epsilon) {\n\t\t\t\t\t\tif (scale) lengths[i] = 0;\n\t\t\t\t\t\tspaces[++i] = spacing;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet x = setupLength * bone.a, y = setupLength * bone.c;\n\t\t\t\t\t\tlet length = Math.sqrt(x * x + y * y);\n\t\t\t\t\t\tif (scale) lengths[i] = length;\n\t\t\t\t\t\tspaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t\tlet positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents);\n\t\tlet boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\n\t\tlet tip = false;\n\t\tif (offsetRotation == 0)\n\t\t\ttip = data.rotateMode == RotateMode.Chain;\n\t\telse {\n\t\t\ttip = false;\n\t\t\tlet p = this.target.bone;\n\t\t\toffsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n\t\t}\n\t\tfor (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n\t\t\tlet bone = bones[i];\n\t\t\tbone.worldX += (boneX - bone.worldX) * mixX;\n\t\t\tbone.worldY += (boneY - bone.worldY) * mixY;\n\t\t\tlet x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\n\t\t\tif (scale) {\n\t\t\t\tlet length = lengths[i];\n\t\t\t\tif (length != 0) {\n\t\t\t\t\tlet s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;\n\t\t\t\t\tbone.a *= s;\n\t\t\t\t\tbone.c *= s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboneX = x;\n\t\t\tboneY = y;\n\t\t\tif (mixRotate > 0) {\n\t\t\t\tlet a = bone.a, b = bone.b, c = bone.c, d = bone.d, r = 0, cos = 0, sin = 0;\n\t\t\t\tif (tangents)\n\t\t\t\t\tr = positions[p - 1];\n\t\t\t\telse if (spaces[i + 1] == 0)\n\t\t\t\t\tr = positions[p + 2];\n\t\t\t\telse\n\t\t\t\t\tr = Math.atan2(dy, dx);\n\t\t\t\tr -= Math.atan2(c, a);\n\t\t\t\tif (tip) {\n\t\t\t\t\tcos = Math.cos(r);\n\t\t\t\t\tsin = Math.sin(r);\n\t\t\t\t\tlet length = bone.data.length;\n\t\t\t\t\tboneX += (length * (cos * a - sin * c) - dx) * mixRotate;\n\t\t\t\t\tboneY += (length * (sin * a + cos * c) - dy) * mixRotate;\n\t\t\t\t} else {\n\t\t\t\t\tr += offsetRotation;\n\t\t\t\t}\n\t\t\t\tif (r > MathUtils.PI)\n\t\t\t\t\tr -= MathUtils.PI2;\n\t\t\t\telse if (r < -MathUtils.PI) //\n\t\t\t\t\tr += MathUtils.PI2;\n\t\t\t\tr *= mixRotate;\n\t\t\t\tcos = Math.cos(r);\n\t\t\t\tsin = Math.sin(r);\n\t\t\t\tbone.a = cos * a - sin * c;\n\t\t\t\tbone.b = cos * b - sin * d;\n\t\t\t\tbone.c = sin * a + cos * c;\n\t\t\t\tbone.d = sin * b + cos * d;\n\t\t\t}\n\t\t\tbone.updateAppliedTransform();\n\t\t}\n\t}\n\n\tcomputeWorldPositions (path: PathAttachment, spacesCount: number, tangents: boolean) {\n\t\tlet target = this.target;\n\t\tlet position = this.position;\n\t\tlet spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world: Array<number> = this.world;\n\t\tlet closed = path.closed;\n\t\tlet verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\n\n\t\tif (!path.constantSpeed) {\n\t\t\tlet lengths = path.lengths;\n\t\t\tcurveCount -= closed ? 1 : 2;\n\t\t\tlet pathLength = lengths[curveCount];\n\t\t\tif (this.data.positionMode == PositionMode.Percent) position *= pathLength;\n\n\t\t\tlet multiplier;\n\t\t\tswitch (this.data.spacingMode) {\n\t\t\t\tcase SpacingMode.Percent:\n\t\t\t\t\tmultiplier = pathLength;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SpacingMode.Proportional:\n\t\t\t\t\tmultiplier = pathLength / spacesCount;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmultiplier = 1;\n\t\t\t}\n\t\t\tworld = Utils.setArraySize(this.world, 8);\n\t\t\tfor (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n\t\t\t\tlet space = spaces[i] * multiplier;\n\t\t\t\tposition += space;\n\t\t\t\tlet p = position;\n\n\t\t\t\tif (closed) {\n\t\t\t\t\tp %= pathLength;\n\t\t\t\t\tif (p < 0) p += pathLength;\n\t\t\t\t\tcurve = 0;\n\t\t\t\t} else if (p < 0) {\n\t\t\t\t\tif (prevCurve != PathConstraint.BEFORE) {\n\t\t\t\t\t\tprevCurve = PathConstraint.BEFORE;\n\t\t\t\t\t\tpath.computeWorldVertices(target, 2, 4, world, 0, 2);\n\t\t\t\t\t}\n\t\t\t\t\tthis.addBeforePosition(p, world, 0, out, o);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (p > pathLength) {\n\t\t\t\t\tif (prevCurve != PathConstraint.AFTER) {\n\t\t\t\t\t\tprevCurve = PathConstraint.AFTER;\n\t\t\t\t\t\tpath.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n\t\t\t\t\t}\n\t\t\t\t\tthis.addAfterPosition(p - pathLength, world, 0, out, o);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Determine curve containing position.\n\t\t\t\tfor (; ; curve++) {\n\t\t\t\t\tlet length = lengths[curve];\n\t\t\t\t\tif (p > length) continue;\n\t\t\t\t\tif (curve == 0)\n\t\t\t\t\t\tp /= length;\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet prev = lengths[curve - 1];\n\t\t\t\t\t\tp = (p - prev) / (length - prev);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (curve != prevCurve) {\n\t\t\t\t\tprevCurve = curve;\n\t\t\t\t\tif (closed && curve == curveCount) {\n\t\t\t\t\t\tpath.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n\t\t\t\t\t\tpath.computeWorldVertices(target, 0, 4, world, 4, 2);\n\t\t\t\t\t} else\n\t\t\t\t\t\tpath.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n\t\t\t\t}\n\t\t\t\tthis.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o,\n\t\t\t\t\ttangents || (i > 0 && space == 0));\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\n\t\t// World vertices.\n\t\tif (closed) {\n\t\t\tverticesLength += 2;\n\t\t\tworld = Utils.setArraySize(this.world, verticesLength);\n\t\t\tpath.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n\t\t\tpath.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n\t\t\tworld[verticesLength - 2] = world[0];\n\t\t\tworld[verticesLength - 1] = world[1];\n\t\t} else {\n\t\t\tcurveCount--;\n\t\t\tverticesLength -= 4;\n\t\t\tworld = Utils.setArraySize(this.world, verticesLength);\n\t\t\tpath.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n\t\t}\n\n\t\t// Curve lengths.\n\t\tlet curves = Utils.setArraySize(this.curves, curveCount);\n\t\tlet pathLength = 0;\n\t\tlet x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\n\t\tlet tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\n\t\tfor (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n\t\t\tcx1 = world[w];\n\t\t\tcy1 = world[w + 1];\n\t\t\tcx2 = world[w + 2];\n\t\t\tcy2 = world[w + 3];\n\t\t\tx2 = world[w + 4];\n\t\t\ty2 = world[w + 5];\n\t\t\ttmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n\t\t\ttmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n\t\t\tdddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n\t\t\tdddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n\t\t\tddfx = tmpx * 2 + dddfx;\n\t\t\tddfy = tmpy * 2 + dddfy;\n\t\t\tdfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n\t\t\tdfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\tdfx += ddfx;\n\t\t\tdfy += ddfy;\n\t\t\tddfx += dddfx;\n\t\t\tddfy += dddfy;\n\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\tdfx += ddfx;\n\t\t\tdfy += ddfy;\n\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\tdfx += ddfx + dddfx;\n\t\t\tdfy += ddfy + dddfy;\n\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\tcurves[i] = pathLength;\n\t\t\tx1 = x2;\n\t\t\ty1 = y2;\n\t\t}\n\n\t\tif (this.data.positionMode == PositionMode.Percent) position *= pathLength;\n\n\t\tlet multiplier;\n\t\tswitch (this.data.spacingMode) {\n\t\t\tcase SpacingMode.Percent:\n\t\t\t\tmultiplier = pathLength;\n\t\t\t\tbreak;\n\t\t\tcase SpacingMode.Proportional:\n\t\t\t\tmultiplier = pathLength / spacesCount;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmultiplier = 1;\n\t\t}\n\n\t\tlet segments = this.segments;\n\t\tlet curveLength = 0;\n\t\tfor (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n\t\t\tlet space = spaces[i] * multiplier;\n\t\t\tposition += space;\n\t\t\tlet p = position;\n\n\t\t\tif (closed) {\n\t\t\t\tp %= pathLength;\n\t\t\t\tif (p < 0) p += pathLength;\n\t\t\t\tcurve = 0;\n\t\t\t} else if (p < 0) {\n\t\t\t\tthis.addBeforePosition(p, world, 0, out, o);\n\t\t\t\tcontinue;\n\t\t\t} else if (p > pathLength) {\n\t\t\t\tthis.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Determine curve containing position.\n\t\t\tfor (; ; curve++) {\n\t\t\t\tlet length = curves[curve];\n\t\t\t\tif (p > length) continue;\n\t\t\t\tif (curve == 0)\n\t\t\t\t\tp /= length;\n\t\t\t\telse {\n\t\t\t\t\tlet prev = curves[curve - 1];\n\t\t\t\t\tp = (p - prev) / (length - prev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Curve segment lengths.\n\t\t\tif (curve != prevCurve) {\n\t\t\t\tprevCurve = curve;\n\t\t\t\tlet ii = curve * 6;\n\t\t\t\tx1 = world[ii];\n\t\t\t\ty1 = world[ii + 1];\n\t\t\t\tcx1 = world[ii + 2];\n\t\t\t\tcy1 = world[ii + 3];\n\t\t\t\tcx2 = world[ii + 4];\n\t\t\t\tcy2 = world[ii + 5];\n\t\t\t\tx2 = world[ii + 6];\n\t\t\t\ty2 = world[ii + 7];\n\t\t\t\ttmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n\t\t\t\ttmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n\t\t\t\tdddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n\t\t\t\tdddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n\t\t\t\tddfx = tmpx * 2 + dddfx;\n\t\t\t\tddfy = tmpy * 2 + dddfy;\n\t\t\t\tdfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n\t\t\t\tdfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n\t\t\t\tcurveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\t\tsegments[0] = curveLength;\n\t\t\t\tfor (ii = 1; ii < 8; ii++) {\n\t\t\t\t\tdfx += ddfx;\n\t\t\t\t\tdfy += ddfy;\n\t\t\t\t\tddfx += dddfx;\n\t\t\t\t\tddfy += dddfy;\n\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\t\t\tsegments[ii] = curveLength;\n\t\t\t\t}\n\t\t\t\tdfx += ddfx;\n\t\t\t\tdfy += ddfy;\n\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\t\tsegments[8] = curveLength;\n\t\t\t\tdfx += ddfx + dddfx;\n\t\t\t\tdfy += ddfy + dddfy;\n\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\t\tsegments[9] = curveLength;\n\t\t\t\tsegment = 0;\n\t\t\t}\n\n\t\t\t// Weight by segment length.\n\t\t\tp *= curveLength;\n\t\t\tfor (; ; segment++) {\n\t\t\t\tlet length = segments[segment];\n\t\t\t\tif (p > length) continue;\n\t\t\t\tif (segment == 0)\n\t\t\t\t\tp /= length;\n\t\t\t\telse {\n\t\t\t\t\tlet prev = segments[segment - 1];\n\t\t\t\t\tp = segment + (p - prev) / (length - prev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n\t\t}\n\t\treturn out;\n\t}\n\n\taddBeforePosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n\t\tlet x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\n\t\tout[o] = x1 + p * Math.cos(r);\n\t\tout[o + 1] = y1 + p * Math.sin(r);\n\t\tout[o + 2] = r;\n\t}\n\n\taddAfterPosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n\t\tlet x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\n\t\tout[o] = x1 + p * Math.cos(r);\n\t\tout[o + 1] = y1 + p * Math.sin(r);\n\t\tout[o + 2] = r;\n\t}\n\n\taddCurvePosition (p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number,\n\t\tout: Array<number>, o: number, tangents: boolean) {\n\t\tif (p == 0 || isNaN(p)) {\n\t\t\tout[o] = x1;\n\t\t\tout[o + 1] = y1;\n\t\t\tout[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n\t\t\treturn;\n\t\t}\n\t\tlet tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\n\t\tlet ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\n\t\tlet x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n\t\tout[o] = x;\n\t\tout[o + 1] = y;\n\t\tif (tangents) {\n\t\t\tif (p < 0.001)\n\t\t\t\tout[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n\t\t\telse\n\t\t\t\tout[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n\t\t}\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Bone } from \"./Bone.js\";\nimport { PhysicsConstraintData } from \"./PhysicsConstraintData.js\";\nimport { Physics, Skeleton } from \"./Skeleton.js\";\nimport { Updatable } from \"./Updatable.js\";\nimport { MathUtils } from \"./Utils.js\";\n\n\n/** Stores the current pose for a physics constraint. A physics constraint applies physics to bones.\n * <p>\n * See <a href=\"http://esotericsoftware.com/spine-physics-constraints\">Physics constraints</a> in the Spine User Guide. */\nexport class PhysicsConstraint implements Updatable {\n\treadonly data: PhysicsConstraintData;\n\tprivate _bone: Bone | null = null;\n\t/** The bone constrained by this physics constraint. */\n\tpublic set bone (bone: Bone) { this._bone = bone; }\n\tpublic get bone () {\n\t\tif (!this._bone) throw new Error(\"Bone not set.\")\n\t\telse return this._bone;\n\t}\n\tinertia = 0;\n\tstrength = 0;\n\tdamping = 0;\n\tmassInverse = 0;\n\twind = 0;\n\tgravity = 0;\n\tmix = 0;\n\n\t_reset = true;\n\tux = 0;\n\tuy = 0;\n\tcx = 0;\n\tcy = 0;\n\ttx = 0;\n\tty = 0;\n\txOffset = 0;\n\txVelocity = 0;\n\tyOffset = 0;\n\tyVelocity = 0;\n\trotateOffset = 0;\n\trotateVelocity = 0;\n\tscaleOffset = 0\n\tscaleVelocity = 0;\n\n\tactive = false;\n\n\treadonly skeleton: Skeleton;\n\tremaining = 0;\n\tlastTime = 0;\n\n\tconstructor (data: PhysicsConstraintData, skeleton: Skeleton) {\n\t\tthis.data = data;\n\t\tthis.skeleton = skeleton;\n\n\t\tthis.bone = skeleton.bones[data.bone.index];\n\n\t\tthis.inertia = data.inertia;\n\t\tthis.strength = data.strength;\n\t\tthis.damping = data.damping;\n\t\tthis.massInverse = data.massInverse;\n\t\tthis.wind = data.wind;\n\t\tthis.gravity = data.gravity;\n\t\tthis.mix = data.mix;\n\t}\n\n\treset () {\n\t\tthis.remaining = 0;\n\t\tthis.lastTime = this.skeleton.time;\n\t\tthis._reset = true;\n\t\tthis.xOffset = 0;\n\t\tthis.xVelocity = 0;\n\t\tthis.yOffset = 0;\n\t\tthis.yVelocity = 0;\n\t\tthis.rotateOffset = 0;\n\t\tthis.rotateVelocity = 0;\n\t\tthis.scaleOffset = 0;\n\t\tthis.scaleVelocity = 0;\n\t}\n\n\tsetToSetupPose () {\n\t\tconst data = this.data;\n\t\tthis.inertia = data.inertia;\n\t\tthis.strength = data.strength;\n\t\tthis.damping = data.damping;\n\t\tthis.massInverse = data.massInverse;\n\t\tthis.wind = data.wind;\n\t\tthis.gravity = data.gravity;\n\t\tthis.mix = data.mix;\n\t}\n\n\tisActive () {\n\t\treturn this.active;\n\t}\n\n\t/** Applies the constraint to the constrained bones. */\n\tupdate (physics: Physics) {\n\t\tconst mix = this.mix;\n\t\tif (mix == 0) return;\n\n\t\tconst x = this.data.x > 0, y = this.data.y > 0, rotateOrShearX = this.data.rotate > 0 || this.data.shearX > 0, scaleX = this.data.scaleX > 0;\n\t\tconst bone = this.bone;\n\t\tconst l = bone.data.length;\n\n\t\tswitch (physics) {\n\t\t\tcase Physics.none:\n\t\t\t\treturn;\n\t\t\tcase Physics.reset:\n\t\t\t\tthis.reset();\n\t\t\t// Fall through.\n\t\t\tcase Physics.update:\n\t\t\t\tconst skeleton = this.skeleton;\n\t\t\t\tconst delta = Math.max(this.skeleton.time - this.lastTime, 0);\n\t\t\t\tthis.remaining += delta;\n\t\t\t\tthis.lastTime = skeleton.time;\n\n\t\t\t\tconst bx = bone.worldX, by = bone.worldY;\n\t\t\t\tif (this._reset) {\n\t\t\t\t\tthis._reset = false;\n\t\t\t\t\tthis.ux = bx;\n\t\t\t\t\tthis.uy = by;\n\t\t\t\t} else {\n\t\t\t\t\tlet a = this.remaining, i = this.inertia, t = this.data.step, f = this.skeleton.data.referenceScale, d = -1;\n\t\t\t\t\tlet qx = this.data.limit * delta, qy = qx * Math.abs(skeleton.scaleY);\n\t\t\t\t\tqx *= Math.abs(skeleton.scaleX);\n\t\t\t\t\tif (x || y) {\n\t\t\t\t\t\tif (x) {\n\t\t\t\t\t\t\tconst u = (this.ux - bx) * i;\n\t\t\t\t\t\t\tthis.xOffset += u > qx ? qx : u < -qx ? -qx : u;\n\t\t\t\t\t\t\tthis.ux = bx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (y) {\n\t\t\t\t\t\t\tconst u = (this.uy - by) * i;\n\t\t\t\t\t\t\tthis.yOffset += u > qy ? qy : u < -qy ? -qy : u;\n\t\t\t\t\t\t\tthis.uy = by;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a >= t) {\n\t\t\t\t\t\t\td = Math.pow(this.damping, 60 * t);\n\t\t\t\t\t\t\tconst m = this.massInverse * t, e = this.strength, w = this.wind * f, g = (Skeleton.yDown ? -this.gravity : this.gravity) * f;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tif (x) {\n\t\t\t\t\t\t\t\t\tthis.xVelocity += (w - this.xOffset * e) * m;\n\t\t\t\t\t\t\t\t\tthis.xOffset += this.xVelocity * t;\n\t\t\t\t\t\t\t\t\tthis.xVelocity *= d;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (y) {\n\t\t\t\t\t\t\t\t\tthis.yVelocity -= (g + this.yOffset * e) * m;\n\t\t\t\t\t\t\t\t\tthis.yOffset += this.yVelocity * t;\n\t\t\t\t\t\t\t\t\tthis.yVelocity *= d;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ta -= t;\n\t\t\t\t\t\t\t} while (a >= t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x) bone.worldX += this.xOffset * mix * this.data.x;\n\t\t\t\t\t\tif (y) bone.worldY += this.yOffset * mix * this.data.y;\n\t\t\t\t\t}\n\t\t\t\t\tif (rotateOrShearX || scaleX) {\n\t\t\t\t\t\tlet ca = Math.atan2(bone.c, bone.a), c = 0, s = 0, mr = 0;\n\t\t\t\t\t\tlet dx = this.cx - bone.worldX, dy = this.cy - bone.worldY;\n\t\t\t\t\t\tif (dx > qx)\n\t\t\t\t\t\t\tdx = qx;\n\t\t\t\t\t\telse if (dx < -qx) //\n\t\t\t\t\t\t\tdx = -qx;\n\t\t\t\t\t\tif (dy > qy)\n\t\t\t\t\t\t\tdy = qy;\n\t\t\t\t\t\telse if (dy < -qy) //\n\t\t\t\t\t\t\tdy = -qy;\n\t\t\t\t\t\tif (rotateOrShearX) {\n\t\t\t\t\t\t\tmr = (this.data.rotate + this.data.shearX) * mix;\n\t\t\t\t\t\t\tlet r = Math.atan2(dy + this.ty, dx + this.tx) - ca - this.rotateOffset * mr;\n\t\t\t\t\t\t\tthis.rotateOffset += (r - Math.ceil(r * MathUtils.invPI2 - 0.5) * MathUtils.PI2) * i;\n\t\t\t\t\t\t\tr = this.rotateOffset * mr + ca;\n\t\t\t\t\t\t\tc = Math.cos(r);\n\t\t\t\t\t\t\ts = Math.sin(r);\n\t\t\t\t\t\t\tif (scaleX) {\n\t\t\t\t\t\t\t\tr = l * bone.getWorldScaleX();\n\t\t\t\t\t\t\t\tif (r > 0) this.scaleOffset += (dx * c + dy * s) * i / r;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tc = Math.cos(ca);\n\t\t\t\t\t\t\ts = Math.sin(ca);\n\t\t\t\t\t\t\tconst r = l * bone.getWorldScaleX();\n\t\t\t\t\t\t\tif (r > 0) this.scaleOffset += (dx * c + dy * s) * i / r;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta = this.remaining;\n\t\t\t\t\t\tif (a >= t) {\n\t\t\t\t\t\t\tif (d == -1) d = Math.pow(this.damping, 60 * t);\n\t\t\t\t\t\t\tconst m = this.massInverse * t, e = this.strength, w = this.wind, g = (Skeleton.yDown ? -this.gravity : this.gravity), h = l / f;\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\ta -= t;\n\t\t\t\t\t\t\t\tif (scaleX) {\n\t\t\t\t\t\t\t\t\tthis.scaleVelocity += (w * c - g * s - this.scaleOffset * e) * m;\n\t\t\t\t\t\t\t\t\tthis.scaleOffset += this.scaleVelocity * t;\n\t\t\t\t\t\t\t\t\tthis.scaleVelocity *= d;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (rotateOrShearX) {\n\t\t\t\t\t\t\t\t\tthis.rotateVelocity -= ((w * s + g * c) * h + this.rotateOffset * e) * m;\n\t\t\t\t\t\t\t\t\tthis.rotateOffset += this.rotateVelocity * t;\n\t\t\t\t\t\t\t\t\tthis.rotateVelocity *= d;\n\t\t\t\t\t\t\t\t\tif (a < t) break;\n\t\t\t\t\t\t\t\t\tconst r = this.rotateOffset * mr + ca;\n\t\t\t\t\t\t\t\t\tc = Math.cos(r);\n\t\t\t\t\t\t\t\t\ts = Math.sin(r);\n\t\t\t\t\t\t\t\t} else if (a < t) //\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.remaining = a;\n\t\t\t\t}\n\t\t\t\tthis.cx = bone.worldX;\n\t\t\t\tthis.cy = bone.worldY;\n\t\t\t\tbreak;\n\t\t\tcase Physics.pose:\n\t\t\t\tif (x) bone.worldX += this.xOffset * mix * this.data.x;\n\t\t\t\tif (y) bone.worldY += this.yOffset * mix * this.data.y;\n\t\t}\n\n\t\tif (rotateOrShearX) {\n\t\t\tlet o = this.rotateOffset * mix, s = 0, c = 0, a = 0;\n\t\t\tif (this.data.shearX > 0) {\n\t\t\t\tlet r = 0;\n\t\t\t\tif (this.data.rotate > 0) {\n\t\t\t\t\tr = o * this.data.rotate;\n\t\t\t\t\ts = Math.sin(r);\n\t\t\t\t\tc = Math.cos(r);\n\t\t\t\t\ta = bone.b;\n\t\t\t\t\tbone.b = c * a - s * bone.d;\n\t\t\t\t\tbone.d = s * a + c * bone.d;\n\t\t\t\t}\n\t\t\t\tr += o * this.data.shearX;\n\t\t\t\ts = Math.sin(r);\n\t\t\t\tc = Math.cos(r);\n\t\t\t\ta = bone.a;\n\t\t\t\tbone.a = c * a - s * bone.c;\n\t\t\t\tbone.c = s * a + c * bone.c;\n\t\t\t} else {\n\t\t\t\to *= this.data.rotate;\n\t\t\t\ts = Math.sin(o);\n\t\t\t\tc = Math.cos(o);\n\t\t\t\ta = bone.a;\n\t\t\t\tbone.a = c * a - s * bone.c;\n\t\t\t\tbone.c = s * a + c * bone.c;\n\t\t\t\ta = bone.b;\n\t\t\t\tbone.b = c * a - s * bone.d;\n\t\t\t\tbone.d = s * a + c * bone.d;\n\t\t\t}\n\t\t}\n\t\tif (scaleX) {\n\t\t\tconst s = 1 + this.scaleOffset * mix * this.data.scaleX;\n\t\t\tbone.a *= s;\n\t\t\tbone.c *= s;\n\t\t}\n\t\tif (physics != Physics.pose) {\n\t\t\tthis.tx = l * bone.a;\n\t\t\tthis.ty = l * bone.c;\n\t\t}\n\t\tbone.updateAppliedTransform();\n\t}\n\n\t/** Translates the physics constraint so next {@link #update(Physics)} forces are applied as if the bone moved an additional\n\t * amount in world space. */\n\ttranslate (x: number, y: number) {\n\t\tthis.ux -= x;\n\t\tthis.uy -= y;\n\t\tthis.cx -= x;\n\t\tthis.cy -= y;\n\t}\n\n\t/** Rotates the physics constraint so next {@link #update(Physics)} forces are applied as if the bone rotated around the\n\t * specified point in world space. */\n\trotate (x: number, y: number, degrees: number) {\n\t\tconst r = degrees * MathUtils.degRad, cos = Math.cos(r), sin = Math.sin(r);\n\t\tconst dx = this.cx - x, dy = this.cy - y;\n\t\tthis.translate(dx * cos - dy * sin - dx, dx * sin + dy * cos - dy);\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Attachment, VertexAttachment } from \"./attachments/Attachment.js\";\nimport { Bone } from \"./Bone.js\";\nimport { Skeleton } from \"./Skeleton.js\";\nimport { SlotData } from \"./SlotData.js\";\nimport { Color } from \"./Utils.js\";\n\n/** Stores a slot's current pose. Slots organize attachments for {@link Skeleton#drawOrder} purposes and provide a place to store\n * state for an attachment. State cannot be stored in an attachment itself because attachments are stateless and may be shared\n * across multiple skeletons. */\nexport class Slot {\n\t/** The slot's setup pose data. */\n\tdata: SlotData;\n\n\t/** The bone this slot belongs to. */\n\tbone: Bone;\n\n\t/** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\n\t * color tinting. */\n\tcolor: Color;\n\n\t/** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\n\t * color's alpha is not used. */\n\tdarkColor: Color | null = null;\n\n\tattachment: Attachment | null = null;\n\n\tattachmentState: number = 0;\n\n\t/** The index of the texture region to display when the slot's attachment has a {@link Sequence}. -1 represents the\n\t * {@link Sequence#getSetupIndex()}. */\n\tsequenceIndex: number = -1;\n\n\t/** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a\n\t * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.\n\t *\n\t * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */\n\tdeform = new Array<number>();\n\n\tconstructor (data: SlotData, bone: Bone) {\n\t\tif (!data) throw new Error(\"data cannot be null.\");\n\t\tif (!bone) throw new Error(\"bone cannot be null.\");\n\t\tthis.data = data;\n\t\tthis.bone = bone;\n\t\tthis.color = new Color();\n\t\tthis.darkColor = !data.darkColor ? null : new Color();\n\t\tthis.setToSetupPose();\n\t}\n\n\t/** The skeleton this slot belongs to. */\n\tgetSkeleton (): Skeleton {\n\t\treturn this.bone.skeleton;\n\t}\n\n\t/** The current attachment for the slot, or null if the slot has no attachment. */\n\tgetAttachment (): Attachment | null {\n\t\treturn this.attachment;\n\t}\n\n\t/** Sets the slot's attachment and, if the attachment changed, resets {@link #sequenceIndex} and clears the {@link #deform}.\n\t * The deform is not cleared if the old attachment has the same {@link VertexAttachment#getTimelineAttachment()} as the\n\t * specified attachment. */\n\tsetAttachment (attachment: Attachment | null) {\n\t\tif (this.attachment == attachment) return;\n\t\tif (!(attachment instanceof VertexAttachment) || !(this.attachment instanceof VertexAttachment)\n\t\t\t|| (<VertexAttachment>attachment).timelineAttachment != (<VertexAttachment>this.attachment).timelineAttachment) {\n\t\t\tthis.deform.length = 0;\n\t\t}\n\t\tthis.attachment = attachment;\n\t\tthis.sequenceIndex = -1;\n\t}\n\n\t/** Sets this slot to the setup pose. */\n\tsetToSetupPose () {\n\t\tthis.color.setFromColor(this.data.color);\n\t\tif (this.darkColor) this.darkColor.setFromColor(this.data.darkColor!);\n\t\tif (!this.data.attachmentName)\n\t\t\tthis.attachment = null;\n\t\telse {\n\t\t\tthis.attachment = null;\n\t\t\tthis.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n\t\t}\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Bone } from \"./Bone.js\";\nimport { Physics, Skeleton } from \"./Skeleton.js\";\nimport { TransformConstraintData } from \"./TransformConstraintData.js\";\nimport { Updatable } from \"./Updatable.js\";\nimport { Vector2, MathUtils } from \"./Utils.js\";\n\n\n/** Stores the current pose for a transform constraint. A transform constraint adjusts the world transform of the constrained\n * bones to match that of the target bone.\n *\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide. */\nexport class TransformConstraint implements Updatable {\n\n\t/** The transform constraint's setup pose data. */\n\tdata: TransformConstraintData;\n\n\t/** The bones that will be modified by this transform constraint. */\n\tbones: Array<Bone>;\n\n\t/** The target bone whose world transform will be copied to the constrained bones. */\n\ttarget: Bone;\n\n\tmixRotate = 0; mixX = 0; mixY = 0; mixScaleX = 0; mixScaleY = 0; mixShearY = 0;\n\n\ttemp = new Vector2();\n\tactive = false;\n\n\tconstructor (data: TransformConstraintData, skeleton: Skeleton) {\n\t\tif (!data) throw new Error(\"data cannot be null.\");\n\t\tif (!skeleton) throw new Error(\"skeleton cannot be null.\");\n\t\tthis.data = data;\n\n\t\tthis.bones = new Array<Bone>();\n\t\tfor (let i = 0; i < data.bones.length; i++) {\n\t\t\tlet bone = skeleton.findBone(data.bones[i].name);\n\t\t\tif (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\n\t\t\tthis.bones.push(bone);\n\t\t}\n\t\tlet target = skeleton.findBone(data.target.name);\n\t\tif (!target) throw new Error(`Couldn't find target bone ${data.target.name}.`);\n\t\tthis.target = target;\n\n\t\tthis.mixRotate = data.mixRotate;\n\t\tthis.mixX = data.mixX;\n\t\tthis.mixY = data.mixY;\n\t\tthis.mixScaleX = data.mixScaleX;\n\t\tthis.mixScaleY = data.mixScaleY;\n\t\tthis.mixShearY = data.mixShearY;\n\t}\n\n\tisActive () {\n\t\treturn this.active;\n\t}\n\n\tsetToSetupPose () {\n\t\tconst data = this.data;\n\t\tthis.mixRotate = data.mixRotate;\n\t\tthis.mixX = data.mixX;\n\t\tthis.mixY = data.mixY;\n\t\tthis.mixScaleX = data.mixScaleX;\n\t\tthis.mixScaleY = data.mixScaleY;\n\t\tthis.mixShearY = data.mixShearY;\n\t}\n\n\tupdate (physics: Physics) {\n\t\tif (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleY == 0 && this.mixShearY == 0) return;\n\n\t\tif (this.data.local) {\n\t\t\tif (this.data.relative)\n\t\t\t\tthis.applyRelativeLocal();\n\t\t\telse\n\t\t\t\tthis.applyAbsoluteLocal();\n\t\t} else {\n\t\t\tif (this.data.relative)\n\t\t\t\tthis.applyRelativeWorld();\n\t\t\telse\n\t\t\t\tthis.applyAbsoluteWorld();\n\t\t}\n\t}\n\n\tapplyAbsoluteWorld () {\n\t\tlet mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX,\n\t\t\tmixScaleY = this.mixScaleY, mixShearY = this.mixShearY;\n\t\tlet translate = mixX != 0 || mixY != 0;\n\n\t\tlet target = this.target;\n\t\tlet ta = target.a, tb = target.b, tc = target.c, td = target.d;\n\t\tlet degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n\t\tlet offsetRotation = this.data.offsetRotation * degRadReflect;\n\t\tlet offsetShearY = this.data.offsetShearY * degRadReflect;\n\n\t\tlet bones = this.bones;\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\n\t\t\tlet bone = bones[i];\n\n\t\t\tif (mixRotate != 0) {\n\t\t\t\tlet a = bone.a, b = bone.b, c = bone.c, d = bone.d;\n\t\t\t\tlet r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n\t\t\t\tif (r > MathUtils.PI)\n\t\t\t\t\tr -= MathUtils.PI2;\n\t\t\t\telse if (r < -MathUtils.PI) //\n\t\t\t\t\tr += MathUtils.PI2;\n\t\t\t\tr *= mixRotate;\n\t\t\t\tlet cos = Math.cos(r), sin = Math.sin(r);\n\t\t\t\tbone.a = cos * a - sin * c;\n\t\t\t\tbone.b = cos * b - sin * d;\n\t\t\t\tbone.c = sin * a + cos * c;\n\t\t\t\tbone.d = sin * b + cos * d;\n\t\t\t}\n\n\t\t\tif (translate) {\n\t\t\t\tlet temp = this.temp;\n\t\t\t\ttarget.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n\t\t\t\tbone.worldX += (temp.x - bone.worldX) * mixX;\n\t\t\t\tbone.worldY += (temp.y - bone.worldY) * mixY;\n\t\t\t}\n\n\t\t\tif (mixScaleX != 0) {\n\t\t\t\tlet s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);\n\t\t\t\tif (s != 0) s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;\n\t\t\t\tbone.a *= s;\n\t\t\t\tbone.c *= s;\n\t\t\t}\n\t\t\tif (mixScaleY != 0) {\n\t\t\t\tlet s = Math.sqrt(bone.b * bone.b + bone.d * bone.d);\n\t\t\t\tif (s != 0) s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;\n\t\t\t\tbone.b *= s;\n\t\t\t\tbone.d *= s;\n\t\t\t}\n\n\t\t\tif (mixShearY > 0) {\n\t\t\t\tlet b = bone.b, d = bone.d;\n\t\t\t\tlet by = Math.atan2(d, b);\n\t\t\t\tlet r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));\n\t\t\t\tif (r > MathUtils.PI)\n\t\t\t\t\tr -= MathUtils.PI2;\n\t\t\t\telse if (r < -MathUtils.PI) //\n\t\t\t\t\tr += MathUtils.PI2;\n\t\t\t\tr = by + (r + offsetShearY) * mixShearY;\n\t\t\t\tlet s = Math.sqrt(b * b + d * d);\n\t\t\t\tbone.b = Math.cos(r) * s;\n\t\t\t\tbone.d = Math.sin(r) * s;\n\t\t\t}\n\n\t\t\tbone.updateAppliedTransform();\n\t\t}\n\t}\n\n\tapplyRelativeWorld () {\n\t\tlet mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX,\n\t\t\tmixScaleY = this.mixScaleY, mixShearY = this.mixShearY;\n\t\tlet translate = mixX != 0 || mixY != 0;\n\n\t\tlet target = this.target;\n\t\tlet ta = target.a, tb = target.b, tc = target.c, td = target.d;\n\t\tlet degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n\t\tlet offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;\n\n\t\tlet bones = this.bones;\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\n\t\t\tlet bone = bones[i];\n\n\t\t\tif (mixRotate != 0) {\n\t\t\t\tlet a = bone.a, b = bone.b, c = bone.c, d = bone.d;\n\t\t\t\tlet r = Math.atan2(tc, ta) + offsetRotation;\n\t\t\t\tif (r > MathUtils.PI)\n\t\t\t\t\tr -= MathUtils.PI2;\n\t\t\t\telse if (r < -MathUtils.PI) //\n\t\t\t\t\tr += MathUtils.PI2;\n\t\t\t\tr *= mixRotate;\n\t\t\t\tlet cos = Math.cos(r), sin = Math.sin(r);\n\t\t\t\tbone.a = cos * a - sin * c;\n\t\t\t\tbone.b = cos * b - sin * d;\n\t\t\t\tbone.c = sin * a + cos * c;\n\t\t\t\tbone.d = sin * b + cos * d;\n\t\t\t}\n\n\t\t\tif (translate) {\n\t\t\t\tlet temp = this.temp;\n\t\t\t\ttarget.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n\t\t\t\tbone.worldX += temp.x * mixX;\n\t\t\t\tbone.worldY += temp.y * mixY;\n\t\t\t}\n\n\t\t\tif (mixScaleX != 0) {\n\t\t\t\tlet s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;\n\t\t\t\tbone.a *= s;\n\t\t\t\tbone.c *= s;\n\t\t\t}\n\t\t\tif (mixScaleY != 0) {\n\t\t\t\tlet s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;\n\t\t\t\tbone.b *= s;\n\t\t\t\tbone.d *= s;\n\t\t\t}\n\n\t\t\tif (mixShearY > 0) {\n\t\t\t\tlet r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n\t\t\t\tif (r > MathUtils.PI)\n\t\t\t\t\tr -= MathUtils.PI2;\n\t\t\t\telse if (r < -MathUtils.PI) //\n\t\t\t\t\tr += MathUtils.PI2;\n\t\t\t\tlet b = bone.b, d = bone.d;\n\t\t\t\tr = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * mixShearY;\n\t\t\t\tlet s = Math.sqrt(b * b + d * d);\n\t\t\t\tbone.b = Math.cos(r) * s;\n\t\t\t\tbone.d = Math.sin(r) * s;\n\t\t\t}\n\n\t\t\tbone.updateAppliedTransform();\n\t\t}\n\t}\n\n\tapplyAbsoluteLocal () {\n\t\tlet mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX,\n\t\t\tmixScaleY = this.mixScaleY, mixShearY = this.mixShearY;\n\n\t\tlet target = this.target;\n\n\t\tlet bones = this.bones;\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\n\t\t\tlet bone = bones[i];\n\n\t\t\tlet rotation = bone.arotation;\n\t\t\tif (mixRotate != 0) rotation += (target.arotation - rotation + this.data.offsetRotation) * mixRotate;\n\n\t\t\tlet x = bone.ax, y = bone.ay;\n\t\t\tx += (target.ax - x + this.data.offsetX) * mixX;\n\t\t\ty += (target.ay - y + this.data.offsetY) * mixY;\n\n\t\t\tlet scaleX = bone.ascaleX, scaleY = bone.ascaleY;\n\t\t\tif (mixScaleX != 0 && scaleX != 0)\n\t\t\t\tscaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;\n\t\t\tif (mixScaleY != 0 && scaleY != 0)\n\t\t\t\tscaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;\n\n\t\t\tlet shearY = bone.ashearY;\n\t\t\tif (mixShearY != 0) shearY += (target.ashearY - shearY + this.data.offsetShearY) * mixShearY;\n\n\t\t\tbone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n\t\t}\n\t}\n\n\tapplyRelativeLocal () {\n\t\tlet mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX,\n\t\t\tmixScaleY = this.mixScaleY, mixShearY = this.mixShearY;\n\n\t\tlet target = this.target;\n\n\t\tlet bones = this.bones;\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\n\t\t\tlet bone = bones[i];\n\n\t\t\tlet rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;\n\t\t\tlet x = bone.ax + (target.ax + this.data.offsetX) * mixX;\n\t\t\tlet y = bone.ay + (target.ay + this.data.offsetY) * mixY;\n\t\t\tlet scaleX = bone.ascaleX * (((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX) + 1);\n\t\t\tlet scaleY = bone.ascaleY * (((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY) + 1);\n\t\t\tlet shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;\n\n\t\t\tbone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n\t\t}\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Attachment } from \"./attachments/Attachment.js\";\nimport { ClippingAttachment } from \"./attachments/ClippingAttachment.js\";\nimport { MeshAttachment } from \"./attachments/MeshAttachment.js\";\nimport { PathAttachment } from \"./attachments/PathAttachment.js\";\nimport { RegionAttachment } from \"./attachments/RegionAttachment.js\";\nimport { Bone } from \"./Bone.js\";\nimport { IkConstraint } from \"./IkConstraint.js\";\nimport { PathConstraint } from \"./PathConstraint.js\";\nimport { PhysicsConstraint } from \"./PhysicsConstraint.js\";\nimport { SkeletonClipping } from \"./SkeletonClipping.js\";\nimport { SkeletonData } from \"./SkeletonData.js\";\nimport { Skin } from \"./Skin.js\";\nimport { Slot } from \"./Slot.js\";\nimport { TransformConstraint } from \"./TransformConstraint.js\";\nimport { Updatable } from \"./Updatable.js\";\nimport { Color, Utils, MathUtils, Vector2, NumberArrayLike } from \"./Utils.js\";\n\n/** Stores the current pose for a skeleton.\n *\n * See [Instance objects](http://esotericsoftware.com/spine-runtime-architecture#Instance-objects) in the Spine Runtimes Guide. */\nexport class Skeleton {\n\tprivate static quadTriangles = [0, 1, 2, 2, 3, 0];\n\tstatic yDown = false;\n\n\t/** The skeleton's setup pose data. */\n\tdata: SkeletonData;\n\n\t/** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n\tbones: Array<Bone>;\n\n\t/** The skeleton's slots in the setup pose draw order. */\n\tslots: Array<Slot>;\n\n\t/** The skeleton's slots in the order they should be drawn. The returned array may be modified to change the draw order. */\n\tdrawOrder: Array<Slot>;\n\n\t/** The skeleton's IK constraints. */\n\tikConstraints: Array<IkConstraint>;\n\n\t/** The skeleton's transform constraints. */\n\ttransformConstraints: Array<TransformConstraint>;\n\n\t/** The skeleton's path constraints. */\n\tpathConstraints: Array<PathConstraint>;\n\n\n\t/** The skeleton's physics constraints. */\n\tphysicsConstraints: Array<PhysicsConstraint>;\n\n\t/** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */\n\t_updateCache = new Array<Updatable>();\n\n\t/** The skeleton's current skin. May be null. */\n\tskin: Skin | null = null;\n\n\t/** The color to tint all the skeleton's attachments. */\n\tcolor: Color;\n\n\t/** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale\n\t  * inheritance. */\n\tscaleX = 1;\n\n\t/** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale\n\t  * inheritance. */\n\tprivate _scaleY = 1;\n\n\tpublic get scaleY () {\n\t\treturn Skeleton.yDown ? -this._scaleY : this._scaleY;\n\t}\n\n\tpublic set scaleY (scaleY: number) {\n\t\tthis._scaleY = scaleY;\n\t}\n\n\t/** Sets the skeleton X position, which is added to the root bone worldX position. */\n\tx = 0;\n\n\t/** Sets the skeleton Y position, which is added to the root bone worldY position. */\n\ty = 0;\n\n\t/** Returns the skeleton's time. This is used for time-based manipulations, such as {@link PhysicsConstraint}.\n\t * <p>\n\t * See {@link #update(float)}. */\n\ttime = 0;\n\n\tconstructor (data: SkeletonData) {\n\t\tif (!data) throw new Error(\"data cannot be null.\");\n\t\tthis.data = data;\n\n\t\tthis.bones = new Array<Bone>();\n\t\tfor (let i = 0; i < data.bones.length; i++) {\n\t\t\tlet boneData = data.bones[i];\n\t\t\tlet bone: Bone;\n\t\t\tif (!boneData.parent)\n\t\t\t\tbone = new Bone(boneData, this, null);\n\t\t\telse {\n\t\t\t\tlet parent = this.bones[boneData.parent.index];\n\t\t\t\tbone = new Bone(boneData, this, parent);\n\t\t\t\tparent.children.push(bone);\n\t\t\t}\n\t\t\tthis.bones.push(bone);\n\t\t}\n\n\t\tthis.slots = new Array<Slot>();\n\t\tthis.drawOrder = new Array<Slot>();\n\t\tfor (let i = 0; i < data.slots.length; i++) {\n\t\t\tlet slotData = data.slots[i];\n\t\t\tlet bone = this.bones[slotData.boneData.index];\n\t\t\tlet slot = new Slot(slotData, bone);\n\t\t\tthis.slots.push(slot);\n\t\t\tthis.drawOrder.push(slot);\n\t\t}\n\n\t\tthis.ikConstraints = new Array<IkConstraint>();\n\t\tfor (let i = 0; i < data.ikConstraints.length; i++) {\n\t\t\tlet ikConstraintData = data.ikConstraints[i];\n\t\t\tthis.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n\t\t}\n\n\t\tthis.transformConstraints = new Array<TransformConstraint>();\n\t\tfor (let i = 0; i < data.transformConstraints.length; i++) {\n\t\t\tlet transformConstraintData = data.transformConstraints[i];\n\t\t\tthis.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n\t\t}\n\n\t\tthis.pathConstraints = new Array<PathConstraint>();\n\t\tfor (let i = 0; i < data.pathConstraints.length; i++) {\n\t\t\tlet pathConstraintData = data.pathConstraints[i];\n\t\t\tthis.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n\t\t}\n\n\t\tthis.physicsConstraints = new Array<PhysicsConstraint>();\n\t\tfor (let i = 0; i < data.physicsConstraints.length; i++) {\n\t\t\tlet physicsConstraintData = data.physicsConstraints[i];\n\t\t\tthis.physicsConstraints.push(new PhysicsConstraint(physicsConstraintData, this));\n\t\t}\n\n\t\tthis.color = new Color(1, 1, 1, 1);\n\t\tthis.updateCache();\n\t}\n\n\t/** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,\n\t * constraints, or weighted path attachments are added or removed. */\n\tupdateCache () {\n\t\tlet updateCache = this._updateCache;\n\t\tupdateCache.length = 0;\n\n\t\tlet bones = this.bones;\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\n\t\t\tlet bone = bones[i];\n\t\t\tbone.sorted = bone.data.skinRequired;\n\t\t\tbone.active = !bone.sorted;\n\t\t}\n\n\t\tif (this.skin) {\n\t\t\tlet skinBones = this.skin.bones;\n\t\t\tfor (let i = 0, n = this.skin.bones.length; i < n; i++) {\n\t\t\t\tlet bone: Bone | null = this.bones[skinBones[i].index];\n\t\t\t\tdo {\n\t\t\t\t\tbone.sorted = false;\n\t\t\t\t\tbone.active = true;\n\t\t\t\t\tbone = bone.parent;\n\t\t\t\t} while (bone);\n\t\t\t}\n\t\t}\n\n\t\t// IK first, lowest hierarchy depth first.\n\t\tlet ikConstraints = this.ikConstraints;\n\t\tlet transformConstraints = this.transformConstraints;\n\t\tlet pathConstraints = this.pathConstraints;\n\t\tlet physicsConstraints = this.physicsConstraints;\n\t\tlet ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length, physicsCount = this.physicsConstraints.length;\n\t\tlet constraintCount = ikCount + transformCount + pathCount + physicsCount;\n\n\t\touter:\n\t\tfor (let i = 0; i < constraintCount; i++) {\n\t\t\tfor (let ii = 0; ii < ikCount; ii++) {\n\t\t\t\tlet constraint = ikConstraints[ii];\n\t\t\t\tif (constraint.data.order == i) {\n\t\t\t\t\tthis.sortIkConstraint(constraint);\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let ii = 0; ii < transformCount; ii++) {\n\t\t\t\tlet constraint = transformConstraints[ii];\n\t\t\t\tif (constraint.data.order == i) {\n\t\t\t\t\tthis.sortTransformConstraint(constraint);\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let ii = 0; ii < pathCount; ii++) {\n\t\t\t\tlet constraint = pathConstraints[ii];\n\t\t\t\tif (constraint.data.order == i) {\n\t\t\t\t\tthis.sortPathConstraint(constraint);\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let ii = 0; ii < physicsCount; ii++) {\n\t\t\t\tconst constraint = physicsConstraints[ii];\n\t\t\t\tif (constraint.data.order == i) {\n\t\t\t\t\tthis.sortPhysicsConstraint(constraint);\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, n = bones.length; i < n; i++)\n\t\t\tthis.sortBone(bones[i]);\n\t}\n\n\tsortIkConstraint (constraint: IkConstraint) {\n\t\tconstraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)))!;\n\t\tif (!constraint.active) return;\n\n\t\tlet target = constraint.target;\n\t\tthis.sortBone(target);\n\n\t\tlet constrained = constraint.bones;\n\t\tlet parent = constrained[0];\n\t\tthis.sortBone(parent);\n\n\t\tif (constrained.length == 1) {\n\t\t\tthis._updateCache.push(constraint);\n\t\t\tthis.sortReset(parent.children);\n\t\t} else {\n\t\t\tlet child = constrained[constrained.length - 1];\n\t\t\tthis.sortBone(child);\n\n\t\t\tthis._updateCache.push(constraint);\n\n\t\t\tthis.sortReset(parent.children);\n\t\t\tchild.sorted = true;\n\t\t}\n\t}\n\n\tsortPathConstraint (constraint: PathConstraint) {\n\t\tconstraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)))!;\n\t\tif (!constraint.active) return;\n\n\t\tlet slot = constraint.target;\n\t\tlet slotIndex = slot.data.index;\n\t\tlet slotBone = slot.bone;\n\t\tif (this.skin) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n\t\tif (this.data.defaultSkin && this.data.defaultSkin != this.skin)\n\t\t\tthis.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n\t\tfor (let i = 0, n = this.data.skins.length; i < n; i++)\n\t\t\tthis.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n\t\tlet attachment = slot.getAttachment();\n\t\tif (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n\t\tlet constrained = constraint.bones;\n\t\tlet boneCount = constrained.length;\n\t\tfor (let i = 0; i < boneCount; i++)\n\t\t\tthis.sortBone(constrained[i]);\n\n\t\tthis._updateCache.push(constraint);\n\n\t\tfor (let i = 0; i < boneCount; i++)\n\t\t\tthis.sortReset(constrained[i].children);\n\t\tfor (let i = 0; i < boneCount; i++)\n\t\t\tconstrained[i].sorted = true;\n\t}\n\n\tsortTransformConstraint (constraint: TransformConstraint) {\n\t\tconstraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)))!;\n\t\tif (!constraint.active) return;\n\n\t\tthis.sortBone(constraint.target);\n\n\t\tlet constrained = constraint.bones;\n\t\tlet boneCount = constrained.length;\n\t\tif (constraint.data.local) {\n\t\t\tfor (let i = 0; i < boneCount; i++) {\n\t\t\t\tlet child = constrained[i];\n\t\t\t\tthis.sortBone(child.parent!);\n\t\t\t\tthis.sortBone(child);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < boneCount; i++) {\n\t\t\t\tthis.sortBone(constrained[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis._updateCache.push(constraint);\n\n\t\tfor (let i = 0; i < boneCount; i++)\n\t\t\tthis.sortReset(constrained[i].children);\n\t\tfor (let i = 0; i < boneCount; i++)\n\t\t\tconstrained[i].sorted = true;\n\t}\n\n\tsortPathConstraintAttachment (skin: Skin, slotIndex: number, slotBone: Bone) {\n\t\tlet attachments = skin.attachments[slotIndex];\n\t\tif (!attachments) return;\n\t\tfor (let key in attachments) {\n\t\t\tthis.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n\t\t}\n\t}\n\n\tsortPathConstraintAttachmentWith (attachment: Attachment, slotBone: Bone) {\n\t\tif (!(attachment instanceof PathAttachment)) return;\n\t\tlet pathBones = (<PathAttachment>attachment).bones;\n\t\tif (!pathBones)\n\t\t\tthis.sortBone(slotBone);\n\t\telse {\n\t\t\tlet bones = this.bones;\n\t\t\tfor (let i = 0, n = pathBones.length; i < n;) {\n\t\t\t\tlet nn = pathBones[i++];\n\t\t\t\tnn += i;\n\t\t\t\twhile (i < nn)\n\t\t\t\t\tthis.sortBone(bones[pathBones[i++]]);\n\t\t\t}\n\t\t}\n\t}\n\n\tsortPhysicsConstraint (constraint: PhysicsConstraint) {\n\t\tconst bone = constraint.bone;\n\t\tconstraint.active = bone.active && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\n\t\tif (!constraint.active) return;\n\n\t\tthis.sortBone(bone);\n\n\t\tthis._updateCache.push(constraint);\n\n\t\tthis.sortReset(bone.children);\n\t\tbone.sorted = true;\n\t}\n\n\tsortBone (bone: Bone) {\n\t\tif (!bone) return;\n\t\tif (bone.sorted) return;\n\t\tlet parent = bone.parent;\n\t\tif (parent) this.sortBone(parent);\n\t\tbone.sorted = true;\n\t\tthis._updateCache.push(bone);\n\t}\n\n\tsortReset (bones: Array<Bone>) {\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\n\t\t\tlet bone = bones[i];\n\t\t\tif (!bone.active) continue;\n\t\t\tif (bone.sorted) this.sortReset(bone.children);\n\t\t\tbone.sorted = false;\n\t\t}\n\t}\n\n\t/** Updates the world transform for each bone and applies all constraints.\n\t *\n\t * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n\t * Runtimes Guide. */\n\tupdateWorldTransform (physics: Physics) {\n\t\tif (physics === undefined || physics === null) throw new Error(\"physics is undefined\");\n\t\tlet bones = this.bones;\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\n\t\t\tlet bone = bones[i];\n\t\t\tbone.ax = bone.x;\n\t\t\tbone.ay = bone.y;\n\t\t\tbone.arotation = bone.rotation;\n\t\t\tbone.ascaleX = bone.scaleX;\n\t\t\tbone.ascaleY = bone.scaleY;\n\t\t\tbone.ashearX = bone.shearX;\n\t\t\tbone.ashearY = bone.shearY;\n\t\t}\n\n\t\tlet updateCache = this._updateCache;\n\t\tfor (let i = 0, n = updateCache.length; i < n; i++)\n\t\t\tupdateCache[i].update(physics);\n\t}\n\n\tupdateWorldTransformWith (physics: Physics, parent: Bone) {\n\t\tif (!parent) throw new Error(\"parent cannot be null.\");\n\n\t\tlet bones = this.bones;\n\t\tfor (let i = 1, n = bones.length; i < n; i++) { // Skip root bone.\n\t\t\tlet bone = bones[i];\n\t\t\tbone.ax = bone.x;\n\t\t\tbone.ay = bone.y;\n\t\t\tbone.arotation = bone.rotation;\n\t\t\tbone.ascaleX = bone.scaleX;\n\t\t\tbone.ascaleY = bone.scaleY;\n\t\t\tbone.ashearX = bone.shearX;\n\t\t\tbone.ashearY = bone.shearY;\n\t\t}\n\n\t\t// Apply the parent bone transform to the root bone. The root bone always inherits scale, rotation and reflection.\n\t\tlet rootBone = this.getRootBone();\n\t\tif (!rootBone) throw new Error(\"Root bone must not be null.\");\n\t\tlet pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\n\t\trootBone.worldX = pa * this.x + pb * this.y + parent.worldX;\n\t\trootBone.worldY = pc * this.x + pd * this.y + parent.worldY;\n\n\t\tconst rx = (rootBone.rotation + rootBone.shearX) * MathUtils.degRad;\n\t\tconst ry = (rootBone.rotation + 90 + rootBone.shearY) * MathUtils.degRad;\n\t\tconst la = Math.cos(rx) * rootBone.scaleX;\n\t\tconst lb = Math.cos(ry) * rootBone.scaleY;\n\t\tconst lc = Math.sin(rx) * rootBone.scaleX;\n\t\tconst ld = Math.sin(ry) * rootBone.scaleY;\n\t\trootBone.a = (pa * la + pb * lc) * this.scaleX;\n\t\trootBone.b = (pa * lb + pb * ld) * this.scaleX;\n\t\trootBone.c = (pc * la + pd * lc) * this.scaleY;\n\t\trootBone.d = (pc * lb + pd * ld) * this.scaleY;\n\n\t\t// Update everything except root bone.\n\t\tlet updateCache = this._updateCache;\n\t\tfor (let i = 0, n = updateCache.length; i < n; i++) {\n\t\t\tlet updatable = updateCache[i];\n\t\t\tif (updatable != rootBone) updatable.update(physics);\n\t\t}\n\t}\n\n\t/** Sets the bones, constraints, and slots to their setup pose values. */\n\tsetToSetupPose () {\n\t\tthis.setBonesToSetupPose();\n\t\tthis.setSlotsToSetupPose();\n\t}\n\n\t/** Sets the bones and constraints to their setup pose values. */\n\tsetBonesToSetupPose () {\n\t\tfor (const bone of this.bones) bone.setToSetupPose();\n\t\tfor (const constraint of this.ikConstraints) constraint.setToSetupPose();\n\t\tfor (const constraint of this.transformConstraints) constraint.setToSetupPose();\n\t\tfor (const constraint of this.pathConstraints) constraint.setToSetupPose();\n\t\tfor (const constraint of this.physicsConstraints) constraint.setToSetupPose();\n\t}\n\n\t/** Sets the slots and draw order to their setup pose values. */\n\tsetSlotsToSetupPose () {\n\t\tlet slots = this.slots;\n\t\tUtils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n\t\tfor (let i = 0, n = slots.length; i < n; i++)\n\t\t\tslots[i].setToSetupPose();\n\t}\n\n\t/** @returns May return null. */\n\tgetRootBone () {\n\t\tif (this.bones.length == 0) return null;\n\t\treturn this.bones[0];\n\t}\n\n\t/** @returns May be null. */\n\tfindBone (boneName: string) {\n\t\tif (!boneName) throw new Error(\"boneName cannot be null.\");\n\t\tlet bones = this.bones;\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\n\t\t\tlet bone = bones[i];\n\t\t\tif (bone.data.name == boneName) return bone;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n\t * repeatedly.\n\t * @returns May be null. */\n\tfindSlot (slotName: string) {\n\t\tif (!slotName) throw new Error(\"slotName cannot be null.\");\n\t\tlet slots = this.slots;\n\t\tfor (let i = 0, n = slots.length; i < n; i++) {\n\t\t\tlet slot = slots[i];\n\t\t\tif (slot.data.name == slotName) return slot;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Sets a skin by name.\n\t *\n\t * See {@link #setSkin()}. */\n\tsetSkinByName (skinName: string) {\n\t\tlet skin = this.data.findSkin(skinName);\n\t\tif (!skin) throw new Error(\"Skin not found: \" + skinName);\n\t\tthis.setSkin(skin);\n\t}\n\n\t/** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the\n\t * skin is changed, {@link #updateCache()} is called.\n\t *\n\t * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n\t * old skin, each slot's setup mode attachment is attached from the new skin.\n\t *\n\t * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling\n\t * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the\n\t * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.\n\t * @param newSkin May be null. */\n\tsetSkin (newSkin: Skin) {\n\t\tif (newSkin == this.skin) return;\n\t\tif (newSkin) {\n\t\t\tif (this.skin)\n\t\t\t\tnewSkin.attachAll(this, this.skin);\n\t\t\telse {\n\t\t\t\tlet slots = this.slots;\n\t\t\t\tfor (let i = 0, n = slots.length; i < n; i++) {\n\t\t\t\t\tlet slot = slots[i];\n\t\t\t\t\tlet name = slot.data.attachmentName;\n\t\t\t\t\tif (name) {\n\t\t\t\t\t\tlet attachment = newSkin.getAttachment(i, name);\n\t\t\t\t\t\tif (attachment) slot.setAttachment(attachment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.skin = newSkin;\n\t\tthis.updateCache();\n\t}\n\n\n\t/** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment\n\t * name.\n\t *\n\t * See {@link #getAttachment()}.\n\t * @returns May be null. */\n\tgetAttachmentByName (slotName: string, attachmentName: string): Attachment | null {\n\t\tlet slot = this.data.findSlot(slotName);\n\t\tif (!slot) throw new Error(`Can't find slot with name ${slotName}`);\n\t\treturn this.getAttachment(slot.index, attachmentName);\n\t}\n\n\t/** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and\n\t * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.\n\t *\n\t * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\n\t * @returns May be null. */\n\tgetAttachment (slotIndex: number, attachmentName: string): Attachment | null {\n\t\tif (!attachmentName) throw new Error(\"attachmentName cannot be null.\");\n\t\tif (this.skin) {\n\t\t\tlet attachment = this.skin.getAttachment(slotIndex, attachmentName);\n\t\t\tif (attachment) return attachment;\n\t\t}\n\t\tif (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n\t\treturn null;\n\t}\n\n\t/** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with\n\t * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.\n\t * @param attachmentName May be null to clear the slot's attachment. */\n\tsetAttachment (slotName: string, attachmentName: string) {\n\t\tif (!slotName) throw new Error(\"slotName cannot be null.\");\n\t\tlet slots = this.slots;\n\t\tfor (let i = 0, n = slots.length; i < n; i++) {\n\t\t\tlet slot = slots[i];\n\t\t\tif (slot.data.name == slotName) {\n\t\t\t\tlet attachment: Attachment | null = null;\n\t\t\t\tif (attachmentName) {\n\t\t\t\t\tattachment = this.getAttachment(i, attachmentName);\n\t\t\t\t\tif (!attachment) throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n\t\t\t\t}\n\t\t\t\tslot.setAttachment(attachment);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow new Error(\"Slot not found: \" + slotName);\n\t}\n\n\n\t/** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n\t * than to call it repeatedly.\n\t * @return May be null. */\n\tfindIkConstraint (constraintName: string) {\n\t\tif (!constraintName) throw new Error(\"constraintName cannot be null.\");\n\t\treturn this.ikConstraints.find((constraint) => constraint.data.name == constraintName) ?? null;\n\t}\n\n\t/** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n\t * this method than to call it repeatedly.\n\t * @return May be null. */\n\tfindTransformConstraint (constraintName: string) {\n\t\tif (!constraintName) throw new Error(\"constraintName cannot be null.\");\n\t\treturn this.transformConstraints.find((constraint) => constraint.data.name == constraintName) ?? null;\n\t}\n\n\t/** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n\t * than to call it repeatedly.\n\t * @return May be null. */\n\tfindPathConstraint (constraintName: string) {\n\t\tif (!constraintName) throw new Error(\"constraintName cannot be null.\");\n\t\treturn this.pathConstraints.find((constraint) => constraint.data.name == constraintName) ?? null;\n\t}\n\n\t/** Finds a physics constraint by comparing each physics constraint's name. It is more efficient to cache the results of this\n\t * method than to call it repeatedly. */\n\tfindPhysicsConstraint (constraintName: string) {\n\t\tif (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n\t\treturn this.physicsConstraints.find((constraint) => constraint.data.name == constraintName) ?? null;\n\t}\n\n\t/** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.\n\t * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */\n\tgetBoundsRect () {\n\t\tlet offset = new Vector2();\n\t\tlet size = new Vector2();\n\t\tthis.getBounds(offset, size);\n\t\treturn { x: offset.x, y: offset.y, width: size.x, height: size.y };\n\t}\n\n\t/** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n\t * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\n\t * @param size An output value, the width and height of the AABB.\n\t * @param temp Working memory to temporarily store attachments' computed world vertices.\n\t * @param clipper {@link SkeletonClipping} to use. If <code>null</code>, no clipping is applied. */\n\tgetBounds (offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2), clipper: SkeletonClipping | null = null) {\n\t\tif (!offset) throw new Error(\"offset cannot be null.\");\n\t\tif (!size) throw new Error(\"size cannot be null.\");\n\t\tlet drawOrder = this.drawOrder;\n\t\tlet minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n\t\tfor (let i = 0, n = drawOrder.length; i < n; i++) {\n\t\t\tlet slot = drawOrder[i];\n\t\t\tif (!slot.bone.active) continue;\n\t\t\tlet verticesLength = 0;\n\t\t\tlet vertices: NumberArrayLike | null = null;\n\t\t\tlet triangles: NumberArrayLike | null = null;\n\t\t\tlet attachment = slot.getAttachment();\n\t\t\tif (attachment instanceof RegionAttachment) {\n\t\t\t\tverticesLength = 8;\n\t\t\t\tvertices = Utils.setArraySize(temp, verticesLength, 0);\n\t\t\t\tattachment.computeWorldVertices(slot, vertices, 0, 2);\n\t\t\t\ttriangles = Skeleton.quadTriangles;\n\t\t\t} else if (attachment instanceof MeshAttachment) {\n\t\t\t\tlet mesh = (<MeshAttachment>attachment);\n\t\t\t\tverticesLength = mesh.worldVerticesLength;\n\t\t\t\tvertices = Utils.setArraySize(temp, verticesLength, 0);\n\t\t\t\tmesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n\t\t\t\ttriangles = mesh.triangles;\n\t\t\t} else if (attachment instanceof ClippingAttachment && clipper != null) {\n\t\t\t\tclipper.clipStart(slot, attachment);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vertices && triangles) {\n\t\t\t\tif (clipper != null && clipper.isClipping()) {\n\t\t\t\t\tclipper.clipTriangles(vertices, triangles, triangles.length);\n\t\t\t\t\tvertices = clipper.clippedVertices;\n\t\t\t\t\tverticesLength = clipper.clippedVertices.length;\n\t\t\t\t}\n\t\t\t\tfor (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n\t\t\t\t\tlet x = vertices[ii], y = vertices[ii + 1];\n\t\t\t\t\tminX = Math.min(minX, x);\n\t\t\t\t\tminY = Math.min(minY, y);\n\t\t\t\t\tmaxX = Math.max(maxX, x);\n\t\t\t\t\tmaxY = Math.max(maxY, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (clipper != null) clipper.clipEndWithSlot(slot);\n\t\t}\n\t\tif (clipper != null) clipper.clipEnd();\n\t\toffset.set(minX, minY);\n\t\tsize.set(maxX - minX, maxY - minY);\n\t}\n\n\t/** Increments the skeleton's {@link #time}. */\n\tupdate (delta: number) {\n\t\tthis.time += delta;\n\t}\n\n\tphysicsTranslate (x: number, y: number) {\n\t\tconst physicsConstraints = this.physicsConstraints;\n\t\tfor (let i = 0, n = physicsConstraints.length; i < n; i++)\n\t\t\tphysicsConstraints[i].translate(x, y);\n\t}\n\n\t/** Calls {@link PhysicsConstraint#rotate(float, float, float)} for each physics constraint. */\n\tphysicsRotate (x: number, y: number, degrees: number) {\n\t\tconst physicsConstraints = this.physicsConstraints;\n\t\tfor (let i = 0, n = physicsConstraints.length; i < n; i++)\n\t\t\tphysicsConstraints[i].rotate(x, y, degrees);\n\t}\n}\n\n/** Determines how physics and other non-deterministic updates are applied. */\nexport enum Physics {\n\t/** Physics are not updated or applied. */\n\tnone,\n\n\t/** Physics are reset to the current pose. */\n\treset,\n\n\t/** Physics are updated and the pose from physics is applied. */\n\tupdate,\n\n\t/** Physics are not updated but the pose from physics is applied. */\n\tpose\n}", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { BoneData } from \"./BoneData.js\";\nimport { ConstraintData } from \"./ConstraintData.js\";\n\n\n/** Stores the setup pose for a {@link PhysicsConstraint}.\n * <p>\n * See <a href=\"http://esotericsoftware.com/spine-physics-constraints\">Physics constraints</a> in the Spine User Guide. */\nexport class PhysicsConstraintData extends ConstraintData {\n\tprivate _bone: BoneData | null = null;\n\t/** The bone constrained by this physics constraint. */\n\tpublic set bone (boneData: BoneData) { this._bone = boneData; }\n\tpublic get bone () {\n\t\tif (!this._bone) throw new Error(\"BoneData not set.\")\n\t\telse return this._bone;\n\t}\n\n\tx = 0;\n\ty = 0;\n\trotate = 0;\n\tscaleX = 0;\n\tshearX = 0;\n\tlimit = 0;\n\tstep = 0;\n\tinertia = 0;\n\tstrength = 0;\n\tdamping = 0;\n\tmassInverse = 0;\n\twind = 0;\n\tgravity = 0;\n\t/** A percentage (0-1) that controls the mix between the constrained and unconstrained poses. */\n\tmix = 0;\n\tinertiaGlobal = false;\n\tstrengthGlobal = false;\n\tdampingGlobal = false;\n\tmassGlobal = false;\n\twindGlobal = false;\n\tgravityGlobal = false;\n\tmixGlobal = false;\n\n\tconstructor (name: string) {\n\t\tsuper(name, 0, false);\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Animation } from \"./Animation\"\nimport { BoneData } from \"./BoneData.js\";\nimport { EventData } from \"./EventData.js\";\nimport { IkConstraintData } from \"./IkConstraintData.js\";\nimport { PathConstraintData } from \"./PathConstraintData.js\";\nimport { PhysicsConstraintData } from \"./PhysicsConstraintData.js\";\nimport { Skin } from \"./Skin.js\";\nimport { SlotData } from \"./SlotData.js\";\nimport { TransformConstraintData } from \"./TransformConstraintData.js\";\n\n/** Stores the setup pose and all of the stateless data for a skeleton.\n *\n * See [Data objects](http://esotericsoftware.com/spine-runtime-architecture#Data-objects) in the Spine Runtimes\n * Guide. */\nexport class SkeletonData {\n\n\t/** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */\n\tname: string | null = null;\n\n\t/** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n\tbones = new Array<BoneData>(); // Ordered parents first.\n\n\t/** The skeleton's slots in the setup pose draw order. */\n\tslots = new Array<SlotData>(); // Setup pose draw order.\n\n\tskins = new Array<Skin>();\n\n\t/** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.\n\t *\n\t * See {@link Skeleton#getAttachmentByName()}.\n\t * May be null. */\n\tdefaultSkin: Skin | null = null;\n\n\t/** The skeleton's events. */\n\tevents = new Array<EventData>();\n\n\t/** The skeleton's animations. */\n\tanimations = new Array<Animation>();\n\n\t/** The skeleton's IK constraints. */\n\tikConstraints = new Array<IkConstraintData>();\n\n\t/** The skeleton's transform constraints. */\n\ttransformConstraints = new Array<TransformConstraintData>();\n\n\t/** The skeleton's path constraints. */\n\tpathConstraints = new Array<PathConstraintData>();\n\n\t/** The skeleton's physics constraints. */\n\tphysicsConstraints = new Array<PhysicsConstraintData>();\n\n\t/** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */\n\tx: number = 0;\n\n\t/** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */\n\ty: number = 0;\n\n\t/** The width of the skeleton's axis aligned bounding box in the setup pose. */\n\twidth: number = 0;\n\n\t/** The height of the skeleton's axis aligned bounding box in the setup pose. */\n\theight: number = 0;\n\n\t/** Baseline scale factor for applying distance-dependent effects on non-scalable properties, such as angle or scale. Default\n\t * is 100. */\n\treferenceScale = 100;\n\n\t/** The Spine version used to export the skeleton data, or null. */\n\tversion: string | null = null;\n\n\t/** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */\n\thash: string | null = null;\n\n\t// Nonessential\n\t/** The dopesheet FPS in Spine. Available only when nonessential data was exported. */\n\tfps = 0;\n\n\t/** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */\n\timagesPath: string | null = null;\n\n\t/** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */\n\taudioPath: string | null = null;\n\n\t/** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it\n\t * multiple times.\n\t * @returns May be null. */\n\tfindBone (boneName: string) {\n\t\tif (!boneName) throw new Error(\"boneName cannot be null.\");\n\t\tlet bones = this.bones;\n\t\tfor (let i = 0, n = bones.length; i < n; i++) {\n\t\t\tlet bone = bones[i];\n\t\t\tif (bone.name == boneName) return bone;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n\t * multiple times.\n\t * @returns May be null. */\n\tfindSlot (slotName: string) {\n\t\tif (!slotName) throw new Error(\"slotName cannot be null.\");\n\t\tlet slots = this.slots;\n\t\tfor (let i = 0, n = slots.length; i < n; i++) {\n\t\t\tlet slot = slots[i];\n\t\t\tif (slot.name == slotName) return slot;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it\n\t * multiple times.\n\t * @returns May be null. */\n\tfindSkin (skinName: string) {\n\t\tif (!skinName) throw new Error(\"skinName cannot be null.\");\n\t\tlet skins = this.skins;\n\t\tfor (let i = 0, n = skins.length; i < n; i++) {\n\t\t\tlet skin = skins[i];\n\t\t\tif (skin.name == skinName) return skin;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it\n\t * multiple times.\n\t * @returns May be null. */\n\tfindEvent (eventDataName: string) {\n\t\tif (!eventDataName) throw new Error(\"eventDataName cannot be null.\");\n\t\tlet events = this.events;\n\t\tfor (let i = 0, n = events.length; i < n; i++) {\n\t\t\tlet event = events[i];\n\t\t\tif (event.name == eventDataName) return event;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to\n\t * call it multiple times.\n\t * @returns May be null. */\n\tfindAnimation (animationName: string) {\n\t\tif (!animationName) throw new Error(\"animationName cannot be null.\");\n\t\tlet animations = this.animations;\n\t\tfor (let i = 0, n = animations.length; i < n; i++) {\n\t\t\tlet animation = animations[i];\n\t\t\tif (animation.name == animationName) return animation;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n\t * than to call it multiple times.\n\t * @return May be null. */\n\tfindIkConstraint (constraintName: string) {\n\t\tif (!constraintName) throw new Error(\"constraintName cannot be null.\");\n\t\tconst ikConstraints = this.ikConstraints;\n\t\tfor (let i = 0, n = ikConstraints.length; i < n; i++) {\n\t\t\tconst constraint = ikConstraints[i];\n\t\t\tif (constraint.name == constraintName) return constraint;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n\t * this method than to call it multiple times.\n\t * @return May be null. */\n\tfindTransformConstraint (constraintName: string) {\n\t\tif (!constraintName) throw new Error(\"constraintName cannot be null.\");\n\t\tconst transformConstraints = this.transformConstraints;\n\t\tfor (let i = 0, n = transformConstraints.length; i < n; i++) {\n\t\t\tconst constraint = transformConstraints[i];\n\t\t\tif (constraint.name == constraintName) return constraint;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n\t * than to call it multiple times.\n\t * @return May be null. */\n\tfindPathConstraint (constraintName: string) {\n\t\tif (!constraintName) throw new Error(\"constraintName cannot be null.\");\n\t\tconst pathConstraints = this.pathConstraints;\n\t\tfor (let i = 0, n = pathConstraints.length; i < n; i++) {\n\t\t\tconst constraint = pathConstraints[i];\n\t\t\tif (constraint.name == constraintName) return constraint;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Finds a physics constraint by comparing each physics constraint's name. It is more efficient to cache the results of this method\n\t * than to call it multiple times.\n\t * @return May be null. */\n\tfindPhysicsConstraint (constraintName: string) {\n\t\tif (!constraintName) throw new Error(\"constraintName cannot be null.\");\n\t\tconst physicsConstraints = this.physicsConstraints;\n\t\tfor (let i = 0, n = physicsConstraints.length; i < n; i++) {\n\t\t\tconst constraint = physicsConstraints[i];\n\t\t\tif (constraint.name == constraintName) return constraint;\n\t\t}\n\t\treturn null;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Attachment } from \"./attachments/Attachment.js\";\nimport { MeshAttachment } from \"./attachments/MeshAttachment.js\";\nimport { BoneData } from \"./BoneData.js\";\nimport { ConstraintData } from \"./ConstraintData.js\";\nimport { Skeleton } from \"./Skeleton.js\";\nimport { Color, StringMap } from \"./Utils.js\";\n\n/** Stores an entry in the skin consisting of the slot index, name, and attachment **/\nexport class SkinEntry {\n\tconstructor (public slotIndex: number = 0, public name: string, public attachment: Attachment) { }\n}\n\n/** Stores attachments by slot index and attachment name.\n *\n * See SkeletonData {@link SkeletonData#defaultSkin}, Skeleton {@link Skeleton#skin}, and\n * [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide. */\nexport class Skin {\n\t/** The skin's name, which is unique across all skins in the skeleton. */\n\tname: string;\n\n\tattachments = new Array<StringMap<Attachment>>();\n\tbones = Array<BoneData>();\n\tconstraints = new Array<ConstraintData>();\n\n\t/** The color of the skin as it was in Spine, or a default color if nonessential data was not exported. */\n\tcolor = new Color(0.99607843, 0.61960787, 0.30980393, 1); // fe9e4fff\n\n\tconstructor (name: string) {\n\t\tif (!name) throw new Error(\"name cannot be null.\");\n\t\tthis.name = name;\n\t}\n\n\t/** Adds an attachment to the skin for the specified slot index and name. */\n\tsetAttachment (slotIndex: number, name: string, attachment: Attachment) {\n\t\tif (!attachment) throw new Error(\"attachment cannot be null.\");\n\t\tlet attachments = this.attachments;\n\t\tif (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n\t\tif (!attachments[slotIndex]) attachments[slotIndex] = {};\n\t\tattachments[slotIndex][name] = attachment;\n\t}\n\n\t/** Adds all attachments, bones, and constraints from the specified skin to this skin. */\n\taddSkin (skin: Skin) {\n\t\tfor (let i = 0; i < skin.bones.length; i++) {\n\t\t\tlet bone = skin.bones[i];\n\t\t\tlet contained = false;\n\t\t\tfor (let ii = 0; ii < this.bones.length; ii++) {\n\t\t\t\tif (this.bones[ii] == bone) {\n\t\t\t\t\tcontained = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!contained) this.bones.push(bone);\n\t\t}\n\n\t\tfor (let i = 0; i < skin.constraints.length; i++) {\n\t\t\tlet constraint = skin.constraints[i];\n\t\t\tlet contained = false;\n\t\t\tfor (let ii = 0; ii < this.constraints.length; ii++) {\n\t\t\t\tif (this.constraints[ii] == constraint) {\n\t\t\t\t\tcontained = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!contained) this.constraints.push(constraint);\n\t\t}\n\n\t\tlet attachments = skin.getAttachments();\n\t\tfor (let i = 0; i < attachments.length; i++) {\n\t\t\tvar attachment = attachments[i];\n\t\t\tthis.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n\t\t}\n\t}\n\n\t/** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not\n\t * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */\n\tcopySkin (skin: Skin) {\n\t\tfor (let i = 0; i < skin.bones.length; i++) {\n\t\t\tlet bone = skin.bones[i];\n\t\t\tlet contained = false;\n\t\t\tfor (let ii = 0; ii < this.bones.length; ii++) {\n\t\t\t\tif (this.bones[ii] == bone) {\n\t\t\t\t\tcontained = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!contained) this.bones.push(bone);\n\t\t}\n\n\t\tfor (let i = 0; i < skin.constraints.length; i++) {\n\t\t\tlet constraint = skin.constraints[i];\n\t\t\tlet contained = false;\n\t\t\tfor (let ii = 0; ii < this.constraints.length; ii++) {\n\t\t\t\tif (this.constraints[ii] == constraint) {\n\t\t\t\t\tcontained = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!contained) this.constraints.push(constraint);\n\t\t}\n\n\t\tlet attachments = skin.getAttachments();\n\t\tfor (let i = 0; i < attachments.length; i++) {\n\t\t\tvar attachment = attachments[i];\n\t\t\tif (!attachment.attachment) continue;\n\t\t\tif (attachment.attachment instanceof MeshAttachment) {\n\t\t\t\tattachment.attachment = attachment.attachment.newLinkedMesh();\n\t\t\t\tthis.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n\t\t\t} else {\n\t\t\t\tattachment.attachment = attachment.attachment.copy();\n\t\t\t\tthis.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Returns the attachment for the specified slot index and name, or null. */\n\tgetAttachment (slotIndex: number, name: string): Attachment | null {\n\t\tlet dictionary = this.attachments[slotIndex];\n\t\treturn dictionary ? dictionary[name] : null;\n\t}\n\n\t/** Removes the attachment in the skin for the specified slot index and name, if any. */\n\tremoveAttachment (slotIndex: number, name: string) {\n\t\tlet dictionary = this.attachments[slotIndex];\n\t\tif (dictionary) delete dictionary[name];\n\t}\n\n\t/** Returns all attachments in this skin. */\n\tgetAttachments (): Array<SkinEntry> {\n\t\tlet entries = new Array<SkinEntry>();\n\t\tfor (var i = 0; i < this.attachments.length; i++) {\n\t\t\tlet slotAttachments = this.attachments[i];\n\t\t\tif (slotAttachments) {\n\t\t\t\tfor (let name in slotAttachments) {\n\t\t\t\t\tlet attachment = slotAttachments[name];\n\t\t\t\t\tif (attachment) entries.push(new SkinEntry(i, name, attachment));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn entries;\n\t}\n\n\t/** Returns all attachments in this skin for the specified slot index. */\n\tgetAttachmentsForSlot (slotIndex: number, attachments: Array<SkinEntry>) {\n\t\tlet slotAttachments = this.attachments[slotIndex];\n\t\tif (slotAttachments) {\n\t\t\tfor (let name in slotAttachments) {\n\t\t\t\tlet attachment = slotAttachments[name];\n\t\t\t\tif (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Clears all attachments, bones, and constraints. */\n\tclear () {\n\t\tthis.attachments.length = 0;\n\t\tthis.bones.length = 0;\n\t\tthis.constraints.length = 0;\n\t}\n\n\t/** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n\tattachAll (skeleton: Skeleton, oldSkin: Skin) {\n\t\tlet slotIndex = 0;\n\t\tfor (let i = 0; i < skeleton.slots.length; i++) {\n\t\t\tlet slot = skeleton.slots[i];\n\t\t\tlet slotAttachment = slot.getAttachment();\n\t\t\tif (slotAttachment && slotIndex < oldSkin.attachments.length) {\n\t\t\t\tlet dictionary = oldSkin.attachments[slotIndex];\n\t\t\t\tfor (let key in dictionary) {\n\t\t\t\t\tlet skinAttachment: Attachment = dictionary[key];\n\t\t\t\t\tif (slotAttachment == skinAttachment) {\n\t\t\t\t\t\tlet attachment = this.getAttachment(slotIndex, key);\n\t\t\t\t\t\tif (attachment) slot.setAttachment(attachment);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tslotIndex++;\n\t\t}\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { BoneData } from \"./BoneData.js\";\nimport { Color } from \"./Utils.js\";\n\n/** Stores the setup pose for a {@link Slot}. */\nexport class SlotData {\n\t/** The index of the slot in {@link Skeleton#getSlots()}. */\n\tindex: number = 0;\n\n\t/** The name of the slot, which is unique across all slots in the skeleton. */\n\tname: string;\n\n\t/** The bone this slot belongs to. */\n\tboneData: BoneData;\n\n\t/** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\n\t * color tinting. */\n\tcolor = new Color(1, 1, 1, 1);\n\n\t/** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\n\t * color's alpha is not used. */\n\tdarkColor: Color | null = null;\n\n\t/** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */\n\tattachmentName: string | null = null;\n\n\t/** The blend mode for drawing the slot's attachment. */\n\tblendMode: BlendMode = BlendMode.Normal;\n\n\t/** False if the slot was hidden in Spine and nonessential data was exported. Does not affect runtime rendering. */\n\tvisible = true;\n\n\tconstructor (index: number, name: string, boneData: BoneData) {\n\t\tif (index < 0) throw new Error(\"index must be >= 0.\");\n\t\tif (!name) throw new Error(\"name cannot be null.\");\n\t\tif (!boneData) throw new Error(\"boneData cannot be null.\");\n\t\tthis.index = index;\n\t\tthis.name = name;\n\t\tthis.boneData = boneData;\n\t}\n}\n\n/** Determines how images are blended with existing pixels when drawn. */\nexport enum BlendMode { Normal, Additive, Multiply, Screen }\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { ConstraintData } from \"./ConstraintData.js\";\nimport { BoneData } from \"./BoneData.js\";\n\n/** Stores the setup pose for a {@link TransformConstraint}.\n *\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide. */\nexport class TransformConstraintData extends ConstraintData {\n\n\t/** The bones that will be modified by this transform constraint. */\n\tbones = new Array<BoneData>();\n\n\t/** The target bone whose world transform will be copied to the constrained bones. */\n\tprivate _target: BoneData | null = null;\n\tpublic set target (boneData: BoneData) { this._target = boneData; }\n\tpublic get target () {\n\t\tif (!this._target) throw new Error(\"BoneData not set.\")\n\t\telse return this._target;\n\t}\n\n\tmixRotate = 0;\n\tmixX = 0;\n\tmixY = 0;\n\tmixScaleX = 0;\n\tmixScaleY = 0;\n\tmixShearY = 0;\n\n\t/** An offset added to the constrained bone rotation. */\n\toffsetRotation = 0;\n\n\t/** An offset added to the constrained bone X translation. */\n\toffsetX = 0;\n\n\t/** An offset added to the constrained bone Y translation. */\n\toffsetY = 0;\n\n\t/** An offset added to the constrained bone scaleX. */\n\toffsetScaleX = 0;\n\n\t/** An offset added to the constrained bone scaleY. */\n\toffsetScaleY = 0;\n\n\t/** An offset added to the constrained bone shearY. */\n\toffsetShearY = 0;\n\n\trelative = false;\n\tlocal = false;\n\n\tconstructor (name: string) {\n\t\tsuper(name, 0, false);\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Animation, Timeline, InheritTimeline, AttachmentTimeline, RGBATimeline, RGBTimeline, RGBA2Timeline, RGB2Timeline, AlphaTimeline, RotateTimeline, TranslateTimeline, TranslateXTimeline, TranslateYTimeline, ScaleTimeline, ScaleXTimeline, ScaleYTimeline, ShearTimeline, ShearXTimeline, ShearYTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, CurveTimeline1, CurveTimeline2, CurveTimeline, SequenceTimeline, PhysicsConstraintResetTimeline, PhysicsConstraintInertiaTimeline, PhysicsConstraintStrengthTimeline, PhysicsConstraintDampingTimeline, PhysicsConstraintMassTimeline, PhysicsConstraintWindTimeline, PhysicsConstraintGravityTimeline, PhysicsConstraintMixTimeline } from \"./Animation.js\";\nimport { VertexAttachment, Attachment } from \"./attachments/Attachment.js\";\nimport { AttachmentLoader } from \"./attachments/AttachmentLoader.js\";\nimport { HasTextureRegion } from \"./attachments/HasTextureRegion.js\";\nimport { MeshAttachment } from \"./attachments/MeshAttachment.js\";\nimport { Sequence, SequenceModeValues } from \"./attachments/Sequence.js\";\nimport { BoneData } from \"./BoneData.js\";\nimport { Event } from \"./Event.js\";\nimport { EventData } from \"./EventData.js\";\nimport { IkConstraintData } from \"./IkConstraintData.js\";\nimport { PathConstraintData, PositionMode, SpacingMode } from \"./PathConstraintData.js\";\nimport { PhysicsConstraintData } from \"./PhysicsConstraintData.js\";\nimport { SkeletonData } from \"./SkeletonData.js\";\nimport { Skin } from \"./Skin.js\";\nimport { SlotData } from \"./SlotData.js\";\nimport { TransformConstraintData } from \"./TransformConstraintData.js\";\nimport { Color, Utils } from \"./Utils.js\";\n\n/** Loads skeleton data in the Spine binary format.\n *\n * See [Spine binary format](http://esotericsoftware.com/spine-binary-format) and\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\n * Runtimes Guide. */\nexport class SkeletonBinary {\n\t/** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n\t * runtime than were used in Spine.\n\t *\n\t * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n\tscale = 1;\n\n\tattachmentLoader: AttachmentLoader;\n\tprivate linkedMeshes = new Array<LinkedMesh>();\n\n\tconstructor (attachmentLoader: AttachmentLoader) {\n\t\tthis.attachmentLoader = attachmentLoader;\n\t}\n\n\treadSkeletonData (binary: Uint8Array | ArrayBuffer): SkeletonData {\n\t\tlet scale = this.scale;\n\n\t\tlet skeletonData = new SkeletonData();\n\t\tskeletonData.name = \"\"; // BOZO\n\n\t\tlet input = new BinaryInput(binary);\n\n\t\tlet lowHash = input.readInt32();\n\t\tlet highHash = input.readInt32();\n\t\tskeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);\n\t\tskeletonData.version = input.readString();\n\t\tskeletonData.x = input.readFloat();\n\t\tskeletonData.y = input.readFloat();\n\t\tskeletonData.width = input.readFloat();\n\t\tskeletonData.height = input.readFloat();\n\t\tskeletonData.referenceScale = input.readFloat() * scale;\n\n\t\tlet nonessential = input.readBoolean();\n\t\tif (nonessential) {\n\t\t\tskeletonData.fps = input.readFloat();\n\t\t\tskeletonData.imagesPath = input.readString();\n\t\t\tskeletonData.audioPath = input.readString();\n\t\t}\n\n\t\tlet n = 0;\n\t\t// Strings.\n\t\tn = input.readInt(true)\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet str = input.readString();\n\t\t\tif (!str) throw new Error(\"String in string table must not be null.\");\n\t\t\tinput.strings.push(str);\n\t\t}\n\n\t\t// Bones.\n\t\tn = input.readInt(true)\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet name = input.readString();\n\t\t\tif (!name) throw new Error(\"Bone name must not be null.\");\n\t\t\tlet parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n\t\t\tlet data = new BoneData(i, name, parent);\n\t\t\tdata.rotation = input.readFloat();\n\t\t\tdata.x = input.readFloat() * scale;\n\t\t\tdata.y = input.readFloat() * scale;\n\t\t\tdata.scaleX = input.readFloat();\n\t\t\tdata.scaleY = input.readFloat();\n\t\t\tdata.shearX = input.readFloat();\n\t\t\tdata.shearY = input.readFloat();\n\t\t\tdata.length = input.readFloat() * scale;\n\t\t\tdata.inherit = input.readByte();\n\t\t\tdata.skinRequired = input.readBoolean();\n\t\t\tif (nonessential) {\n\t\t\t\tColor.rgba8888ToColor(data.color, input.readInt32());\n\t\t\t\tdata.icon = input.readString() ?? undefined;\n\t\t\t\tdata.visible = input.readBoolean();\n\t\t\t}\n\t\t\tskeletonData.bones.push(data);\n\t\t}\n\n\t\t// Slots.\n\t\tn = input.readInt(true);\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet slotName = input.readString();\n\t\t\tif (!slotName) throw new Error(\"Slot name must not be null.\");\n\t\t\tlet boneData = skeletonData.bones[input.readInt(true)];\n\t\t\tlet data = new SlotData(i, slotName, boneData);\n\t\t\tColor.rgba8888ToColor(data.color, input.readInt32());\n\n\t\t\tlet darkColor = input.readInt32();\n\t\t\tif (darkColor != -1) Color.rgb888ToColor(data.darkColor = new Color(), darkColor);\n\n\t\t\tdata.attachmentName = input.readStringRef();\n\t\t\tdata.blendMode = input.readInt(true);\n\t\t\tif (nonessential) data.visible = input.readBoolean();\n\t\t\tskeletonData.slots.push(data);\n\t\t}\n\n\t\t// IK constraints.\n\t\tn = input.readInt(true);\n\t\tfor (let i = 0, nn; i < n; i++) {\n\t\t\tlet name = input.readString();\n\t\t\tif (!name) throw new Error(\"IK constraint data name must not be null.\");\n\t\t\tlet data = new IkConstraintData(name);\n\t\t\tdata.order = input.readInt(true);\n\t\t\tnn = input.readInt(true);\n\t\t\tfor (let ii = 0; ii < nn; ii++)\n\t\t\t\tdata.bones.push(skeletonData.bones[input.readInt(true)]);\n\t\t\tdata.target = skeletonData.bones[input.readInt(true)];\n\t\t\tlet flags = input.readByte();\n\t\t\tdata.skinRequired = (flags & 1) != 0;\n\t\t\tdata.bendDirection = (flags & 2) != 0 ? 1 : -1;\n\t\t\tdata.compress = (flags & 4) != 0;\n\t\t\tdata.stretch = (flags & 8) != 0;\n\t\t\tdata.uniform = (flags & 16) != 0;\n\t\t\tif ((flags & 32) != 0) data.mix = (flags & 64) != 0 ? input.readFloat() : 1;\n\t\t\tif ((flags & 128) != 0) data.softness = input.readFloat() * scale;\n\t\t\tskeletonData.ikConstraints.push(data);\n\t\t}\n\n\t\t// Transform constraints.\n\t\tn = input.readInt(true);\n\t\tfor (let i = 0, nn; i < n; i++) {\n\t\t\tlet name = input.readString();\n\t\t\tif (!name) throw new Error(\"Transform constraint data name must not be null.\");\n\t\t\tlet data = new TransformConstraintData(name);\n\t\t\tdata.order = input.readInt(true);\n\t\t\tnn = input.readInt(true);\n\t\t\tfor (let ii = 0; ii < nn; ii++)\n\t\t\t\tdata.bones.push(skeletonData.bones[input.readInt(true)]);\n\t\t\tdata.target = skeletonData.bones[input.readInt(true)];\n\t\t\tlet flags = input.readByte();\n\t\t\tdata.skinRequired = (flags & 1) != 0;\n\t\t\tdata.local = (flags & 2) != 0;\n\t\t\tdata.relative = (flags & 4) != 0;\n\t\t\tif ((flags & 8) != 0) data.offsetRotation = input.readFloat();\n\t\t\tif ((flags & 16) != 0) data.offsetX = input.readFloat() * scale;\n\t\t\tif ((flags & 32) != 0) data.offsetY = input.readFloat() * scale;\n\t\t\tif ((flags & 64) != 0) data.offsetScaleX = input.readFloat();\n\t\t\tif ((flags & 128) != 0) data.offsetScaleY = input.readFloat();\n\t\t\tflags = input.readByte();\n\t\t\tif ((flags & 1) != 0) data.offsetShearY = input.readFloat();\n\t\t\tif ((flags & 2) != 0) data.mixRotate = input.readFloat();\n\t\t\tif ((flags & 4) != 0) data.mixX = input.readFloat();\n\t\t\tif ((flags & 8) != 0) data.mixY = input.readFloat();\n\t\t\tif ((flags & 16) != 0) data.mixScaleX = input.readFloat();\n\t\t\tif ((flags & 32) != 0) data.mixScaleY = input.readFloat();\n\t\t\tif ((flags & 64) != 0) data.mixShearY = input.readFloat();\n\t\t\tskeletonData.transformConstraints.push(data);\n\t\t}\n\n\t\t// Path constraints.\n\t\tn = input.readInt(true);\n\t\tfor (let i = 0, nn; i < n; i++) {\n\t\t\tlet name = input.readString();\n\t\t\tif (!name) throw new Error(\"Path constraint data name must not be null.\");\n\t\t\tlet data = new PathConstraintData(name);\n\t\t\tdata.order = input.readInt(true);\n\t\t\tdata.skinRequired = input.readBoolean();\n\t\t\tnn = input.readInt(true);\n\t\t\tfor (let ii = 0; ii < nn; ii++)\n\t\t\t\tdata.bones.push(skeletonData.bones[input.readInt(true)]);\n\t\t\tdata.target = skeletonData.slots[input.readInt(true)];\n\t\t\tconst flags = input.readByte();\n\t\t\tdata.positionMode = flags & 1;\n\t\t\tdata.spacingMode = (flags >> 1) & 3;\n\t\t\tdata.rotateMode = (flags >> 3) & 3;\n\t\t\tif ((flags & 128) != 0) data.offsetRotation = input.readFloat();\n\t\t\tdata.position = input.readFloat();\n\t\t\tif (data.positionMode == PositionMode.Fixed) data.position *= scale;\n\t\t\tdata.spacing = input.readFloat();\n\t\t\tif (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n\t\t\tdata.mixRotate = input.readFloat();\n\t\t\tdata.mixX = input.readFloat();\n\t\t\tdata.mixY = input.readFloat();\n\t\t\tskeletonData.pathConstraints.push(data);\n\t\t}\n\n\t\t// Physics constraints.\n\t\tn = input.readInt(true);\n\t\tfor (let i = 0, nn; i < n; i++) {\n\t\t\tconst name = input.readString();\n\t\t\tif (!name) throw new Error(\"Physics constraint data name must not be null.\");\n\t\t\tconst data = new PhysicsConstraintData(name);\n\t\t\tdata.order = input.readInt(true);\n\t\t\tdata.bone = skeletonData.bones[input.readInt(true)];\n\t\t\tlet flags = input.readByte();\n\t\t\tdata.skinRequired = (flags & 1) != 0;\n\t\t\tif ((flags & 2) != 0) data.x = input.readFloat();\n\t\t\tif ((flags & 4) != 0) data.y = input.readFloat();\n\t\t\tif ((flags & 8) != 0) data.rotate = input.readFloat();\n\t\t\tif ((flags & 16) != 0) data.scaleX = input.readFloat();\n\t\t\tif ((flags & 32) != 0) data.shearX = input.readFloat();\n\t\t\tdata.limit = ((flags & 64) != 0 ? input.readFloat() : 5000) * scale;\n\t\t\tdata.step = 1 / input.readUnsignedByte();\n\t\t\tdata.inertia = input.readFloat();\n\t\t\tdata.strength = input.readFloat();\n\t\t\tdata.damping = input.readFloat();\n\t\t\tdata.massInverse = (flags & 128) != 0 ? input.readFloat() : 1;\n\t\t\tdata.wind = input.readFloat();\n\t\t\tdata.gravity = input.readFloat();\n\t\t\tflags = input.readByte();\n\t\t\tif ((flags & 1) != 0) data.inertiaGlobal = true;\n\t\t\tif ((flags & 2) != 0) data.strengthGlobal = true;\n\t\t\tif ((flags & 4) != 0) data.dampingGlobal = true;\n\t\t\tif ((flags & 8) != 0) data.massGlobal = true;\n\t\t\tif ((flags & 16) != 0) data.windGlobal = true;\n\t\t\tif ((flags & 32) != 0) data.gravityGlobal = true;\n\t\t\tif ((flags & 64) != 0) data.mixGlobal = true;\n\t\t\tdata.mix = (flags & 128) != 0 ? input.readFloat() : 1;\n\t\t\tskeletonData.physicsConstraints.push(data);\n\t\t}\n\n\t\t// Default skin.\n\t\tlet defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n\t\tif (defaultSkin) {\n\t\t\tskeletonData.defaultSkin = defaultSkin;\n\t\t\tskeletonData.skins.push(defaultSkin);\n\t\t}\n\n\t\t// Skins.\n\t\t{\n\t\t\tlet i = skeletonData.skins.length;\n\t\t\tUtils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\n\t\t\tfor (; i < n; i++) {\n\t\t\t\tlet skin = this.readSkin(input, skeletonData, false, nonessential);\n\t\t\t\tif (!skin) throw new Error(\"readSkin() should not have returned null.\");\n\t\t\t\tskeletonData.skins[i] = skin;\n\t\t\t}\n\t\t}\n\n\t\t// Linked meshes.\n\t\tn = this.linkedMeshes.length;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet linkedMesh = this.linkedMeshes[i];\n\t\t\tconst skin = skeletonData.skins[linkedMesh.skinIndex];\n\t\t\tif (!linkedMesh.parent) throw new Error(\"Linked mesh parent must not be null\");\n\t\t\tlet parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\t\t\tif (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n\t\t\tlinkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent as VertexAttachment : linkedMesh.mesh;\n\t\t\tlinkedMesh.mesh.setParentMesh(parent as MeshAttachment);\n\t\t\tif (linkedMesh.mesh.region != null) linkedMesh.mesh.updateRegion();\n\t\t}\n\t\tthis.linkedMeshes.length = 0;\n\n\t\t// Events.\n\t\tn = input.readInt(true);\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet eventName = input.readString();\n\t\t\tif (!eventName) throw new Error(\"Event data name must not be null\");\n\t\t\tlet data = new EventData(eventName);\n\t\t\tdata.intValue = input.readInt(false);\n\t\t\tdata.floatValue = input.readFloat();\n\t\t\tdata.stringValue = input.readString();\n\t\t\tdata.audioPath = input.readString();\n\t\t\tif (data.audioPath) {\n\t\t\t\tdata.volume = input.readFloat();\n\t\t\t\tdata.balance = input.readFloat();\n\t\t\t}\n\t\t\tskeletonData.events.push(data);\n\t\t}\n\n\t\t// Animations.\n\t\tn = input.readInt(true);\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet animationName = input.readString();\n\t\t\tif (!animationName) throw new Error(\"Animatio name must not be null.\");\n\t\t\tskeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));\n\t\t}\n\t\treturn skeletonData;\n\t}\n\n\tprivate readSkin (input: BinaryInput, skeletonData: SkeletonData, defaultSkin: boolean, nonessential: boolean): Skin | null {\n\t\tlet skin = null;\n\t\tlet slotCount = 0;\n\n\t\tif (defaultSkin) {\n\t\t\tslotCount = input.readInt(true)\n\t\t\tif (slotCount == 0) return null;\n\t\t\tskin = new Skin(\"default\");\n\t\t} else {\n\t\t\tlet skinName = input.readString();\n\t\t\tif (!skinName) throw new Error(\"Skin name must not be null.\");\n\t\t\tskin = new Skin(skinName);\n\t\t\tif (nonessential) Color.rgba8888ToColor(skin.color, input.readInt32());\n\t\t\tskin.bones.length = input.readInt(true);\n\t\t\tfor (let i = 0, n = skin.bones.length; i < n; i++)\n\t\t\t\tskin.bones[i] = skeletonData.bones[input.readInt(true)];\n\n\t\t\tfor (let i = 0, n = input.readInt(true); i < n; i++)\n\t\t\t\tskin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n\t\t\tfor (let i = 0, n = input.readInt(true); i < n; i++)\n\t\t\t\tskin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n\t\t\tfor (let i = 0, n = input.readInt(true); i < n; i++)\n\t\t\t\tskin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n\t\t\tfor (let i = 0, n = input.readInt(true); i < n; i++)\n\t\t\t\tskin.constraints.push(skeletonData.physicsConstraints[input.readInt(true)]);\n\n\t\t\tslotCount = input.readInt(true);\n\t\t}\n\n\t\tfor (let i = 0; i < slotCount; i++) {\n\t\t\tlet slotIndex = input.readInt(true);\n\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\tlet name = input.readStringRef();\n\t\t\t\tif (!name)\n\t\t\t\t\tthrow new Error(\"Attachment name must not be null\");\n\t\t\t\tlet attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\n\t\t\t\tif (attachment) skin.setAttachment(slotIndex, name, attachment);\n\t\t\t}\n\t\t}\n\t\treturn skin;\n\t}\n\n\tprivate readAttachment (input: BinaryInput, skeletonData: SkeletonData, skin: Skin, slotIndex: number, attachmentName: string | null | undefined, nonessential: boolean): Attachment | null {\n\t\tlet scale = this.scale;\n\n\t\tlet flags = input.readByte();\n\t\tconst name = (flags & 8) != 0 ? input.readStringRef() : attachmentName;\n\t\tif (!name) throw new Error(\"Attachment name must not be null\");\n\t\tswitch ((flags & 0b111) as AttachmentType) { // BUG?\n\t\t\tcase AttachmentType.Region: {\n\t\t\t\tlet path = (flags & 16) != 0 ? input.readStringRef() : null;\n\t\t\t\tconst color = (flags & 32) != 0 ? input.readInt32() : 0xffffffff;\n\t\t\t\tconst sequence = (flags & 64) != 0 ? this.readSequence(input) : null;\n\t\t\t\tlet rotation = (flags & 128) != 0 ? input.readFloat() : 0;\n\t\t\t\tlet x = input.readFloat();\n\t\t\t\tlet y = input.readFloat();\n\t\t\t\tlet scaleX = input.readFloat();\n\t\t\t\tlet scaleY = input.readFloat();\n\t\t\t\tlet width = input.readFloat();\n\t\t\t\tlet height = input.readFloat();\n\n\t\t\t\tif (!path) path = name;\n\t\t\t\tlet region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\n\t\t\t\tif (!region) return null;\n\t\t\t\tregion.path = path;\n\t\t\t\tregion.x = x * scale;\n\t\t\t\tregion.y = y * scale;\n\t\t\t\tregion.scaleX = scaleX;\n\t\t\t\tregion.scaleY = scaleY;\n\t\t\t\tregion.rotation = rotation;\n\t\t\t\tregion.width = width * scale;\n\t\t\t\tregion.height = height * scale;\n\t\t\t\tColor.rgba8888ToColor(region.color, color);\n\t\t\t\tregion.sequence = sequence;\n\t\t\t\tif (sequence == null) region.updateRegion();\n\t\t\t\treturn region;\n\t\t\t}\n\t\t\tcase AttachmentType.BoundingBox: {\n\t\t\t\tlet vertices = this.readVertices(input, (flags & 16) != 0);\n\t\t\t\tlet color = nonessential ? input.readInt32() : 0;\n\n\t\t\t\tlet box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\t\t\t\tif (!box) return null;\n\t\t\t\tbox.worldVerticesLength = vertices.length;\n\t\t\t\tbox.vertices = vertices.vertices!;\n\t\t\t\tbox.bones = vertices.bones;\n\t\t\t\tif (nonessential) Color.rgba8888ToColor(box.color, color);\n\t\t\t\treturn box;\n\t\t\t}\n\t\t\tcase AttachmentType.Mesh: {\n\t\t\t\tlet path = (flags & 16) != 0 ? input.readStringRef() : name;\n\t\t\t\tconst color = (flags & 32) != 0 ? input.readInt32() : 0xffffffff;\n\t\t\t\tconst sequence = (flags & 64) != 0 ? this.readSequence(input) : null;\n\t\t\t\tconst hullLength = input.readInt(true);\n\t\t\t\tconst vertices = this.readVertices(input, (flags & 128) != 0);\n\t\t\t\tconst uvs = this.readFloatArray(input, vertices.length, 1);\n\t\t\t\tconst triangles = this.readShortArray(input, (vertices.length - hullLength - 2) * 3);\n\t\t\t\tlet edges: number[] = [];\n\t\t\t\tlet width = 0, height = 0;\n\t\t\t\tif (nonessential) {\n\t\t\t\t\tedges = this.readShortArray(input, input.readInt(true));\n\t\t\t\t\twidth = input.readFloat();\n\t\t\t\t\theight = input.readFloat();\n\t\t\t\t}\n\n\t\t\t\tif (!path) path = name;\n\t\t\t\tlet mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n\t\t\t\tif (!mesh) return null;\n\t\t\t\tmesh.path = path;\n\t\t\t\tColor.rgba8888ToColor(mesh.color, color);\n\t\t\t\tmesh.bones = vertices.bones;\n\t\t\t\tmesh.vertices = vertices.vertices!;\n\t\t\t\tmesh.worldVerticesLength = vertices.length;\n\t\t\t\tmesh.triangles = triangles;\n\t\t\t\tmesh.regionUVs = uvs;\n\t\t\t\tif (sequence == null) mesh.updateRegion();\n\t\t\t\tmesh.hullLength = hullLength << 1;\n\t\t\t\tmesh.sequence = sequence;\n\t\t\t\tif (nonessential) {\n\t\t\t\t\tmesh.edges = edges;\n\t\t\t\t\tmesh.width = width * scale;\n\t\t\t\t\tmesh.height = height * scale;\n\t\t\t\t}\n\t\t\t\treturn mesh;\n\t\t\t}\n\t\t\tcase AttachmentType.LinkedMesh: {\n\t\t\t\tconst path = (flags & 16) != 0 ? input.readStringRef() : name;\n\t\t\t\tif (path == null) throw new Error(\"Path of linked mesh must not be null\");\n\t\t\t\tconst color = (flags & 32) != 0 ? input.readInt32() : 0xffffffff;\n\t\t\t\tconst sequence = (flags & 64) != 0 ? this.readSequence(input) : null;\n\t\t\t\tconst inheritTimelines = (flags & 128) != 0;\n\t\t\t\tconst skinIndex = input.readInt(true);\n\t\t\t\tconst parent = input.readStringRef();\n\t\t\t\tlet width = 0, height = 0;\n\t\t\t\tif (nonessential) {\n\t\t\t\t\twidth = input.readFloat();\n\t\t\t\t\theight = input.readFloat();\n\t\t\t\t}\n\n\t\t\t\tlet mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n\t\t\t\tif (!mesh) return null;\n\t\t\t\tmesh.path = path;\n\t\t\t\tColor.rgba8888ToColor(mesh.color, color);\n\t\t\t\tmesh.sequence = sequence;\n\t\t\t\tif (nonessential) {\n\t\t\t\t\tmesh.width = width * scale;\n\t\t\t\t\tmesh.height = height * scale;\n\t\t\t\t}\n\t\t\t\tthis.linkedMeshes.push(new LinkedMesh(mesh, skinIndex, slotIndex, parent, inheritTimelines));\n\t\t\t\treturn mesh;\n\t\t\t}\n\t\t\tcase AttachmentType.Path: {\n\t\t\t\tconst closed = (flags & 16) != 0;\n\t\t\t\tconst constantSpeed = (flags & 32) != 0;\n\t\t\t\tconst vertices = this.readVertices(input, (flags & 64) != 0);\n\n\t\t\t\tconst lengths = Utils.newArray(vertices.length / 6, 0);\n\t\t\t\tfor (let i = 0, n = lengths.length; i < n; i++)\n\t\t\t\t\tlengths[i] = input.readFloat() * scale;\n\t\t\t\tconst color = nonessential ? input.readInt32() : 0;\n\n\t\t\t\tconst path = this.attachmentLoader.newPathAttachment(skin, name);\n\t\t\t\tif (!path) return null;\n\t\t\t\tpath.closed = closed;\n\t\t\t\tpath.constantSpeed = constantSpeed;\n\t\t\t\tpath.worldVerticesLength = vertices.length;\n\t\t\t\tpath.vertices = vertices.vertices!;\n\t\t\t\tpath.bones = vertices.bones;\n\t\t\t\tpath.lengths = lengths;\n\t\t\t\tif (nonessential) Color.rgba8888ToColor(path.color, color);\n\t\t\t\treturn path;\n\t\t\t}\n\t\t\tcase AttachmentType.Point: {\n\t\t\t\tconst rotation = input.readFloat();\n\t\t\t\tconst x = input.readFloat();\n\t\t\t\tconst y = input.readFloat();\n\t\t\t\tconst color = nonessential ? input.readInt32() : 0;\n\n\t\t\t\tconst point = this.attachmentLoader.newPointAttachment(skin, name);\n\t\t\t\tif (!point) return null;\n\t\t\t\tpoint.x = x * scale;\n\t\t\t\tpoint.y = y * scale;\n\t\t\t\tpoint.rotation = rotation;\n\t\t\t\tif (nonessential) Color.rgba8888ToColor(point.color, color);\n\t\t\t\treturn point;\n\t\t\t}\n\t\t\tcase AttachmentType.Clipping: {\n\t\t\t\tconst endSlotIndex = input.readInt(true);\n\t\t\t\tconst vertices = this.readVertices(input, (flags & 16) != 0);\n\t\t\t\tlet color = nonessential ? input.readInt32() : 0;\n\n\t\t\t\tlet clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\t\t\t\tif (!clip) return null;\n\t\t\t\tclip.endSlot = skeletonData.slots[endSlotIndex];\n\t\t\t\tclip.worldVerticesLength = vertices.length;\n\t\t\t\tclip.vertices = vertices.vertices!;\n\t\t\t\tclip.bones = vertices.bones;\n\t\t\t\tif (nonessential) Color.rgba8888ToColor(clip.color, color);\n\t\t\t\treturn clip;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate readSequence (input: BinaryInput) {\n\t\tlet sequence = new Sequence(input.readInt(true));\n\t\tsequence.start = input.readInt(true);\n\t\tsequence.digits = input.readInt(true);\n\t\tsequence.setupIndex = input.readInt(true);\n\t\treturn sequence;\n\t}\n\n\tprivate readVertices (input: BinaryInput, weighted: boolean): Vertices {\n\t\tconst scale = this.scale;\n\t\tconst vertexCount = input.readInt(true);\n\t\tconst vertices = new Vertices();\n\t\tvertices.length = vertexCount << 1;\n\t\tif (!weighted) {\n\t\t\tvertices.vertices = this.readFloatArray(input, vertices.length, scale);\n\t\t\treturn vertices;\n\t\t}\n\t\tlet weights = new Array<number>();\n\t\tlet bonesArray = new Array<number>();\n\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\tlet boneCount = input.readInt(true);\n\t\t\tbonesArray.push(boneCount);\n\t\t\tfor (let ii = 0; ii < boneCount; ii++) {\n\t\t\t\tbonesArray.push(input.readInt(true));\n\t\t\t\tweights.push(input.readFloat() * scale);\n\t\t\t\tweights.push(input.readFloat() * scale);\n\t\t\t\tweights.push(input.readFloat());\n\t\t\t}\n\t\t}\n\t\tvertices.vertices = Utils.toFloatArray(weights);\n\t\tvertices.bones = bonesArray;\n\t\treturn vertices;\n\t}\n\n\tprivate readFloatArray (input: BinaryInput, n: number, scale: number): number[] {\n\t\tlet array = new Array<number>(n);\n\t\tif (scale == 1) {\n\t\t\tfor (let i = 0; i < n; i++)\n\t\t\t\tarray[i] = input.readFloat();\n\t\t} else {\n\t\t\tfor (let i = 0; i < n; i++)\n\t\t\t\tarray[i] = input.readFloat() * scale;\n\t\t}\n\t\treturn array;\n\t}\n\n\tprivate readShortArray (input: BinaryInput, n: number): number[] {\n\t\tlet array = new Array<number>(n);\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tarray[i] = input.readInt(true);\n\t\treturn array;\n\t}\n\n\tprivate readAnimation (input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\n\t\tinput.readInt(true); // Number of timelines.\n\t\tlet timelines = new Array<Timeline>();\n\t\tlet scale = this.scale;\n\n\t\t// Slot timelines.\n\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\tlet slotIndex = input.readInt(true);\n\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\tlet timelineType = input.readByte();\n\t\t\t\tlet frameCount = input.readInt(true);\n\t\t\t\tlet frameLast = frameCount - 1;\n\t\t\t\tswitch (timelineType) {\n\t\t\t\t\tcase SLOT_ATTACHMENT: {\n\t\t\t\t\t\tlet timeline = new AttachmentTimeline(frameCount, slotIndex);\n\t\t\t\t\t\tfor (let frame = 0; frame < frameCount; frame++)\n\t\t\t\t\t\t\ttimeline.setFrame(frame, input.readFloat(), input.readStringRef());\n\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase SLOT_RGBA: {\n\t\t\t\t\t\tlet bezierCount = input.readInt(true);\n\t\t\t\t\t\tlet timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);\n\n\t\t\t\t\t\tlet time = input.readFloat();\n\t\t\t\t\t\tlet r = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet g = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet b = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet a = input.readUnsignedByte() / 255.0;\n\n\t\t\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\t\t\ttimeline.setFrame(frame, time, r, g, b, a);\n\t\t\t\t\t\t\tif (frame == frameLast) break;\n\n\t\t\t\t\t\t\tlet time2 = input.readFloat();\n\t\t\t\t\t\t\tlet r2 = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet g2 = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet b2 = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet a2 = input.readUnsignedByte() / 255.0;\n\n\t\t\t\t\t\t\tswitch (input.readByte()) {\n\t\t\t\t\t\t\t\tcase CURVE_STEPPED:\n\t\t\t\t\t\t\t\t\ttimeline.setStepped(frame);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase CURVE_BEZIER:\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttime = time2;\n\t\t\t\t\t\t\tr = r2;\n\t\t\t\t\t\t\tg = g2;\n\t\t\t\t\t\t\tb = b2;\n\t\t\t\t\t\t\ta = a2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase SLOT_RGB: {\n\t\t\t\t\t\tlet bezierCount = input.readInt(true);\n\t\t\t\t\t\tlet timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);\n\n\t\t\t\t\t\tlet time = input.readFloat();\n\t\t\t\t\t\tlet r = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet g = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet b = input.readUnsignedByte() / 255.0;\n\n\t\t\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\t\t\ttimeline.setFrame(frame, time, r, g, b);\n\t\t\t\t\t\t\tif (frame == frameLast) break;\n\n\t\t\t\t\t\t\tlet time2 = input.readFloat();\n\t\t\t\t\t\t\tlet r2 = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet g2 = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet b2 = input.readUnsignedByte() / 255.0;\n\n\t\t\t\t\t\t\tswitch (input.readByte()) {\n\t\t\t\t\t\t\t\tcase CURVE_STEPPED:\n\t\t\t\t\t\t\t\t\ttimeline.setStepped(frame);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase CURVE_BEZIER:\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttime = time2;\n\t\t\t\t\t\t\tr = r2;\n\t\t\t\t\t\t\tg = g2;\n\t\t\t\t\t\t\tb = b2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase SLOT_RGBA2: {\n\t\t\t\t\t\tlet bezierCount = input.readInt(true);\n\t\t\t\t\t\tlet timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);\n\n\t\t\t\t\t\tlet time = input.readFloat();\n\t\t\t\t\t\tlet r = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet g = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet b = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet a = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet r2 = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet g2 = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet b2 = input.readUnsignedByte() / 255.0;\n\n\t\t\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\t\t\ttimeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);\n\t\t\t\t\t\t\tif (frame == frameLast) break;\n\t\t\t\t\t\t\tlet time2 = input.readFloat();\n\t\t\t\t\t\t\tlet nr = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet ng = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet nb = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet na = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet nr2 = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet ng2 = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet nb2 = input.readUnsignedByte() / 255.0;\n\n\t\t\t\t\t\t\tswitch (input.readByte()) {\n\t\t\t\t\t\t\t\tcase CURVE_STEPPED:\n\t\t\t\t\t\t\t\t\ttimeline.setStepped(frame);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase CURVE_BEZIER:\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttime = time2;\n\t\t\t\t\t\t\tr = nr;\n\t\t\t\t\t\t\tg = ng;\n\t\t\t\t\t\t\tb = nb;\n\t\t\t\t\t\t\ta = na;\n\t\t\t\t\t\t\tr2 = nr2;\n\t\t\t\t\t\t\tg2 = ng2;\n\t\t\t\t\t\t\tb2 = nb2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase SLOT_RGB2: {\n\t\t\t\t\t\tlet bezierCount = input.readInt(true);\n\t\t\t\t\t\tlet timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);\n\n\t\t\t\t\t\tlet time = input.readFloat();\n\t\t\t\t\t\tlet r = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet g = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet b = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet r2 = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet g2 = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\tlet b2 = input.readUnsignedByte() / 255.0;\n\n\t\t\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\t\t\ttimeline.setFrame(frame, time, r, g, b, r2, g2, b2);\n\t\t\t\t\t\t\tif (frame == frameLast) break;\n\t\t\t\t\t\t\tlet time2 = input.readFloat();\n\t\t\t\t\t\t\tlet nr = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet ng = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet nb = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet nr2 = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet ng2 = input.readUnsignedByte() / 255.0;\n\t\t\t\t\t\t\tlet nb2 = input.readUnsignedByte() / 255.0;\n\n\t\t\t\t\t\t\tswitch (input.readByte()) {\n\t\t\t\t\t\t\t\tcase CURVE_STEPPED:\n\t\t\t\t\t\t\t\t\ttimeline.setStepped(frame);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase CURVE_BEZIER:\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttime = time2;\n\t\t\t\t\t\t\tr = nr;\n\t\t\t\t\t\t\tg = ng;\n\t\t\t\t\t\t\tb = nb;\n\t\t\t\t\t\t\tr2 = nr2;\n\t\t\t\t\t\t\tg2 = ng2;\n\t\t\t\t\t\t\tb2 = nb2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase SLOT_ALPHA: {\n\t\t\t\t\t\tlet timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);\n\t\t\t\t\t\tlet time = input.readFloat(), a = input.readUnsignedByte() / 255;\n\t\t\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\t\t\ttimeline.setFrame(frame, time, a);\n\t\t\t\t\t\t\tif (frame == frameLast) break;\n\t\t\t\t\t\t\tlet time2 = input.readFloat();\n\t\t\t\t\t\t\tlet a2 = input.readUnsignedByte() / 255;\n\t\t\t\t\t\t\tswitch (input.readByte()) {\n\t\t\t\t\t\t\t\tcase CURVE_STEPPED:\n\t\t\t\t\t\t\t\t\ttimeline.setStepped(frame);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase CURVE_BEZIER:\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttime = time2;\n\t\t\t\t\t\t\ta = a2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Bone timelines.\n\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\tlet boneIndex = input.readInt(true);\n\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\tlet type = input.readByte(), frameCount = input.readInt(true);\n\t\t\t\tif (type == BONE_INHERIT) {\n\t\t\t\t\tlet timeline = new InheritTimeline(frameCount, boneIndex);\n\t\t\t\t\tfor (let frame = 0; frame < frameCount; frame++) {\n\t\t\t\t\t\ttimeline.setFrame(frame, input.readFloat(), input.readByte());\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet bezierCount = input.readInt(true);\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase BONE_ROTATE:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BONE_TRANSLATE:\n\t\t\t\t\t\ttimelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BONE_TRANSLATEX:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BONE_TRANSLATEY:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BONE_SCALE:\n\t\t\t\t\t\ttimelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BONE_SCALEX:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BONE_SCALEY:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BONE_SHEAR:\n\t\t\t\t\t\ttimelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BONE_SHEARX:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BONE_SHEARY:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// IK constraint timelines.\n\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\tlet index = input.readInt(true), frameCount = input.readInt(true), frameLast = frameCount - 1;\n\t\t\tlet timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index);\n\t\t\tlet flags = input.readByte();\n\t\t\tlet time = input.readFloat(), mix = (flags & 1) != 0 ? ((flags & 2) != 0 ? input.readFloat() : 1) : 0;\n\t\t\tlet softness = (flags & 4) != 0 ? input.readFloat() * scale : 0;\n\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\ttimeline.setFrame(frame, time, mix, softness, (flags & 8) != 0 ? 1 : -1, (flags & 16) != 0, (flags & 32) != 0);\n\t\t\t\tif (frame == frameLast) break;\n\t\t\t\tflags = input.readByte();\n\t\t\t\tconst time2 = input.readFloat(), mix2 = (flags & 1) != 0 ? ((flags & 2) != 0 ? input.readFloat() : 1) : 0;\n\t\t\t\tconst softness2 = (flags & 4) != 0 ? input.readFloat() * scale : 0;\n\t\t\t\tif ((flags & 64) != 0) {\n\t\t\t\t\ttimeline.setStepped(frame);\n\t\t\t\t} else if ((flags & 128) != 0) {\n\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);\n\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);\n\t\t\t\t}\n\t\t\t\ttime = time2;\n\t\t\t\tmix = mix2;\n\t\t\t\tsoftness = softness2;\n\t\t\t}\n\t\t\ttimelines.push(timeline);\n\t\t}\n\n\t\t// Transform constraint timelines.\n\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\tlet index = input.readInt(true), frameCount = input.readInt(true), frameLast = frameCount - 1;\n\t\t\tlet timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index);\n\t\t\tlet time = input.readFloat(), mixRotate = input.readFloat(), mixX = input.readFloat(), mixY = input.readFloat(),\n\t\t\t\tmixScaleX = input.readFloat(), mixScaleY = input.readFloat(), mixShearY = input.readFloat();\n\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\ttimeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n\t\t\t\tif (frame == frameLast) break;\n\t\t\t\tlet time2 = input.readFloat(), mixRotate2 = input.readFloat(), mixX2 = input.readFloat(), mixY2 = input.readFloat(),\n\t\t\t\t\tmixScaleX2 = input.readFloat(), mixScaleY2 = input.readFloat(), mixShearY2 = input.readFloat();\n\t\t\t\tswitch (input.readByte()) {\n\t\t\t\t\tcase CURVE_STEPPED:\n\t\t\t\t\t\ttimeline.setStepped(frame);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CURVE_BEZIER:\n\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n\t\t\t\t}\n\t\t\t\ttime = time2;\n\t\t\t\tmixRotate = mixRotate2;\n\t\t\t\tmixX = mixX2;\n\t\t\t\tmixY = mixY2;\n\t\t\t\tmixScaleX = mixScaleX2;\n\t\t\t\tmixScaleY = mixScaleY2;\n\t\t\t\tmixShearY = mixShearY2;\n\t\t\t}\n\t\t\ttimelines.push(timeline);\n\t\t}\n\n\t\t// Path constraint timelines.\n\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\tlet index = input.readInt(true);\n\t\t\tlet data = skeletonData.pathConstraints[index];\n\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\tconst type = input.readByte(), frameCount = input.readInt(true), bezierCount = input.readInt(true);\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase PATH_POSITION:\n\t\t\t\t\t\ttimelines\n\t\t\t\t\t\t\t.push(readTimeline1(input, new PathConstraintPositionTimeline(frameCount, bezierCount, index),\n\t\t\t\t\t\t\t\tdata.positionMode == PositionMode.Fixed ? scale : 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PATH_SPACING:\n\t\t\t\t\t\ttimelines\n\t\t\t\t\t\t\t.push(readTimeline1(input, new PathConstraintSpacingTimeline(frameCount, bezierCount, index),\n\t\t\t\t\t\t\t\tdata.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PATH_MIX:\n\t\t\t\t\t\tlet timeline = new PathConstraintMixTimeline(frameCount, bezierCount, index);\n\t\t\t\t\t\tlet time = input.readFloat(), mixRotate = input.readFloat(), mixX = input.readFloat(), mixY = input.readFloat();\n\t\t\t\t\t\tfor (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n\t\t\t\t\t\t\ttimeline.setFrame(frame, time, mixRotate, mixX, mixY);\n\t\t\t\t\t\t\tif (frame == frameLast) break;\n\t\t\t\t\t\t\tlet time2 = input.readFloat(), mixRotate2 = input.readFloat(), mixX2 = input.readFloat(),\n\t\t\t\t\t\t\t\tmixY2 = input.readFloat();\n\t\t\t\t\t\t\tswitch (input.readByte()) {\n\t\t\t\t\t\t\t\tcase CURVE_STEPPED:\n\t\t\t\t\t\t\t\t\ttimeline.setStepped(frame);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase CURVE_BEZIER:\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttime = time2;\n\t\t\t\t\t\t\tmixRotate = mixRotate2;\n\t\t\t\t\t\t\tmixX = mixX2;\n\t\t\t\t\t\t\tmixY = mixY2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Physics timelines.\n\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\tconst index = input.readInt(true) - 1;\n\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\tconst type = input.readByte(), frameCount = input.readInt(true);\n\t\t\t\tif (type == PHYSICS_RESET) {\n\t\t\t\t\tconst timeline = new PhysicsConstraintResetTimeline(frameCount, index);\n\t\t\t\t\tfor (let frame = 0; frame < frameCount; frame++)\n\t\t\t\t\t\ttimeline.setFrame(frame, input.readFloat());\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst bezierCount = input.readInt(true);\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase PHYSICS_INERTIA:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new PhysicsConstraintInertiaTimeline(frameCount, bezierCount, index), 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PHYSICS_STRENGTH:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new PhysicsConstraintStrengthTimeline(frameCount, bezierCount, index), 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PHYSICS_DAMPING:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new PhysicsConstraintDampingTimeline(frameCount, bezierCount, index), 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PHYSICS_MASS:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new PhysicsConstraintMassTimeline(frameCount, bezierCount, index), 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PHYSICS_WIND:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new PhysicsConstraintWindTimeline(frameCount, bezierCount, index), 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PHYSICS_GRAVITY:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new PhysicsConstraintGravityTimeline(frameCount, bezierCount, index), 1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PHYSICS_MIX:\n\t\t\t\t\t\ttimelines.push(readTimeline1(input, new PhysicsConstraintMixTimeline(frameCount, bezierCount, index), 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Deform timelines.\n\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\tlet skin = skeletonData.skins[input.readInt(true)];\n\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\tlet slotIndex = input.readInt(true);\n\t\t\t\tfor (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n\t\t\t\t\tlet attachmentName = input.readStringRef();\n\t\t\t\t\tif (!attachmentName) throw new Error(\"attachmentName must not be null.\");\n\t\t\t\t\tlet attachment = skin.getAttachment(slotIndex, attachmentName);\n\t\t\t\t\tlet timelineType = input.readByte();\n\t\t\t\t\tlet frameCount = input.readInt(true);\n\t\t\t\t\tlet frameLast = frameCount - 1;\n\n\t\t\t\t\tswitch (timelineType) {\n\t\t\t\t\t\tcase ATTACHMENT_DEFORM: {\n\t\t\t\t\t\t\tlet vertexAttachment = attachment as VertexAttachment;\n\t\t\t\t\t\t\tlet weighted = vertexAttachment.bones;\n\t\t\t\t\t\t\tlet vertices = vertexAttachment.vertices;\n\t\t\t\t\t\t\tlet deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n\n\n\t\t\t\t\t\t\tlet bezierCount = input.readInt(true);\n\t\t\t\t\t\t\tlet timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);\n\n\t\t\t\t\t\t\tlet time = input.readFloat();\n\t\t\t\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\t\t\t\tlet deform;\n\t\t\t\t\t\t\t\tlet end = input.readInt(true);\n\t\t\t\t\t\t\t\tif (end == 0)\n\t\t\t\t\t\t\t\t\tdeform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tdeform = Utils.newFloatArray(deformLength);\n\t\t\t\t\t\t\t\t\tlet start = input.readInt(true);\n\t\t\t\t\t\t\t\t\tend += start;\n\t\t\t\t\t\t\t\t\tif (scale == 1) {\n\t\t\t\t\t\t\t\t\t\tfor (let v = start; v < end; v++)\n\t\t\t\t\t\t\t\t\t\t\tdeform[v] = input.readFloat();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tfor (let v = start; v < end; v++)\n\t\t\t\t\t\t\t\t\t\t\tdeform[v] = input.readFloat() * scale;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!weighted) {\n\t\t\t\t\t\t\t\t\t\tfor (let v = 0, vn = deform.length; v < vn; v++)\n\t\t\t\t\t\t\t\t\t\t\tdeform[v] += vertices[v];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttimeline.setFrame(frame, time, deform);\n\t\t\t\t\t\t\t\tif (frame == frameLast) break;\n\t\t\t\t\t\t\t\tlet time2 = input.readFloat();\n\t\t\t\t\t\t\t\tswitch (input.readByte()) {\n\t\t\t\t\t\t\t\t\tcase CURVE_STEPPED:\n\t\t\t\t\t\t\t\t\t\ttimeline.setStepped(frame);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase CURVE_BEZIER:\n\t\t\t\t\t\t\t\t\t\tsetBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttime = time2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase ATTACHMENT_SEQUENCE: {\n\t\t\t\t\t\t\tlet timeline = new SequenceTimeline(frameCount, slotIndex, attachment as unknown as HasTextureRegion);\n\t\t\t\t\t\t\tfor (let frame = 0; frame < frameCount; frame++) {\n\t\t\t\t\t\t\t\tlet time = input.readFloat();\n\t\t\t\t\t\t\t\tlet modeAndIndex = input.readInt32();\n\t\t\t\t\t\t\t\ttimeline.setFrame(frame, time, SequenceModeValues[modeAndIndex & 0xf], modeAndIndex >> 4,\n\t\t\t\t\t\t\t\t\tinput.readFloat());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Draw order timeline.\n\t\tlet drawOrderCount = input.readInt(true);\n\t\tif (drawOrderCount > 0) {\n\t\t\tlet timeline = new DrawOrderTimeline(drawOrderCount);\n\t\t\tlet slotCount = skeletonData.slots.length;\n\t\t\tfor (let i = 0; i < drawOrderCount; i++) {\n\t\t\t\tlet time = input.readFloat();\n\t\t\t\tlet offsetCount = input.readInt(true);\n\t\t\t\tlet drawOrder = Utils.newArray(slotCount, 0);\n\t\t\t\tfor (let ii = slotCount - 1; ii >= 0; ii--)\n\t\t\t\t\tdrawOrder[ii] = -1;\n\t\t\t\tlet unchanged = Utils.newArray(slotCount - offsetCount, 0);\n\t\t\t\tlet originalIndex = 0, unchangedIndex = 0;\n\t\t\t\tfor (let ii = 0; ii < offsetCount; ii++) {\n\t\t\t\t\tlet slotIndex = input.readInt(true);\n\t\t\t\t\t// Collect unchanged items.\n\t\t\t\t\twhile (originalIndex != slotIndex)\n\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\n\t\t\t\t\t// Set changed items.\n\t\t\t\t\tdrawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n\t\t\t\t}\n\t\t\t\t// Collect remaining unchanged items.\n\t\t\t\twhile (originalIndex < slotCount)\n\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\n\t\t\t\t// Fill in unchanged items.\n\t\t\t\tfor (let ii = slotCount - 1; ii >= 0; ii--)\n\t\t\t\t\tif (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n\t\t\t\ttimeline.setFrame(i, time, drawOrder);\n\t\t\t}\n\t\t\ttimelines.push(timeline);\n\t\t}\n\n\t\t// Event timeline.\n\t\tlet eventCount = input.readInt(true);\n\t\tif (eventCount > 0) {\n\t\t\tlet timeline = new EventTimeline(eventCount);\n\t\t\tfor (let i = 0; i < eventCount; i++) {\n\t\t\t\tlet time = input.readFloat();\n\t\t\t\tlet eventData = skeletonData.events[input.readInt(true)];\n\t\t\t\tlet event = new Event(time, eventData);\n\t\t\t\tevent.intValue = input.readInt(false);\n\t\t\t\tevent.floatValue = input.readFloat();\n\t\t\t\tevent.stringValue = input.readString();\n\t\t\t\tif (event.stringValue == null) event.stringValue = eventData.stringValue;\n\t\t\t\tif (event.data.audioPath) {\n\t\t\t\t\tevent.volume = input.readFloat();\n\t\t\t\t\tevent.balance = input.readFloat();\n\t\t\t\t}\n\t\t\t\ttimeline.setFrame(i, event);\n\t\t\t}\n\t\t\ttimelines.push(timeline);\n\t\t}\n\n\t\tlet duration = 0;\n\t\tfor (let i = 0, n = timelines.length; i < n; i++)\n\t\t\tduration = Math.max(duration, timelines[i].getDuration());\n\t\treturn new Animation(name, timelines, duration);\n\t}\n}\n\nexport class BinaryInput {\n\tconstructor (data: Uint8Array | ArrayBuffer, public strings = new Array<string>(), private index: number = 0, private buffer = new DataView(data instanceof ArrayBuffer ? data : data.buffer)) {\n\t}\n\n\treadByte (): number {\n\t\treturn this.buffer.getInt8(this.index++);\n\t}\n\n\treadUnsignedByte (): number {\n\t\treturn this.buffer.getUint8(this.index++);\n\t}\n\n\treadShort (): number {\n\t\tlet value = this.buffer.getInt16(this.index);\n\t\tthis.index += 2;\n\t\treturn value;\n\t}\n\n\treadInt32 (): number {\n\t\tlet value = this.buffer.getInt32(this.index)\n\t\tthis.index += 4;\n\t\treturn value;\n\t}\n\n\treadInt (optimizePositive: boolean) {\n\t\tlet b = this.readByte();\n\t\tlet result = b & 0x7F;\n\t\tif ((b & 0x80) != 0) {\n\t\t\tb = this.readByte();\n\t\t\tresult |= (b & 0x7F) << 7;\n\t\t\tif ((b & 0x80) != 0) {\n\t\t\t\tb = this.readByte();\n\t\t\t\tresult |= (b & 0x7F) << 14;\n\t\t\t\tif ((b & 0x80) != 0) {\n\t\t\t\t\tb = this.readByte();\n\t\t\t\t\tresult |= (b & 0x7F) << 21;\n\t\t\t\t\tif ((b & 0x80) != 0) {\n\t\t\t\t\t\tb = this.readByte();\n\t\t\t\t\t\tresult |= (b & 0x7F) << 28;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn optimizePositive ? result : ((result >>> 1) ^ -(result & 1));\n\t}\n\n\treadStringRef (): string | null {\n\t\tlet index = this.readInt(true);\n\t\treturn index == 0 ? null : this.strings[index - 1];\n\t}\n\n\treadString (): string | null {\n\t\tlet byteCount = this.readInt(true);\n\t\tswitch (byteCount) {\n\t\t\tcase 0:\n\t\t\t\treturn null;\n\t\t\tcase 1:\n\t\t\t\treturn \"\";\n\t\t}\n\t\tbyteCount--;\n\t\tlet chars = \"\";\n\t\tlet charCount = 0;\n\t\tfor (let i = 0; i < byteCount;) {\n\t\t\tlet b = this.readUnsignedByte();\n\t\t\tswitch (b >> 4) {\n\t\t\t\tcase 12:\n\t\t\t\tcase 13:\n\t\t\t\t\tchars += String.fromCharCode(((b & 0x1F) << 6 | this.readByte() & 0x3F));\n\t\t\t\t\ti += 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\tchars += String.fromCharCode(((b & 0x0F) << 12 | (this.readByte() & 0x3F) << 6 | this.readByte() & 0x3F));\n\t\t\t\t\ti += 3;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tchars += String.fromCharCode(b);\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn chars;\n\t}\n\n\treadFloat (): number {\n\t\tlet value = this.buffer.getFloat32(this.index);\n\t\tthis.index += 4;\n\t\treturn value;\n\t}\n\n\treadBoolean (): boolean {\n\t\treturn this.readByte() != 0;\n\t}\n}\n\nclass LinkedMesh {\n\tparent: string | null; skinIndex: number;\n\tslotIndex: number;\n\tmesh: MeshAttachment;\n\tinheritTimeline: boolean;\n\n\tconstructor (mesh: MeshAttachment, skinIndex: number, slotIndex: number, parent: string | null, inheritDeform: boolean) {\n\t\tthis.mesh = mesh;\n\t\tthis.skinIndex = skinIndex;\n\t\tthis.slotIndex = slotIndex;\n\t\tthis.parent = parent;\n\t\tthis.inheritTimeline = inheritDeform;\n\t}\n}\n\nclass Vertices {\n\tconstructor (public bones: Array<number> | null = null, public vertices: Array<number> | Float32Array | null = null, public length: number = 0) { }\n}\n\nenum AttachmentType { Region, BoundingBox, Mesh, LinkedMesh, Path, Point, Clipping }\n\nfunction readTimeline1 (input: BinaryInput, timeline: CurveTimeline1, scale: number): CurveTimeline1 {\n\tlet time = input.readFloat(), value = input.readFloat() * scale;\n\tfor (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n\t\ttimeline.setFrame(frame, time, value);\n\t\tif (frame == frameLast) break;\n\t\tlet time2 = input.readFloat(), value2 = input.readFloat() * scale;\n\t\tswitch (input.readByte()) {\n\t\t\tcase CURVE_STEPPED:\n\t\t\t\ttimeline.setStepped(frame);\n\t\t\t\tbreak;\n\t\t\tcase CURVE_BEZIER:\n\t\t\t\tsetBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);\n\t\t}\n\t\ttime = time2;\n\t\tvalue = value2;\n\t}\n\treturn timeline;\n}\n\nfunction readTimeline2 (input: BinaryInput, timeline: CurveTimeline2, scale: number): CurveTimeline2 {\n\tlet time = input.readFloat(), value1 = input.readFloat() * scale, value2 = input.readFloat() * scale;\n\tfor (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n\t\ttimeline.setFrame(frame, time, value1, value2);\n\t\tif (frame == frameLast) break;\n\t\tlet time2 = input.readFloat(), nvalue1 = input.readFloat() * scale, nvalue2 = input.readFloat() * scale;\n\t\tswitch (input.readByte()) {\n\t\t\tcase CURVE_STEPPED:\n\t\t\t\ttimeline.setStepped(frame);\n\t\t\t\tbreak;\n\t\t\tcase CURVE_BEZIER:\n\t\t\t\tsetBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);\n\t\t\t\tsetBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);\n\t\t}\n\t\ttime = time2;\n\t\tvalue1 = nvalue1;\n\t\tvalue2 = nvalue2;\n\t}\n\treturn timeline;\n}\n\nfunction setBezier (input: BinaryInput, timeline: CurveTimeline, bezier: number, frame: number, value: number,\n\ttime1: number, time2: number, value1: number, value2: number, scale: number) {\n\ttimeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);\n}\n\nconst BONE_ROTATE = 0;\nconst BONE_TRANSLATE = 1;\nconst BONE_TRANSLATEX = 2;\nconst BONE_TRANSLATEY = 3;\nconst BONE_SCALE = 4;\nconst BONE_SCALEX = 5;\nconst BONE_SCALEY = 6;\nconst BONE_SHEAR = 7;\nconst BONE_SHEARX = 8;\nconst BONE_SHEARY = 9;\nconst BONE_INHERIT = 10;\n\nconst SLOT_ATTACHMENT = 0;\nconst SLOT_RGBA = 1;\nconst SLOT_RGB = 2;\nconst SLOT_RGBA2 = 3;\nconst SLOT_RGB2 = 4;\nconst SLOT_ALPHA = 5;\n\nconst ATTACHMENT_DEFORM = 0;\nconst ATTACHMENT_SEQUENCE = 1;\n\nconst PATH_POSITION = 0;\nconst PATH_SPACING = 1;\nconst PATH_MIX = 2;\n\nconst PHYSICS_INERTIA = 0;\nconst PHYSICS_STRENGTH = 1;\nconst PHYSICS_DAMPING = 2;\nconst PHYSICS_MASS = 4;\nconst PHYSICS_WIND = 5;\nconst PHYSICS_GRAVITY = 6;\nconst PHYSICS_MIX = 7;\nconst PHYSICS_RESET = 8;\n\nconst CURVE_LINEAR = 0;\nconst CURVE_STEPPED = 1;\nconst CURVE_BEZIER = 2;\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { BoundingBoxAttachment } from \"./attachments/BoundingBoxAttachment.js\";\nimport { Skeleton } from \"./Skeleton.js\";\nimport { NumberArrayLike, Pool, Utils } from \"./Utils.js\";\n\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\n * provided along with convenience methods for doing hit detection. */\nexport class SkeletonBounds {\n\n\t/** The left edge of the axis aligned bounding box. */\n\tminX = 0;\n\n\t/** The bottom edge of the axis aligned bounding box. */\n\tminY = 0;\n\n\t/** The right edge of the axis aligned bounding box. */\n\tmaxX = 0;\n\n\t/** The top edge of the axis aligned bounding box. */\n\tmaxY = 0;\n\n\t/** The visible bounding boxes. */\n\tboundingBoxes = new Array<BoundingBoxAttachment>();\n\n\t/** The world vertices for the bounding box polygons. */\n\tpolygons = new Array<NumberArrayLike>();\n\n\tprivate polygonPool = new Pool<NumberArrayLike>(() => {\n\t\treturn Utils.newFloatArray(16);\n\t});\n\n\t/** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding\n\t * box's polygon.\n\t * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the\n\t *           SkeletonBounds AABB methods will always return true. */\n\tupdate (skeleton: Skeleton, updateAabb: boolean) {\n\t\tif (!skeleton) throw new Error(\"skeleton cannot be null.\");\n\t\tlet boundingBoxes = this.boundingBoxes;\n\t\tlet polygons = this.polygons;\n\t\tlet polygonPool = this.polygonPool;\n\t\tlet slots = skeleton.slots;\n\t\tlet slotCount = slots.length;\n\n\t\tboundingBoxes.length = 0;\n\t\tpolygonPool.freeAll(polygons);\n\t\tpolygons.length = 0;\n\n\t\tfor (let i = 0; i < slotCount; i++) {\n\t\t\tlet slot = slots[i];\n\t\t\tif (!slot.bone.active) continue;\n\t\t\tlet attachment = slot.getAttachment();\n\t\t\tif (attachment instanceof BoundingBoxAttachment) {\n\t\t\t\tlet boundingBox = attachment as BoundingBoxAttachment;\n\t\t\t\tboundingBoxes.push(boundingBox);\n\n\t\t\t\tlet polygon = polygonPool.obtain();\n\t\t\t\tif (polygon.length != boundingBox.worldVerticesLength) {\n\t\t\t\t\tpolygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\n\t\t\t\t}\n\t\t\t\tpolygons.push(polygon);\n\t\t\t\tboundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n\t\t\t}\n\t\t}\n\n\t\tif (updateAabb) {\n\t\t\tthis.aabbCompute();\n\t\t} else {\n\t\t\tthis.minX = Number.POSITIVE_INFINITY;\n\t\t\tthis.minY = Number.POSITIVE_INFINITY;\n\t\t\tthis.maxX = Number.NEGATIVE_INFINITY;\n\t\t\tthis.maxY = Number.NEGATIVE_INFINITY;\n\t\t}\n\t}\n\n\taabbCompute () {\n\t\tlet minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n\t\tlet polygons = this.polygons;\n\t\tfor (let i = 0, n = polygons.length; i < n; i++) {\n\t\t\tlet polygon = polygons[i];\n\t\t\tlet vertices = polygon;\n\t\t\tfor (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n\t\t\t\tlet x = vertices[ii];\n\t\t\t\tlet y = vertices[ii + 1];\n\t\t\t\tminX = Math.min(minX, x);\n\t\t\t\tminY = Math.min(minY, y);\n\t\t\t\tmaxX = Math.max(maxX, x);\n\t\t\t\tmaxY = Math.max(maxY, y);\n\t\t\t}\n\t\t}\n\t\tthis.minX = minX;\n\t\tthis.minY = minY;\n\t\tthis.maxX = maxX;\n\t\tthis.maxY = maxY;\n\t}\n\n\t/** Returns true if the axis aligned bounding box contains the point. */\n\taabbContainsPoint (x: number, y: number) {\n\t\treturn x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n\t}\n\n\t/** Returns true if the axis aligned bounding box intersects the line segment. */\n\taabbIntersectsSegment (x1: number, y1: number, x2: number, y2: number) {\n\t\tlet minX = this.minX;\n\t\tlet minY = this.minY;\n\t\tlet maxX = this.maxX;\n\t\tlet maxY = this.maxY;\n\t\tif ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\n\t\t\treturn false;\n\t\tlet m = (y2 - y1) / (x2 - x1);\n\t\tlet y = m * (minX - x1) + y1;\n\t\tif (y > minY && y < maxY) return true;\n\t\ty = m * (maxX - x1) + y1;\n\t\tif (y > minY && y < maxY) return true;\n\t\tlet x = (minY - y1) / m + x1;\n\t\tif (x > minX && x < maxX) return true;\n\t\tx = (maxY - y1) / m + x1;\n\t\tif (x > minX && x < maxX) return true;\n\t\treturn false;\n\t}\n\n\t/** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n\taabbIntersectsSkeleton (bounds: SkeletonBounds) {\n\t\treturn this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n\t}\n\n\t/** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n\t * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\n\tcontainsPoint (x: number, y: number): BoundingBoxAttachment | null {\n\t\tlet polygons = this.polygons;\n\t\tfor (let i = 0, n = polygons.length; i < n; i++)\n\t\t\tif (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n\t\treturn null;\n\t}\n\n\t/** Returns true if the polygon contains the point. */\n\tcontainsPointPolygon (polygon: NumberArrayLike, x: number, y: number) {\n\t\tlet vertices = polygon;\n\t\tlet nn = polygon.length;\n\n\t\tlet prevIndex = nn - 2;\n\t\tlet inside = false;\n\t\tfor (let ii = 0; ii < nn; ii += 2) {\n\t\t\tlet vertexY = vertices[ii + 1];\n\t\t\tlet prevY = vertices[prevIndex + 1];\n\t\t\tif ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\n\t\t\t\tlet vertexX = vertices[ii];\n\t\t\t\tif (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n\t\t\t}\n\t\t\tprevIndex = ii;\n\t\t}\n\t\treturn inside;\n\t}\n\n\t/** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\n\t * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns\n\t * true. */\n\tintersectsSegment (x1: number, y1: number, x2: number, y2: number) {\n\t\tlet polygons = this.polygons;\n\t\tfor (let i = 0, n = polygons.length; i < n; i++)\n\t\t\tif (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n\t\treturn null;\n\t}\n\n\t/** Returns true if the polygon contains any part of the line segment. */\n\tintersectsSegmentPolygon (polygon: NumberArrayLike, x1: number, y1: number, x2: number, y2: number) {\n\t\tlet vertices = polygon;\n\t\tlet nn = polygon.length;\n\n\t\tlet width12 = x1 - x2, height12 = y1 - y2;\n\t\tlet det1 = x1 * y2 - y1 * x2;\n\t\tlet x3 = vertices[nn - 2], y3 = vertices[nn - 1];\n\t\tfor (let ii = 0; ii < nn; ii += 2) {\n\t\t\tlet x4 = vertices[ii], y4 = vertices[ii + 1];\n\t\t\tlet det2 = x3 * y4 - y3 * x4;\n\t\t\tlet width34 = x3 - x4, height34 = y3 - y4;\n\t\t\tlet det3 = width12 * height34 - height12 * width34;\n\t\t\tlet x = (det1 * width34 - width12 * det2) / det3;\n\t\t\tif (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\n\t\t\t\tlet y = (det1 * height34 - height12 * det2) / det3;\n\t\t\t\tif (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\n\t\t\t}\n\t\t\tx3 = x4;\n\t\t\ty3 = y4;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** Returns the polygon for the specified bounding box, or null. */\n\tgetPolygon (boundingBox: BoundingBoxAttachment) {\n\t\tif (!boundingBox) throw new Error(\"boundingBox cannot be null.\");\n\t\tlet index = this.boundingBoxes.indexOf(boundingBox);\n\t\treturn index == -1 ? null : this.polygons[index];\n\t}\n\n\t/** The width of the axis aligned bounding box. */\n\tgetWidth () {\n\t\treturn this.maxX - this.minX;\n\t}\n\n\t/** The height of the axis aligned bounding box. */\n\tgetHeight () {\n\t\treturn this.maxY - this.minY;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { NumberArrayLike, Pool } from \"./Utils.js\";\n\nexport class Triangulator {\n\tprivate convexPolygons = new Array<Array<number>>();\n\tprivate convexPolygonsIndices = new Array<Array<number>>();\n\n\tprivate indicesArray = new Array<number>();\n\tprivate isConcaveArray = new Array<boolean>();\n\tprivate triangles = new Array<number>();\n\n\tprivate polygonPool = new Pool<Array<number>>(() => {\n\t\treturn new Array<number>();\n\t});\n\n\tprivate polygonIndicesPool = new Pool<Array<number>>(() => {\n\t\treturn new Array<number>();\n\t});\n\n\tpublic triangulate (verticesArray: NumberArrayLike): Array<number> {\n\t\tlet vertices = verticesArray;\n\t\tlet vertexCount = verticesArray.length >> 1;\n\n\t\tlet indices = this.indicesArray;\n\t\tindices.length = 0;\n\t\tfor (let i = 0; i < vertexCount; i++)\n\t\t\tindices[i] = i;\n\n\t\tlet isConcave = this.isConcaveArray;\n\t\tisConcave.length = 0;\n\t\tfor (let i = 0, n = vertexCount; i < n; ++i)\n\t\t\tisConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\n\n\t\tlet triangles = this.triangles;\n\t\ttriangles.length = 0;\n\n\t\twhile (vertexCount > 3) {\n\t\t\t// Find ear tip.\n\t\t\tlet previous = vertexCount - 1, i = 0, next = 1;\n\t\t\twhile (true) {\n\t\t\t\touter:\n\t\t\t\tif (!isConcave[i]) {\n\t\t\t\t\tlet p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;\n\t\t\t\t\tlet p1x = vertices[p1], p1y = vertices[p1 + 1];\n\t\t\t\t\tlet p2x = vertices[p2], p2y = vertices[p2 + 1];\n\t\t\t\t\tlet p3x = vertices[p3], p3y = vertices[p3 + 1];\n\t\t\t\t\tfor (let ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\n\t\t\t\t\t\tif (!isConcave[ii]) continue;\n\t\t\t\t\t\tlet v = indices[ii] << 1;\n\t\t\t\t\t\tlet vx = vertices[v], vy = vertices[v + 1];\n\t\t\t\t\t\tif (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\n\t\t\t\t\t\t\tif (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\n\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy)) break outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (next == 0) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (!isConcave[i]) break;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t} while (i > 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tprevious = i;\n\t\t\t\ti = next;\n\t\t\t\tnext = (next + 1) % vertexCount;\n\t\t\t}\n\n\t\t\t// Cut ear tip.\n\t\t\ttriangles.push(indices[(vertexCount + i - 1) % vertexCount]);\n\t\t\ttriangles.push(indices[i]);\n\t\t\ttriangles.push(indices[(i + 1) % vertexCount]);\n\t\t\tindices.splice(i, 1);\n\t\t\tisConcave.splice(i, 1);\n\t\t\tvertexCount--;\n\n\t\t\tlet previousIndex = (vertexCount + i - 1) % vertexCount;\n\t\t\tlet nextIndex = i == vertexCount ? 0 : i;\n\t\t\tisConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\n\t\t\tisConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\n\t\t}\n\n\t\tif (vertexCount == 3) {\n\t\t\ttriangles.push(indices[2]);\n\t\t\ttriangles.push(indices[0]);\n\t\t\ttriangles.push(indices[1]);\n\t\t}\n\n\t\treturn triangles;\n\t}\n\n\tdecompose (verticesArray: Array<number>, triangles: Array<number>): Array<Array<number>> {\n\t\tlet vertices = verticesArray;\n\t\tlet convexPolygons = this.convexPolygons;\n\t\tthis.polygonPool.freeAll(convexPolygons);\n\t\tconvexPolygons.length = 0;\n\n\t\tlet convexPolygonsIndices = this.convexPolygonsIndices;\n\t\tthis.polygonIndicesPool.freeAll(convexPolygonsIndices);\n\t\tconvexPolygonsIndices.length = 0;\n\n\t\tlet polygonIndices = this.polygonIndicesPool.obtain();\n\t\tpolygonIndices.length = 0;\n\n\t\tlet polygon = this.polygonPool.obtain();\n\t\tpolygon.length = 0;\n\n\t\t// Merge subsequent triangles if they form a triangle fan.\n\t\tlet fanBaseIndex = -1, lastWinding = 0;\n\t\tfor (let i = 0, n = triangles.length; i < n; i += 3) {\n\t\t\tlet t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;\n\t\t\tlet x1 = vertices[t1], y1 = vertices[t1 + 1];\n\t\t\tlet x2 = vertices[t2], y2 = vertices[t2 + 1];\n\t\t\tlet x3 = vertices[t3], y3 = vertices[t3 + 1];\n\n\t\t\t// If the base of the last triangle is the same as this triangle, check if they form a convex polygon (triangle fan).\n\t\t\tlet merged = false;\n\t\t\tif (fanBaseIndex == t1) {\n\t\t\t\tlet o = polygon.length - 4;\n\t\t\t\tlet winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\n\t\t\t\tlet winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\n\t\t\t\tif (winding1 == lastWinding && winding2 == lastWinding) {\n\t\t\t\t\tpolygon.push(x3);\n\t\t\t\t\tpolygon.push(y3);\n\t\t\t\t\tpolygonIndices.push(t3);\n\t\t\t\t\tmerged = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise make this triangle the new base.\n\t\t\tif (!merged) {\n\t\t\t\tif (polygon.length > 0) {\n\t\t\t\t\tconvexPolygons.push(polygon);\n\t\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\n\t\t\t\t} else {\n\t\t\t\t\tthis.polygonPool.free(polygon)\n\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\n\t\t\t\t}\n\t\t\t\tpolygon = this.polygonPool.obtain();\n\t\t\t\tpolygon.length = 0;\n\t\t\t\tpolygon.push(x1);\n\t\t\t\tpolygon.push(y1);\n\t\t\t\tpolygon.push(x2);\n\t\t\t\tpolygon.push(y2);\n\t\t\t\tpolygon.push(x3);\n\t\t\t\tpolygon.push(y3);\n\t\t\t\tpolygonIndices = this.polygonIndicesPool.obtain();\n\t\t\t\tpolygonIndices.length = 0;\n\t\t\t\tpolygonIndices.push(t1);\n\t\t\t\tpolygonIndices.push(t2);\n\t\t\t\tpolygonIndices.push(t3);\n\t\t\t\tlastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\n\t\t\t\tfanBaseIndex = t1;\n\t\t\t}\n\t\t}\n\n\t\tif (polygon.length > 0) {\n\t\t\tconvexPolygons.push(polygon);\n\t\t\tconvexPolygonsIndices.push(polygonIndices);\n\t\t}\n\n\t\t// Go through the list of polygons and try to merge the remaining triangles with the found triangle fans.\n\t\tfor (let i = 0, n = convexPolygons.length; i < n; i++) {\n\t\t\tpolygonIndices = convexPolygonsIndices[i];\n\t\t\tif (polygonIndices.length == 0) continue;\n\t\t\tlet firstIndex = polygonIndices[0];\n\t\t\tlet lastIndex = polygonIndices[polygonIndices.length - 1];\n\n\t\t\tpolygon = convexPolygons[i];\n\t\t\tlet o = polygon.length - 4;\n\t\t\tlet prevPrevX = polygon[o], prevPrevY = polygon[o + 1];\n\t\t\tlet prevX = polygon[o + 2], prevY = polygon[o + 3];\n\t\t\tlet firstX = polygon[0], firstY = polygon[1];\n\t\t\tlet secondX = polygon[2], secondY = polygon[3];\n\t\t\tlet winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\n\n\t\t\tfor (let ii = 0; ii < n; ii++) {\n\t\t\t\tif (ii == i) continue;\n\t\t\t\tlet otherIndices = convexPolygonsIndices[ii];\n\t\t\t\tif (otherIndices.length != 3) continue;\n\t\t\t\tlet otherFirstIndex = otherIndices[0];\n\t\t\t\tlet otherSecondIndex = otherIndices[1];\n\t\t\t\tlet otherLastIndex = otherIndices[2];\n\n\t\t\t\tlet otherPoly = convexPolygons[ii];\n\t\t\t\tlet x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];\n\n\t\t\t\tif (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex) continue;\n\t\t\t\tlet winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\n\t\t\t\tlet winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\n\t\t\t\tif (winding1 == winding && winding2 == winding) {\n\t\t\t\t\totherPoly.length = 0;\n\t\t\t\t\totherIndices.length = 0;\n\t\t\t\t\tpolygon.push(x3);\n\t\t\t\t\tpolygon.push(y3);\n\t\t\t\t\tpolygonIndices.push(otherLastIndex);\n\t\t\t\t\tprevPrevX = prevX;\n\t\t\t\t\tprevPrevY = prevY;\n\t\t\t\t\tprevX = x3;\n\t\t\t\t\tprevY = y3;\n\t\t\t\t\tii = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove empty polygons that resulted from the merge step above.\n\t\tfor (let i = convexPolygons.length - 1; i >= 0; i--) {\n\t\t\tpolygon = convexPolygons[i];\n\t\t\tif (polygon.length == 0) {\n\t\t\t\tconvexPolygons.splice(i, 1);\n\t\t\t\tthis.polygonPool.free(polygon);\n\t\t\t\tpolygonIndices = convexPolygonsIndices[i]\n\t\t\t\tconvexPolygonsIndices.splice(i, 1)\n\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\n\t\t\t}\n\t\t}\n\n\t\treturn convexPolygons;\n\t}\n\n\tprivate static isConcave (index: number, vertexCount: number, vertices: NumberArrayLike, indices: NumberArrayLike): boolean {\n\t\tlet previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\n\t\tlet current = indices[index] << 1;\n\t\tlet next = indices[(index + 1) % vertexCount] << 1;\n\t\treturn !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next],\n\t\t\tvertices[next + 1]);\n\t}\n\n\tprivate static positiveArea (p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): boolean {\n\t\treturn p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\n\t}\n\n\tprivate static winding (p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): number {\n\t\tlet px = p2x - p1x, py = p2y - p1y;\n\t\treturn p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { ClippingAttachment } from \"./attachments/ClippingAttachment.js\";\nimport { Slot } from \"./Slot.js\";\nimport { Triangulator } from \"./Triangulator.js\";\nimport { Utils, Color, NumberArrayLike } from \"./Utils.js\";\n\nexport class SkeletonClipping {\n\tprivate triangulator = new Triangulator();\n\tprivate clippingPolygon = new Array<number>();\n\tprivate clipOutput = new Array<number>();\n\tclippedVertices = new Array<number>();\n\tclippedUVs = new Array<number>();\n\tclippedTriangles = new Array<number>();\n\tprivate scratch = new Array<number>();\n\n\tprivate clipAttachment: ClippingAttachment | null = null;\n\tprivate clippingPolygons: Array<Array<number>> | null = null;\n\n\tclipStart (slot: Slot, clip: ClippingAttachment): number {\n\t\tif (this.clipAttachment) return 0;\n\t\tthis.clipAttachment = clip;\n\n\t\tlet n = clip.worldVerticesLength;\n\t\tlet vertices = Utils.setArraySize(this.clippingPolygon, n);\n\t\tclip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n\t\tlet clippingPolygon = this.clippingPolygon;\n\t\tSkeletonClipping.makeClockwise(clippingPolygon);\n\t\tlet clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\n\t\tfor (let i = 0, n = clippingPolygons.length; i < n; i++) {\n\t\t\tlet polygon = clippingPolygons[i];\n\t\t\tSkeletonClipping.makeClockwise(polygon);\n\t\t\tpolygon.push(polygon[0]);\n\t\t\tpolygon.push(polygon[1]);\n\t\t}\n\n\t\treturn clippingPolygons.length;\n\t}\n\n\tclipEndWithSlot (slot: Slot) {\n\t\tif (this.clipAttachment && this.clipAttachment.endSlot == slot.data) this.clipEnd();\n\t}\n\n\tclipEnd () {\n\t\tif (!this.clipAttachment) return;\n\t\tthis.clipAttachment = null;\n\t\tthis.clippingPolygons = null;\n\t\tthis.clippedVertices.length = 0;\n\t\tthis.clippedTriangles.length = 0;\n\t\tthis.clippingPolygon.length = 0;\n\t}\n\n\tisClipping (): boolean {\n\t\treturn this.clipAttachment != null;\n\t}\n\n\t/**\n\t* @deprecated Use clipTriangles without verticesLength parameter. Mark for removal in 4.3.\n\t*/\n\tclipTriangles (vertices: NumberArrayLike, verticesLength: number, triangles: NumberArrayLike, trianglesLength: number): void;\n\n\t/**\n\t * @deprecated Use clipTriangles without verticesLength parameter. Mark for removal in 4.3.\n\t */\n\tclipTriangles (vertices: NumberArrayLike, verticesLength: number, triangles: NumberArrayLike, trianglesLength: number, uvs: NumberArrayLike, light: Color, dark: Color, twoColor: boolean): void;\n\n\tclipTriangles (vertices: NumberArrayLike, triangles: NumberArrayLike, trianglesLength: number): void;\n\tclipTriangles (vertices: NumberArrayLike, triangles: NumberArrayLike, trianglesLength: number, uvs: NumberArrayLike, light: Color, dark: Color, twoColor: boolean): void;\n\tclipTriangles (\n\t\tvertices: NumberArrayLike,\n\t\tverticesLengthOrTriangles: number | NumberArrayLike,\n\t\ttrianglesOrTrianglesLength: NumberArrayLike | number,\n\t\ttrianglesLengthOrUvs?: number | NumberArrayLike,\n\t\tuvsOrLight?: NumberArrayLike | Color,\n\t\tlightOrDark?: Color,\n\t\tdarkOrTwoColor?: Color | boolean,\n\t\ttwoColorParam?: boolean\n\t): void {\n\t\t// Determine which overload is being used\n\t\tlet triangles: NumberArrayLike;\n\t\tlet trianglesLength: number;\n\t\tlet uvs: NumberArrayLike | undefined;\n\t\tlet light: Color | undefined;\n\t\tlet dark: Color | undefined;\n\t\tlet twoColor: boolean | undefined;\n\n\t\tif (typeof verticesLengthOrTriangles === 'number') {\n\t\t\ttriangles = trianglesOrTrianglesLength as NumberArrayLike;\n\t\t\ttrianglesLength = trianglesLengthOrUvs as number;\n\t\t\tuvs = uvsOrLight as NumberArrayLike;\n\t\t\tlight = lightOrDark as Color | undefined;\n\t\t\tdark = darkOrTwoColor as Color | undefined;\n\t\t\ttwoColor = twoColorParam;\n\t\t} else {\n\t\t\ttriangles = verticesLengthOrTriangles;\n\t\t\ttrianglesLength = trianglesOrTrianglesLength as number;\n\t\t\tuvs = trianglesLengthOrUvs as NumberArrayLike;\n\t\t\tlight = uvsOrLight as Color | undefined;\n\t\t\tdark = lightOrDark as Color | undefined;\n\t\t\ttwoColor = darkOrTwoColor as boolean;\n\t\t}\n\n\t\tif (uvs && light && dark && typeof twoColor === 'boolean')\n\t\t\tthis.clipTrianglesRender(vertices, triangles, trianglesLength, uvs, light, dark, twoColor);\n\t\telse\n\t\t\tthis.clipTrianglesNoRender(vertices, triangles, trianglesLength);\n\t}\n\n\tprivate clipTrianglesNoRender (vertices: NumberArrayLike, triangles: NumberArrayLike, trianglesLength: number) {\n\n\t\tlet clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\n\t\tlet clippedTriangles = this.clippedTriangles;\n\t\tlet polygons = this.clippingPolygons!;\n\t\tlet polygonsCount = polygons.length;\n\n\t\tlet index = 0;\n\t\tclippedVertices.length = 0;\n\t\tclippedTriangles.length = 0;\n\t\tfor (let i = 0; i < trianglesLength; i += 3) {\n\t\t\tlet vertexOffset = triangles[i] << 1;\n\t\t\tlet x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\n\n\t\t\tvertexOffset = triangles[i + 1] << 1;\n\t\t\tlet x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\n\n\t\t\tvertexOffset = triangles[i + 2] << 1;\n\t\t\tlet x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\n\n\t\t\tfor (let p = 0; p < polygonsCount; p++) {\n\t\t\t\tlet s = clippedVertices.length;\n\t\t\t\tif (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\n\t\t\t\t\tlet clipOutputLength = clipOutput.length;\n\t\t\t\t\tif (clipOutputLength == 0) continue;\n\n\t\t\t\t\tlet clipOutputCount = clipOutputLength >> 1;\n\t\t\t\t\tlet clipOutputItems = this.clipOutput;\n\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + clipOutputCount * 2);\n\t\t\t\t\tfor (let ii = 0; ii < clipOutputLength; ii += 2, s += 2) {\n\t\t\t\t\t\tlet x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\n\t\t\t\t\t\tclippedVerticesItems[s] = x;\n\t\t\t\t\t\tclippedVerticesItems[s + 1] = y;\n\t\t\t\t\t}\n\n\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\n\t\t\t\t\tclipOutputCount--;\n\t\t\t\t\tfor (let ii = 1; ii < clipOutputCount; ii++, s += 3) {\n\t\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + ii);\n\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + ii + 1);\n\t\t\t\t\t}\n\t\t\t\t\tindex += clipOutputCount + 1;\n\n\t\t\t\t} else {\n\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + 3 * 2);\n\t\t\t\t\tclippedVerticesItems[s] = x1;\n\t\t\t\t\tclippedVerticesItems[s + 1] = y1;\n\n\t\t\t\t\tclippedVerticesItems[s + 2] = x2;\n\t\t\t\t\tclippedVerticesItems[s + 3] = y2;\n\n\t\t\t\t\tclippedVerticesItems[s + 4] = x3;\n\t\t\t\t\tclippedVerticesItems[s + 5] = y3;\n\n\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3);\n\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + 1);\n\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + 2);\n\t\t\t\t\tindex += 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate clipTrianglesRender (vertices: NumberArrayLike, triangles: NumberArrayLike, trianglesLength: number, uvs: NumberArrayLike,\n\t\tlight: Color, dark: Color, twoColor: boolean) {\n\n\t\tlet clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\n\t\tlet clippedTriangles = this.clippedTriangles;\n\t\tlet polygons = this.clippingPolygons!;\n\t\tlet polygonsCount = polygons.length;\n\t\tlet vertexSize = twoColor ? 12 : 8;\n\n\t\tlet index = 0;\n\t\tclippedVertices.length = 0;\n\t\tclippedTriangles.length = 0;\n\t\tfor (let i = 0; i < trianglesLength; i += 3) {\n\t\t\tlet vertexOffset = triangles[i] << 1;\n\t\t\tlet x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\n\t\t\tlet u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\n\n\t\t\tvertexOffset = triangles[i + 1] << 1;\n\t\t\tlet x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\n\t\t\tlet u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\n\n\t\t\tvertexOffset = triangles[i + 2] << 1;\n\t\t\tlet x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\n\t\t\tlet u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\n\n\t\t\tfor (let p = 0; p < polygonsCount; p++) {\n\t\t\t\tlet s = clippedVertices.length;\n\t\t\t\tif (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\n\t\t\t\t\tlet clipOutputLength = clipOutput.length;\n\t\t\t\t\tif (clipOutputLength == 0) continue;\n\t\t\t\t\tlet d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\n\t\t\t\t\tlet d = 1 / (d0 * d2 + d1 * (y1 - y3));\n\n\t\t\t\t\tlet clipOutputCount = clipOutputLength >> 1;\n\t\t\t\t\tlet clipOutputItems = this.clipOutput;\n\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\n\t\t\t\t\tfor (let ii = 0; ii < clipOutputLength; ii += 2, s += vertexSize) {\n\t\t\t\t\t\tlet x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\n\t\t\t\t\t\tclippedVerticesItems[s] = x;\n\t\t\t\t\t\tclippedVerticesItems[s + 1] = y;\n\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\n\t\t\t\t\t\tlet c0 = x - x3, c1 = y - y3;\n\t\t\t\t\t\tlet a = (d0 * c0 + d1 * c1) * d;\n\t\t\t\t\t\tlet b = (d4 * c0 + d2 * c1) * d;\n\t\t\t\t\t\tlet c = 1 - a - b;\n\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\n\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\n\t\t\t\t\t\tif (twoColor) {\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\n\t\t\t\t\tclipOutputCount--;\n\t\t\t\t\tfor (let ii = 1; ii < clipOutputCount; ii++, s += 3) {\n\t\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + ii);\n\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + ii + 1);\n\t\t\t\t\t}\n\t\t\t\t\tindex += clipOutputCount + 1;\n\n\t\t\t\t} else {\n\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\n\t\t\t\t\tclippedVerticesItems[s] = x1;\n\t\t\t\t\tclippedVerticesItems[s + 1] = y1;\n\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\n\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\n\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\n\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\n\t\t\t\t\tif (!twoColor) {\n\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\n\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\n\n\t\t\t\t\t\tclippedVerticesItems[s + 8] = x2;\n\t\t\t\t\t\tclippedVerticesItems[s + 9] = y2;\n\t\t\t\t\t\tclippedVerticesItems[s + 10] = light.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 11] = light.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 12] = light.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 13] = light.a;\n\t\t\t\t\t\tclippedVerticesItems[s + 14] = u2;\n\t\t\t\t\t\tclippedVerticesItems[s + 15] = v2;\n\n\t\t\t\t\t\tclippedVerticesItems[s + 16] = x3;\n\t\t\t\t\t\tclippedVerticesItems[s + 17] = y3;\n\t\t\t\t\t\tclippedVerticesItems[s + 18] = light.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 19] = light.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 20] = light.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 21] = light.a;\n\t\t\t\t\t\tclippedVerticesItems[s + 22] = u3;\n\t\t\t\t\t\tclippedVerticesItems[s + 23] = v3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\n\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\n\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\n\n\t\t\t\t\t\tclippedVerticesItems[s + 12] = x2;\n\t\t\t\t\t\tclippedVerticesItems[s + 13] = y2;\n\t\t\t\t\t\tclippedVerticesItems[s + 14] = light.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 15] = light.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 16] = light.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 17] = light.a;\n\t\t\t\t\t\tclippedVerticesItems[s + 18] = u2;\n\t\t\t\t\t\tclippedVerticesItems[s + 19] = v2;\n\t\t\t\t\t\tclippedVerticesItems[s + 20] = dark.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 21] = dark.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 22] = dark.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 23] = dark.a;\n\n\t\t\t\t\t\tclippedVerticesItems[s + 24] = x3;\n\t\t\t\t\t\tclippedVerticesItems[s + 25] = y3;\n\t\t\t\t\t\tclippedVerticesItems[s + 26] = light.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 27] = light.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 28] = light.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 29] = light.a;\n\t\t\t\t\t\tclippedVerticesItems[s + 30] = u3;\n\t\t\t\t\t\tclippedVerticesItems[s + 31] = v3;\n\t\t\t\t\t\tclippedVerticesItems[s + 32] = dark.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 33] = dark.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 34] = dark.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 35] = dark.a;\n\t\t\t\t\t}\n\n\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3);\n\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + 1);\n\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + 2);\n\t\t\t\t\tindex += 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic clipTrianglesUnpacked (vertices: NumberArrayLike, triangles: NumberArrayLike, trianglesLength: number, uvs: NumberArrayLike) {\n\t\tlet clipOutput = this.clipOutput, clippedVertices = this.clippedVertices, clippedUVs = this.clippedUVs;\n\t\tlet clippedTriangles = this.clippedTriangles;\n\t\tlet polygons = this.clippingPolygons!;\n\t\tlet polygonsCount = polygons.length;\n\n\t\tlet index = 0;\n\t\tclippedVertices.length = 0;\n\t\tclippedUVs.length = 0;\n\t\tclippedTriangles.length = 0;\n\t\tfor (let i = 0; i < trianglesLength; i += 3) {\n\t\t\tlet vertexOffset = triangles[i] << 1;\n\t\t\tlet x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\n\t\t\tlet u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\n\n\t\t\tvertexOffset = triangles[i + 1] << 1;\n\t\t\tlet x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\n\t\t\tlet u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\n\n\t\t\tvertexOffset = triangles[i + 2] << 1;\n\t\t\tlet x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\n\t\t\tlet u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\n\n\t\t\tfor (let p = 0; p < polygonsCount; p++) {\n\t\t\t\tlet s = clippedVertices.length;\n\t\t\t\tif (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\n\t\t\t\t\tlet clipOutputLength = clipOutput.length;\n\t\t\t\t\tif (clipOutputLength == 0) continue;\n\t\t\t\t\tlet d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\n\t\t\t\t\tlet d = 1 / (d0 * d2 + d1 * (y1 - y3));\n\n\t\t\t\t\tlet clipOutputCount = clipOutputLength >> 1;\n\t\t\t\t\tlet clipOutputItems = this.clipOutput;\n\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + clipOutputCount * 2);\n\t\t\t\t\tlet clippedUVsItems = Utils.setArraySize(clippedUVs, s + clipOutputCount * 2);\n\t\t\t\t\tfor (let ii = 0; ii < clipOutputLength; ii += 2, s += 2) {\n\t\t\t\t\t\tlet x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\n\t\t\t\t\t\tclippedVerticesItems[s] = x;\n\t\t\t\t\t\tclippedVerticesItems[s + 1] = y;\n\t\t\t\t\t\tlet c0 = x - x3, c1 = y - y3;\n\t\t\t\t\t\tlet a = (d0 * c0 + d1 * c1) * d;\n\t\t\t\t\t\tlet b = (d4 * c0 + d2 * c1) * d;\n\t\t\t\t\t\tlet c = 1 - a - b;\n\t\t\t\t\t\tclippedUVsItems[s] = u1 * a + u2 * b + u3 * c;\n\t\t\t\t\t\tclippedUVsItems[s + 1] = v1 * a + v2 * b + v3 * c;\n\t\t\t\t\t}\n\n\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\n\t\t\t\t\tclipOutputCount--;\n\t\t\t\t\tfor (let ii = 1; ii < clipOutputCount; ii++, s += 3) {\n\t\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + ii);\n\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + ii + 1);\n\t\t\t\t\t}\n\t\t\t\t\tindex += clipOutputCount + 1;\n\n\t\t\t\t} else {\n\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + 3 * 2);\n\t\t\t\t\tclippedVerticesItems[s] = x1;\n\t\t\t\t\tclippedVerticesItems[s + 1] = y1;\n\t\t\t\t\tclippedVerticesItems[s + 2] = x2;\n\t\t\t\t\tclippedVerticesItems[s + 3] = y2;\n\t\t\t\t\tclippedVerticesItems[s + 4] = x3;\n\t\t\t\t\tclippedVerticesItems[s + 5] = y3;\n\n\t\t\t\t\tlet clippedUVSItems = Utils.setArraySize(clippedUVs, s + 3 * 2);\n\t\t\t\t\tclippedUVSItems[s] = u1;\n\t\t\t\t\tclippedUVSItems[s + 1] = v1;\n\t\t\t\t\tclippedUVSItems[s + 2] = u2;\n\t\t\t\t\tclippedUVSItems[s + 3] = v2;\n\t\t\t\t\tclippedUVSItems[s + 4] = u3;\n\t\t\t\t\tclippedUVSItems[s + 5] = v3;\n\n\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3);\n\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + 1);\n\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + 2);\n\t\t\t\t\tindex += 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Clips the input triangle against the convex, clockwise clipping area. If the triangle lies entirely within the clipping\n\t * area, false is returned. The clipping area must duplicate the first vertex at the end of the vertices list. */\n\tclip (x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, clippingArea: Array<number>, output: Array<number>) {\n\t\tlet originalOutput = output;\n\t\tlet clipped = false;\n\n\t\t// Avoid copy at the end.\n\t\tlet input: Array<number>;\n\t\tif (clippingArea.length % 4 >= 2) {\n\t\t\tinput = output;\n\t\t\toutput = this.scratch;\n\t\t} else\n\t\t\tinput = this.scratch;\n\n\t\tinput.length = 0;\n\t\tinput.push(x1);\n\t\tinput.push(y1);\n\t\tinput.push(x2);\n\t\tinput.push(y2);\n\t\tinput.push(x3);\n\t\tinput.push(y3);\n\t\tinput.push(x1);\n\t\tinput.push(y1);\n\t\toutput.length = 0;\n\n\t\tlet clippingVerticesLast = clippingArea.length - 4;\n\t\tlet clippingVertices = clippingArea;\n\t\tfor (let i = 0; ; i += 2) {\n\t\t\tlet edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];\n\t\t\tlet ex = edgeX - clippingVertices[i + 2], ey = edgeY - clippingVertices[i + 3];\n\n\t\t\tlet outputStart = output.length;\n\t\t\tlet inputVertices = input;\n\t\t\tfor (let ii = 0, nn = input.length - 2; ii < nn;) {\n\t\t\t\tlet inputX = inputVertices[ii], inputY = inputVertices[ii + 1];\n\t\t\t\tii += 2;\n\t\t\t\tlet inputX2 = inputVertices[ii], inputY2 = inputVertices[ii + 1];\n\t\t\t\tlet s2 = ey * (edgeX - inputX2) > ex * (edgeY - inputY2);\n\t\t\t\tlet s1 = ey * (edgeX - inputX) - ex * (edgeY - inputY);\n\t\t\t\tif (s1 > 0) {\n\t\t\t\t\tif (s2) { // v1 inside, v2 inside\n\t\t\t\t\t\toutput.push(inputX2);\n\t\t\t\t\t\toutput.push(inputY2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// v1 inside, v2 outside\n\t\t\t\t\tlet ix = inputX2 - inputX, iy = inputY2 - inputY, t = s1 / (ix * ey - iy * ex);\n\t\t\t\t\tif (t >= 0 && t <= 1) {\n\t\t\t\t\t\toutput.push(inputX + ix * t);\n\t\t\t\t\t\toutput.push(inputY + iy * t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput.push(inputX2);\n\t\t\t\t\t\toutput.push(inputY2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (s2) { // v1 outside, v2 inside\n\t\t\t\t\tlet ix = inputX2 - inputX, iy = inputY2 - inputY, t = s1 / (ix * ey - iy * ex);\n\t\t\t\t\tif (t >= 0 && t <= 1) {\n\t\t\t\t\t\toutput.push(inputX + ix * t);\n\t\t\t\t\t\toutput.push(inputY + iy * t);\n\t\t\t\t\t\toutput.push(inputX2);\n\t\t\t\t\t\toutput.push(inputY2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput.push(inputX2);\n\t\t\t\t\t\toutput.push(inputY2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclipped = true;\n\t\t\t}\n\n\t\t\tif (outputStart == output.length) { // All edges outside.\n\t\t\t\toriginalOutput.length = 0;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\toutput.push(output[0]);\n\t\t\toutput.push(output[1]);\n\n\t\t\tif (i == clippingVerticesLast) break;\n\t\t\tlet temp = output;\n\t\t\toutput = input;\n\t\t\toutput.length = 0;\n\t\t\tinput = temp;\n\t\t}\n\n\t\tif (originalOutput != output) {\n\t\t\toriginalOutput.length = 0;\n\t\t\tfor (let i = 0, n = output.length - 2; i < n; i++)\n\t\t\t\toriginalOutput[i] = output[i];\n\t\t} else\n\t\t\toriginalOutput.length = originalOutput.length - 2;\n\n\t\treturn clipped;\n\t}\n\n\tpublic static makeClockwise (polygon: NumberArrayLike) {\n\t\tlet vertices = polygon;\n\t\tlet verticeslength = polygon.length;\n\n\t\tlet area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;\n\t\tfor (let i = 0, n = verticeslength - 3; i < n; i += 2) {\n\t\t\tp1x = vertices[i];\n\t\t\tp1y = vertices[i + 1];\n\t\t\tp2x = vertices[i + 2];\n\t\t\tp2y = vertices[i + 3];\n\t\t\tarea += p1x * p2y - p2x * p1y;\n\t\t}\n\t\tif (area < 0) return;\n\n\t\tfor (let i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\n\t\t\tlet x = vertices[i], y = vertices[i + 1];\n\t\t\tlet other = lastX - i;\n\t\t\tvertices[i] = vertices[other];\n\t\t\tvertices[i + 1] = vertices[other + 1];\n\t\t\tvertices[other] = x;\n\t\t\tvertices[other + 1] = y;\n\t\t}\n\t}\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Animation, Timeline, InheritTimeline, AttachmentTimeline, RGBATimeline, RGBTimeline, AlphaTimeline, RGBA2Timeline, RGB2Timeline, RotateTimeline, TranslateTimeline, TranslateXTimeline, TranslateYTimeline, ScaleTimeline, ScaleXTimeline, ScaleYTimeline, ShearTimeline, ShearXTimeline, ShearYTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, CurveTimeline1, CurveTimeline2, CurveTimeline, PhysicsConstraintResetTimeline, PhysicsConstraintInertiaTimeline, PhysicsConstraintStrengthTimeline, PhysicsConstraintDampingTimeline, PhysicsConstraintMassTimeline, PhysicsConstraintWindTimeline, PhysicsConstraintGravityTimeline, PhysicsConstraintMixTimeline } from \"./Animation.js\";\nimport { VertexAttachment, Attachment } from \"./attachments/Attachment.js\";\nimport { AttachmentLoader } from \"./attachments/AttachmentLoader.js\";\nimport { MeshAttachment } from \"./attachments/MeshAttachment.js\";\nimport { BoneData, Inherit } from \"./BoneData.js\";\nimport { EventData } from \"./EventData.js\";\nimport { Event } from \"./Event.js\";\nimport { IkConstraintData } from \"./IkConstraintData.js\";\nimport { PathConstraintData, PositionMode, SpacingMode, RotateMode } from \"./PathConstraintData.js\";\nimport { SkeletonData } from \"./SkeletonData.js\";\nimport { Skin } from \"./Skin.js\";\nimport { SlotData, BlendMode } from \"./SlotData.js\";\nimport { TransformConstraintData } from \"./TransformConstraintData.js\";\nimport { Utils, Color, NumberArrayLike } from \"./Utils.js\";\nimport { Sequence, SequenceMode } from \"./attachments/Sequence.js\";\nimport { SequenceTimeline } from \"./Animation.js\";\nimport { HasTextureRegion } from \"./attachments/HasTextureRegion.js\";\nimport { PhysicsConstraintData } from \"./PhysicsConstraintData.js\";\n\n/** Loads skeleton data in the Spine JSON format.\n *\n * See [Spine JSON format](http://esotericsoftware.com/spine-json-format) and\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\n * Runtimes Guide. */\nexport class SkeletonJson {\n\tattachmentLoader: AttachmentLoader;\n\n\t/** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n\t * runtime than were used in Spine.\n\t *\n\t * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n\tscale = 1;\n\tprivate linkedMeshes = new Array<LinkedMesh>();\n\n\tconstructor (attachmentLoader: AttachmentLoader) {\n\t\tthis.attachmentLoader = attachmentLoader;\n\t}\n\n\treadSkeletonData (json: string | any): SkeletonData {\n\t\tlet scale = this.scale;\n\t\tlet skeletonData = new SkeletonData();\n\t\tlet root = typeof (json) === \"string\" ? JSON.parse(json) : json;\n\n\t\t// Skeleton\n\t\tlet skeletonMap = root.skeleton;\n\t\tif (skeletonMap) {\n\t\t\tskeletonData.hash = skeletonMap.hash;\n\t\t\tskeletonData.version = skeletonMap.spine;\n\t\t\tskeletonData.x = skeletonMap.x;\n\t\t\tskeletonData.y = skeletonMap.y;\n\t\t\tskeletonData.width = skeletonMap.width;\n\t\t\tskeletonData.height = skeletonMap.height;\n\t\t\tskeletonData.referenceScale = getValue(skeletonMap, \"referenceScale\", 100) * scale;\n\t\t\tskeletonData.fps = skeletonMap.fps;\n\t\t\tskeletonData.imagesPath = skeletonMap.images ?? null;\n\t\t\tskeletonData.audioPath = skeletonMap.audio ?? null;\n\t\t}\n\n\t\t// Bones\n\t\tif (root.bones) {\n\t\t\tfor (let i = 0; i < root.bones.length; i++) {\n\t\t\t\tlet boneMap = root.bones[i];\n\n\t\t\t\tlet parent: BoneData | null = null;\n\t\t\t\tlet parentName: string = getValue(boneMap, \"parent\", null);\n\t\t\t\tif (parentName) parent = skeletonData.findBone(parentName);\n\t\t\t\tlet data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n\t\t\t\tdata.length = getValue(boneMap, \"length\", 0) * scale;\n\t\t\t\tdata.x = getValue(boneMap, \"x\", 0) * scale;\n\t\t\t\tdata.y = getValue(boneMap, \"y\", 0) * scale;\n\t\t\t\tdata.rotation = getValue(boneMap, \"rotation\", 0);\n\t\t\t\tdata.scaleX = getValue(boneMap, \"scaleX\", 1);\n\t\t\t\tdata.scaleY = getValue(boneMap, \"scaleY\", 1);\n\t\t\t\tdata.shearX = getValue(boneMap, \"shearX\", 0);\n\t\t\t\tdata.shearY = getValue(boneMap, \"shearY\", 0);\n\t\t\t\tdata.inherit = Utils.enumValue(Inherit, getValue(boneMap, \"inherit\", \"Normal\"));\n\t\t\t\tdata.skinRequired = getValue(boneMap, \"skin\", false);\n\n\t\t\t\tlet color = getValue(boneMap, \"color\", null);\n\t\t\t\tif (color) data.color.setFromString(color);\n\n\t\t\t\tskeletonData.bones.push(data);\n\t\t\t}\n\t\t}\n\n\t\t// Slots.\n\t\tif (root.slots) {\n\t\t\tfor (let i = 0; i < root.slots.length; i++) {\n\t\t\t\tlet slotMap = root.slots[i];\n\t\t\t\tlet slotName = slotMap.name;\n\n\t\t\t\tlet boneData = skeletonData.findBone(slotMap.bone);\n\t\t\t\tif (!boneData) throw new Error(`Couldn't find bone ${slotMap.bone} for slot ${slotName}`);\n\t\t\t\tlet data = new SlotData(skeletonData.slots.length, slotName, boneData);\n\n\t\t\t\tlet color: string = getValue(slotMap, \"color\", null);\n\t\t\t\tif (color) data.color.setFromString(color);\n\n\t\t\t\tlet dark: string = getValue(slotMap, \"dark\", null);\n\t\t\t\tif (dark) data.darkColor = Color.fromString(dark);\n\n\t\t\t\tdata.attachmentName = getValue(slotMap, \"attachment\", null);\n\t\t\t\tdata.blendMode = Utils.enumValue(BlendMode, getValue(slotMap, \"blend\", \"normal\"));\n\t\t\t\tdata.visible = getValue(slotMap, \"visible\", true);\n\t\t\t\tskeletonData.slots.push(data);\n\t\t\t}\n\t\t}\n\n\t\t// IK constraints\n\t\tif (root.ik) {\n\t\t\tfor (let i = 0; i < root.ik.length; i++) {\n\t\t\t\tlet constraintMap = root.ik[i];\n\t\t\t\tlet data = new IkConstraintData(constraintMap.name);\n\t\t\t\tdata.order = getValue(constraintMap, \"order\", 0);\n\t\t\t\tdata.skinRequired = getValue(constraintMap, \"skin\", false);\n\n\t\t\t\tfor (let ii = 0; ii < constraintMap.bones.length; ii++) {\n\t\t\t\t\tlet bone = skeletonData.findBone(constraintMap.bones[ii]);\n\t\t\t\t\tif (!bone) throw new Error(`Couldn't find bone ${constraintMap.bones[ii]} for IK constraint ${constraintMap.name}.`);\n\t\t\t\t\tdata.bones.push(bone);\n\t\t\t\t}\n\n\t\t\t\tlet target = skeletonData.findBone(constraintMap.target);;\n\t\t\t\tif (!target) throw new Error(`Couldn't find target bone ${constraintMap.target} for IK constraint ${constraintMap.name}.`);\n\t\t\t\tdata.target = target;\n\n\t\t\t\tdata.mix = getValue(constraintMap, \"mix\", 1);\n\t\t\t\tdata.softness = getValue(constraintMap, \"softness\", 0) * scale;\n\t\t\t\tdata.bendDirection = getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n\t\t\t\tdata.compress = getValue(constraintMap, \"compress\", false);\n\t\t\t\tdata.stretch = getValue(constraintMap, \"stretch\", false);\n\t\t\t\tdata.uniform = getValue(constraintMap, \"uniform\", false);\n\n\t\t\t\tskeletonData.ikConstraints.push(data);\n\t\t\t}\n\t\t}\n\n\t\t// Transform constraints.\n\t\tif (root.transform) {\n\t\t\tfor (let i = 0; i < root.transform.length; i++) {\n\t\t\t\tlet constraintMap = root.transform[i];\n\t\t\t\tlet data = new TransformConstraintData(constraintMap.name);\n\t\t\t\tdata.order = getValue(constraintMap, \"order\", 0);\n\t\t\t\tdata.skinRequired = getValue(constraintMap, \"skin\", false);\n\n\t\t\t\tfor (let ii = 0; ii < constraintMap.bones.length; ii++) {\n\t\t\t\t\tlet boneName = constraintMap.bones[ii];\n\t\t\t\t\tlet bone = skeletonData.findBone(boneName);\n\t\t\t\t\tif (!bone) throw new Error(`Couldn't find bone ${boneName} for transform constraint ${constraintMap.name}.`);\n\t\t\t\t\tdata.bones.push(bone);\n\t\t\t\t}\n\n\t\t\t\tlet targetName: string = constraintMap.target;\n\t\t\t\tlet target = skeletonData.findBone(targetName);\n\t\t\t\tif (!target) throw new Error(`Couldn't find target bone ${targetName} for transform constraint ${constraintMap.name}.`);\n\t\t\t\tdata.target = target;\n\n\t\t\t\tdata.local = getValue(constraintMap, \"local\", false);\n\t\t\t\tdata.relative = getValue(constraintMap, \"relative\", false);\n\t\t\t\tdata.offsetRotation = getValue(constraintMap, \"rotation\", 0);\n\t\t\t\tdata.offsetX = getValue(constraintMap, \"x\", 0) * scale;\n\t\t\t\tdata.offsetY = getValue(constraintMap, \"y\", 0) * scale;\n\t\t\t\tdata.offsetScaleX = getValue(constraintMap, \"scaleX\", 0);\n\t\t\t\tdata.offsetScaleY = getValue(constraintMap, \"scaleY\", 0);\n\t\t\t\tdata.offsetShearY = getValue(constraintMap, \"shearY\", 0);\n\n\t\t\t\tdata.mixRotate = getValue(constraintMap, \"mixRotate\", 1);\n\t\t\t\tdata.mixX = getValue(constraintMap, \"mixX\", 1);\n\t\t\t\tdata.mixY = getValue(constraintMap, \"mixY\", data.mixX);\n\t\t\t\tdata.mixScaleX = getValue(constraintMap, \"mixScaleX\", 1);\n\t\t\t\tdata.mixScaleY = getValue(constraintMap, \"mixScaleY\", data.mixScaleX);\n\t\t\t\tdata.mixShearY = getValue(constraintMap, \"mixShearY\", 1);\n\n\t\t\t\tskeletonData.transformConstraints.push(data);\n\t\t\t}\n\t\t}\n\n\t\t// Path constraints.\n\t\tif (root.path) {\n\t\t\tfor (let i = 0; i < root.path.length; i++) {\n\t\t\t\tlet constraintMap = root.path[i];\n\t\t\t\tlet data = new PathConstraintData(constraintMap.name);\n\t\t\t\tdata.order = getValue(constraintMap, \"order\", 0);\n\t\t\t\tdata.skinRequired = getValue(constraintMap, \"skin\", false);\n\n\t\t\t\tfor (let ii = 0; ii < constraintMap.bones.length; ii++) {\n\t\t\t\t\tlet boneName = constraintMap.bones[ii];\n\t\t\t\t\tlet bone = skeletonData.findBone(boneName);\n\t\t\t\t\tif (!bone) throw new Error(`Couldn't find bone ${boneName} for path constraint ${constraintMap.name}.`);\n\t\t\t\t\tdata.bones.push(bone);\n\t\t\t\t}\n\n\t\t\t\tlet targetName: string = constraintMap.target;\n\t\t\t\tlet target = skeletonData.findSlot(targetName);\n\t\t\t\tif (!target) throw new Error(`Couldn't find target slot ${targetName} for path constraint ${constraintMap.name}.`);\n\t\t\t\tdata.target = target;\n\n\t\t\t\tdata.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, \"positionMode\", \"Percent\"));\n\t\t\t\tdata.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, \"spacingMode\", \"Length\"));\n\t\t\t\tdata.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, \"rotateMode\", \"Tangent\"));\n\t\t\t\tdata.offsetRotation = getValue(constraintMap, \"rotation\", 0);\n\t\t\t\tdata.position = getValue(constraintMap, \"position\", 0);\n\t\t\t\tif (data.positionMode == PositionMode.Fixed) data.position *= scale;\n\t\t\t\tdata.spacing = getValue(constraintMap, \"spacing\", 0);\n\t\t\t\tif (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n\t\t\t\tdata.mixRotate = getValue(constraintMap, \"mixRotate\", 1);\n\t\t\t\tdata.mixX = getValue(constraintMap, \"mixX\", 1);\n\t\t\t\tdata.mixY = getValue(constraintMap, \"mixY\", data.mixX);\n\n\t\t\t\tskeletonData.pathConstraints.push(data);\n\t\t\t}\n\t\t}\n\n\t\t// Physics constraints.\n\t\tif (root.physics) {\n\t\t\tfor (let i = 0; i < root.physics.length; i++) {\n\t\t\t\tconst constraintMap = root.physics[i];\n\t\t\t\tconst data = new PhysicsConstraintData(constraintMap.name);\n\t\t\t\tdata.order = getValue(constraintMap, \"order\", 0);\n\t\t\t\tdata.skinRequired = getValue(constraintMap, \"skin\", false);\n\n\t\t\t\tconst boneName = constraintMap.bone;\n\t\t\t\tconst bone = skeletonData.findBone(boneName);\n\t\t\t\tif (bone == null) throw new Error(\"Physics bone not found: \" + boneName);\n\t\t\t\tdata.bone = bone;\n\n\t\t\t\tdata.x = getValue(constraintMap, \"x\", 0);\n\t\t\t\tdata.y = getValue(constraintMap, \"y\", 0);\n\t\t\t\tdata.rotate = getValue(constraintMap, \"rotate\", 0);\n\t\t\t\tdata.scaleX = getValue(constraintMap, \"scaleX\", 0);\n\t\t\t\tdata.shearX = getValue(constraintMap, \"shearX\", 0);\n\t\t\t\tdata.limit = getValue(constraintMap, \"limit\", 5000) * scale;\n\t\t\t\tdata.step = 1 / getValue(constraintMap, \"fps\", 60);\n\t\t\t\tdata.inertia = getValue(constraintMap, \"inertia\", 1);\n\t\t\t\tdata.strength = getValue(constraintMap, \"strength\", 100);\n\t\t\t\tdata.damping = getValue(constraintMap, \"damping\", 1);\n\t\t\t\tdata.massInverse = 1 / getValue(constraintMap, \"mass\", 1);\n\t\t\t\tdata.wind = getValue(constraintMap, \"wind\", 0);\n\t\t\t\tdata.gravity = getValue(constraintMap, \"gravity\", 0);\n\t\t\t\tdata.mix = getValue(constraintMap, \"mix\", 1);\n\t\t\t\tdata.inertiaGlobal = getValue(constraintMap, \"inertiaGlobal\", false);\n\t\t\t\tdata.strengthGlobal = getValue(constraintMap, \"strengthGlobal\", false);\n\t\t\t\tdata.dampingGlobal = getValue(constraintMap, \"dampingGlobal\", false);\n\t\t\t\tdata.massGlobal = getValue(constraintMap, \"massGlobal\", false);\n\t\t\t\tdata.windGlobal = getValue(constraintMap, \"windGlobal\", false);\n\t\t\t\tdata.gravityGlobal = getValue(constraintMap, \"gravityGlobal\", false);\n\t\t\t\tdata.mixGlobal = getValue(constraintMap, \"mixGlobal\", false);\n\n\t\t\t\tskeletonData.physicsConstraints.push(data);\n\t\t\t}\n\t\t}\n\n\t\t// Skins.\n\t\tif (root.skins) {\n\t\t\tfor (let i = 0; i < root.skins.length; i++) {\n\t\t\t\tlet skinMap = root.skins[i]\n\t\t\t\tlet skin = new Skin(skinMap.name);\n\n\t\t\t\tif (skinMap.bones) {\n\t\t\t\t\tfor (let ii = 0; ii < skinMap.bones.length; ii++) {\n\t\t\t\t\t\tlet boneName = skinMap.bones[ii];\n\t\t\t\t\t\tlet bone = skeletonData.findBone(boneName);\n\t\t\t\t\t\tif (!bone) throw new Error(`Couldn't find bone ${boneName} for skin ${skinMap.name}.`);\n\t\t\t\t\t\tskin.bones.push(bone);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (skinMap.ik) {\n\t\t\t\t\tfor (let ii = 0; ii < skinMap.ik.length; ii++) {\n\t\t\t\t\t\tlet constraintName = skinMap.ik[ii];\n\t\t\t\t\t\tlet constraint = skeletonData.findIkConstraint(constraintName);\n\t\t\t\t\t\tif (!constraint) throw new Error(`Couldn't find IK constraint ${constraintName} for skin ${skinMap.name}.`);\n\t\t\t\t\t\tskin.constraints.push(constraint);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (skinMap.transform) {\n\t\t\t\t\tfor (let ii = 0; ii < skinMap.transform.length; ii++) {\n\t\t\t\t\t\tlet constraintName = skinMap.transform[ii];\n\t\t\t\t\t\tlet constraint = skeletonData.findTransformConstraint(constraintName);\n\t\t\t\t\t\tif (!constraint) throw new Error(`Couldn't find transform constraint ${constraintName} for skin ${skinMap.name}.`);\n\t\t\t\t\t\tskin.constraints.push(constraint);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (skinMap.path) {\n\t\t\t\t\tfor (let ii = 0; ii < skinMap.path.length; ii++) {\n\t\t\t\t\t\tlet constraintName = skinMap.path[ii];\n\t\t\t\t\t\tlet constraint = skeletonData.findPathConstraint(constraintName);\n\t\t\t\t\t\tif (!constraint) throw new Error(`Couldn't find path constraint ${constraintName} for skin ${skinMap.name}.`);\n\t\t\t\t\t\tskin.constraints.push(constraint);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (skinMap.physics) {\n\t\t\t\t\tfor (let ii = 0; ii < skinMap.physics.length; ii++) {\n\t\t\t\t\t\tlet constraintName = skinMap.physics[ii];\n\t\t\t\t\t\tlet constraint = skeletonData.findPhysicsConstraint(constraintName);\n\t\t\t\t\t\tif (!constraint) throw new Error(`Couldn't find physics constraint ${constraintName} for skin ${skinMap.name}.`);\n\t\t\t\t\t\tskin.constraints.push(constraint);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (let slotName in skinMap.attachments) {\n\t\t\t\t\tlet slot = skeletonData.findSlot(slotName);\n\t\t\t\t\tif (!slot) throw new Error(`Couldn't find slot ${slotName} for skin ${skinMap.name}.`);\n\t\t\t\t\tlet slotMap = skinMap.attachments[slotName];\n\t\t\t\t\tfor (let entryName in slotMap) {\n\t\t\t\t\t\tlet attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n\t\t\t\t\t\tif (attachment) skin.setAttachment(slot.index, entryName, attachment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tskeletonData.skins.push(skin);\n\t\t\t\tif (skin.name == \"default\") skeletonData.defaultSkin = skin;\n\t\t\t}\n\t\t}\n\n\t\t// Linked meshes.\n\t\tfor (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n\t\t\tlet linkedMesh = this.linkedMeshes[i];\n\t\t\tlet skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n\t\t\tif (!skin) throw new Error(`Skin not found: ${linkedMesh.skin}`);\n\t\t\tlet parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\t\t\tif (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n\t\t\tlinkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\n\t\t\tlinkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\n\t\t\tif (linkedMesh.mesh.region != null) linkedMesh.mesh.updateRegion();\n\t\t}\n\t\tthis.linkedMeshes.length = 0;\n\n\t\t// Events.\n\t\tif (root.events) {\n\t\t\tfor (let eventName in root.events) {\n\t\t\t\tlet eventMap = root.events[eventName];\n\t\t\t\tlet data = new EventData(eventName);\n\t\t\t\tdata.intValue = getValue(eventMap, \"int\", 0);\n\t\t\t\tdata.floatValue = getValue(eventMap, \"float\", 0);\n\t\t\t\tdata.stringValue = getValue(eventMap, \"string\", \"\");\n\t\t\t\tdata.audioPath = getValue(eventMap, \"audio\", null);\n\t\t\t\tif (data.audioPath) {\n\t\t\t\t\tdata.volume = getValue(eventMap, \"volume\", 1);\n\t\t\t\t\tdata.balance = getValue(eventMap, \"balance\", 0);\n\t\t\t\t}\n\t\t\t\tskeletonData.events.push(data);\n\t\t\t}\n\t\t}\n\n\t\t// Animations.\n\t\tif (root.animations) {\n\t\t\tfor (let animationName in root.animations) {\n\t\t\t\tlet animationMap = root.animations[animationName];\n\t\t\t\tthis.readAnimation(animationMap, animationName, skeletonData);\n\t\t\t}\n\t\t}\n\n\t\treturn skeletonData;\n\t}\n\n\treadAttachment (map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment | null {\n\t\tlet scale = this.scale;\n\t\tname = getValue(map, \"name\", name);\n\n\t\tswitch (getValue(map, \"type\", \"region\")) {\n\t\t\tcase \"region\": {\n\t\t\t\tlet path = getValue(map, \"path\", name);\n\t\t\t\tlet sequence = this.readSequence(getValue(map, \"sequence\", null));\n\t\t\t\tlet region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\n\t\t\t\tif (!region) return null;\n\t\t\t\tregion.path = path;\n\t\t\t\tregion.x = getValue(map, \"x\", 0) * scale;\n\t\t\t\tregion.y = getValue(map, \"y\", 0) * scale;\n\t\t\t\tregion.scaleX = getValue(map, \"scaleX\", 1);\n\t\t\t\tregion.scaleY = getValue(map, \"scaleY\", 1);\n\t\t\t\tregion.rotation = getValue(map, \"rotation\", 0);\n\t\t\t\tregion.width = map.width * scale;\n\t\t\t\tregion.height = map.height * scale;\n\t\t\t\tregion.sequence = sequence;\n\n\t\t\t\tlet color: string = getValue(map, \"color\", null);\n\t\t\t\tif (color) region.color.setFromString(color);\n\n\t\t\t\tif (region.region != null) region.updateRegion();\n\t\t\t\treturn region;\n\t\t\t}\n\t\t\tcase \"boundingbox\": {\n\t\t\t\tlet box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\t\t\t\tif (!box) return null;\n\t\t\t\tthis.readVertices(map, box, map.vertexCount << 1);\n\t\t\t\tlet color: string = getValue(map, \"color\", null);\n\t\t\t\tif (color) box.color.setFromString(color);\n\t\t\t\treturn box;\n\t\t\t}\n\t\t\tcase \"mesh\":\n\t\t\tcase \"linkedmesh\": {\n\t\t\t\tlet path = getValue(map, \"path\", name);\n\t\t\t\tlet sequence = this.readSequence(getValue(map, \"sequence\", null));\n\t\t\t\tlet mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n\t\t\t\tif (!mesh) return null;\n\t\t\t\tmesh.path = path;\n\n\t\t\t\tlet color = getValue(map, \"color\", null);\n\t\t\t\tif (color) mesh.color.setFromString(color);\n\n\t\t\t\tmesh.width = getValue(map, \"width\", 0) * scale;\n\t\t\t\tmesh.height = getValue(map, \"height\", 0) * scale;\n\t\t\t\tmesh.sequence = sequence;\n\n\t\t\t\tlet parent: string = getValue(map, \"parent\", null);\n\t\t\t\tif (parent) {\n\t\t\t\t\tthis.linkedMeshes.push(new LinkedMesh(mesh, <string>getValue(map, \"skin\", null), slotIndex, parent, getValue(map, \"timelines\", true)));\n\t\t\t\t\treturn mesh;\n\t\t\t\t}\n\n\t\t\t\tlet uvs: Array<number> = map.uvs;\n\t\t\t\tthis.readVertices(map, mesh, uvs.length);\n\t\t\t\tmesh.triangles = map.triangles;\n\t\t\t\tmesh.regionUVs = uvs;\n\t\t\t\tif (mesh.region != null) mesh.updateRegion();\n\n\t\t\t\tmesh.edges = getValue(map, \"edges\", null);\n\t\t\t\tmesh.hullLength = getValue(map, \"hull\", 0) * 2;\n\t\t\t\treturn mesh;\n\t\t\t}\n\t\t\tcase \"path\": {\n\t\t\t\tlet path = this.attachmentLoader.newPathAttachment(skin, name);\n\t\t\t\tif (!path) return null;\n\t\t\t\tpath.closed = getValue(map, \"closed\", false);\n\t\t\t\tpath.constantSpeed = getValue(map, \"constantSpeed\", true);\n\n\t\t\t\tlet vertexCount = map.vertexCount;\n\t\t\t\tthis.readVertices(map, path, vertexCount << 1);\n\n\t\t\t\tlet lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n\t\t\t\tfor (let i = 0; i < map.lengths.length; i++)\n\t\t\t\t\tlengths[i] = map.lengths[i] * scale;\n\t\t\t\tpath.lengths = lengths;\n\n\t\t\t\tlet color: string = getValue(map, \"color\", null);\n\t\t\t\tif (color) path.color.setFromString(color);\n\t\t\t\treturn path;\n\t\t\t}\n\t\t\tcase \"point\": {\n\t\t\t\tlet point = this.attachmentLoader.newPointAttachment(skin, name);\n\t\t\t\tif (!point) return null;\n\t\t\t\tpoint.x = getValue(map, \"x\", 0) * scale;\n\t\t\t\tpoint.y = getValue(map, \"y\", 0) * scale;\n\t\t\t\tpoint.rotation = getValue(map, \"rotation\", 0);\n\n\t\t\t\tlet color = getValue(map, \"color\", null);\n\t\t\t\tif (color) point.color.setFromString(color);\n\t\t\t\treturn point;\n\t\t\t}\n\t\t\tcase \"clipping\": {\n\t\t\t\tlet clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\t\t\t\tif (!clip) return null;\n\n\t\t\t\tlet end = getValue(map, \"end\", null);\n\t\t\t\tif (end) clip.endSlot = skeletonData.findSlot(end);\n\n\t\t\t\tlet vertexCount = map.vertexCount;\n\t\t\t\tthis.readVertices(map, clip, vertexCount << 1);\n\n\t\t\t\tlet color: string = getValue(map, \"color\", null);\n\t\t\t\tif (color) clip.color.setFromString(color);\n\t\t\t\treturn clip;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\treadSequence (map: any) {\n\t\tif (map == null) return null;\n\t\tlet sequence = new Sequence(getValue(map, \"count\", 0));\n\t\tsequence.start = getValue(map, \"start\", 1);\n\t\tsequence.digits = getValue(map, \"digits\", 0);\n\t\tsequence.setupIndex = getValue(map, \"setup\", 0);\n\t\treturn sequence;\n\t}\n\n\treadVertices (map: any, attachment: VertexAttachment, verticesLength: number) {\n\t\tlet scale = this.scale;\n\t\tattachment.worldVerticesLength = verticesLength;\n\t\tlet vertices: Array<number> = map.vertices;\n\t\tif (verticesLength == vertices.length) {\n\t\t\tlet scaledVertices = Utils.toFloatArray(vertices);\n\t\t\tif (scale != 1) {\n\t\t\t\tfor (let i = 0, n = vertices.length; i < n; i++)\n\t\t\t\t\tscaledVertices[i] *= scale;\n\t\t\t}\n\t\t\tattachment.vertices = scaledVertices;\n\t\t\treturn;\n\t\t}\n\t\tlet weights = new Array<number>();\n\t\tlet bones = new Array<number>();\n\t\tfor (let i = 0, n = vertices.length; i < n;) {\n\t\t\tlet boneCount = vertices[i++];\n\t\t\tbones.push(boneCount);\n\t\t\tfor (let nn = i + boneCount * 4; i < nn; i += 4) {\n\t\t\t\tbones.push(vertices[i]);\n\t\t\t\tweights.push(vertices[i + 1] * scale);\n\t\t\t\tweights.push(vertices[i + 2] * scale);\n\t\t\t\tweights.push(vertices[i + 3]);\n\t\t\t}\n\t\t}\n\t\tattachment.bones = bones;\n\t\tattachment.vertices = Utils.toFloatArray(weights);\n\t}\n\n\treadAnimation (map: any, name: string, skeletonData: SkeletonData) {\n\t\tlet scale = this.scale;\n\t\tlet timelines = new Array<Timeline>();\n\n\t\t// Slot timelines.\n\t\tif (map.slots) {\n\t\t\tfor (let slotName in map.slots) {\n\t\t\t\tlet slotMap = map.slots[slotName];\n\t\t\t\tlet slot = skeletonData.findSlot(slotName);\n\t\t\t\tif (!slot) throw new Error(\"Slot not found: \" + slotName);\n\t\t\t\tlet slotIndex = slot.index;\n\t\t\t\tfor (let timelineName in slotMap) {\n\t\t\t\t\tlet timelineMap = slotMap[timelineName];\n\t\t\t\t\tif (!timelineMap) continue;\n\t\t\t\t\tlet frames = timelineMap.length;\n\t\t\t\t\tif (timelineName == \"attachment\") {\n\t\t\t\t\t\tlet timeline = new AttachmentTimeline(frames, slotIndex);\n\t\t\t\t\t\tfor (let frame = 0; frame < frames; frame++) {\n\t\t\t\t\t\t\tlet keyMap = timelineMap[frame];\n\t\t\t\t\t\t\ttimeline.setFrame(frame, getValue(keyMap, \"time\", 0), getValue(keyMap, \"name\", null));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimelines.push(timeline);\n\n\t\t\t\t\t} else if (timelineName == \"rgba\") {\n\t\t\t\t\t\tlet timeline = new RGBATimeline(frames, frames << 2, slotIndex);\n\t\t\t\t\t\tlet keyMap = timelineMap[0];\n\t\t\t\t\t\tlet time = getValue(keyMap, \"time\", 0);\n\t\t\t\t\t\tlet color = Color.fromString(keyMap.color);\n\n\t\t\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\t\t\ttimeline.setFrame(frame, time, color.r, color.g, color.b, color.a);\n\t\t\t\t\t\t\tlet nextMap = timelineMap[frame + 1];\n\t\t\t\t\t\t\tif (!nextMap) {\n\t\t\t\t\t\t\t\ttimeline.shrink(bezier);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet time2 = getValue(nextMap, \"time\", 0);\n\t\t\t\t\t\t\tlet newColor = Color.fromString(nextMap.color);\n\t\t\t\t\t\t\tlet curve = keyMap.curve;\n\t\t\t\t\t\t\tif (curve) {\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttime = time2;\n\t\t\t\t\t\t\tcolor = newColor;\n\t\t\t\t\t\t\tkeyMap = nextMap;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttimelines.push(timeline);\n\n\t\t\t\t\t} else if (timelineName == \"rgb\") {\n\t\t\t\t\t\tlet timeline = new RGBTimeline(frames, frames * 3, slotIndex);\n\t\t\t\t\t\tlet keyMap = timelineMap[0];\n\t\t\t\t\t\tlet time = getValue(keyMap, \"time\", 0);\n\t\t\t\t\t\tlet color = Color.fromString(keyMap.color);\n\n\t\t\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\t\t\ttimeline.setFrame(frame, time, color.r, color.g, color.b);\n\t\t\t\t\t\t\tlet nextMap = timelineMap[frame + 1];\n\t\t\t\t\t\t\tif (!nextMap) {\n\t\t\t\t\t\t\t\ttimeline.shrink(bezier);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet time2 = getValue(nextMap, \"time\", 0);\n\t\t\t\t\t\t\tlet newColor = Color.fromString(nextMap.color);\n\t\t\t\t\t\t\tlet curve = keyMap.curve;\n\t\t\t\t\t\t\tif (curve) {\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttime = time2;\n\t\t\t\t\t\t\tcolor = newColor;\n\t\t\t\t\t\t\tkeyMap = nextMap;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttimelines.push(timeline);\n\n\t\t\t\t\t} else if (timelineName == \"alpha\") {\n\t\t\t\t\t\ttimelines.push(readTimeline1(timelineMap, new AlphaTimeline(frames, frames, slotIndex), 0, 1));\n\t\t\t\t\t} else if (timelineName == \"rgba2\") {\n\t\t\t\t\t\tlet timeline = new RGBA2Timeline(frames, frames * 7, slotIndex);\n\n\t\t\t\t\t\tlet keyMap = timelineMap[0];\n\t\t\t\t\t\tlet time = getValue(keyMap, \"time\", 0);\n\t\t\t\t\t\tlet color = Color.fromString(keyMap.light);\n\t\t\t\t\t\tlet color2 = Color.fromString(keyMap.dark);\n\n\t\t\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\t\t\ttimeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);\n\t\t\t\t\t\t\tlet nextMap = timelineMap[frame + 1];\n\t\t\t\t\t\t\tif (!nextMap) {\n\t\t\t\t\t\t\t\ttimeline.shrink(bezier);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet time2 = getValue(nextMap, \"time\", 0);\n\t\t\t\t\t\t\tlet newColor = Color.fromString(nextMap.light);\n\t\t\t\t\t\t\tlet newColor2 = Color.fromString(nextMap.dark);\n\t\t\t\t\t\t\tlet curve = keyMap.curve;\n\t\t\t\t\t\t\tif (curve) {\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttime = time2;\n\t\t\t\t\t\t\tcolor = newColor;\n\t\t\t\t\t\t\tcolor2 = newColor2;\n\t\t\t\t\t\t\tkeyMap = nextMap;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttimelines.push(timeline);\n\n\t\t\t\t\t} else if (timelineName == \"rgb2\") {\n\t\t\t\t\t\tlet timeline = new RGB2Timeline(frames, frames * 6, slotIndex);\n\n\t\t\t\t\t\tlet keyMap = timelineMap[0];\n\t\t\t\t\t\tlet time = getValue(keyMap, \"time\", 0);\n\t\t\t\t\t\tlet color = Color.fromString(keyMap.light);\n\t\t\t\t\t\tlet color2 = Color.fromString(keyMap.dark);\n\n\t\t\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\t\t\ttimeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);\n\t\t\t\t\t\t\tlet nextMap = timelineMap[frame + 1];\n\t\t\t\t\t\t\tif (!nextMap) {\n\t\t\t\t\t\t\t\ttimeline.shrink(bezier);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet time2 = getValue(nextMap, \"time\", 0);\n\t\t\t\t\t\t\tlet newColor = Color.fromString(nextMap.light);\n\t\t\t\t\t\t\tlet newColor2 = Color.fromString(nextMap.dark);\n\t\t\t\t\t\t\tlet curve = keyMap.curve;\n\t\t\t\t\t\t\tif (curve) {\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttime = time2;\n\t\t\t\t\t\t\tcolor = newColor;\n\t\t\t\t\t\t\tcolor2 = newColor2;\n\t\t\t\t\t\t\tkeyMap = nextMap;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Bone timelines.\n\t\tif (map.bones) {\n\t\t\tfor (let boneName in map.bones) {\n\t\t\t\tlet boneMap = map.bones[boneName];\n\t\t\t\tlet bone = skeletonData.findBone(boneName);\n\t\t\t\tif (!bone) throw new Error(\"Bone not found: \" + boneName);\n\t\t\t\tlet boneIndex = bone.index;\n\t\t\t\tfor (let timelineName in boneMap) {\n\t\t\t\t\tlet timelineMap = boneMap[timelineName];\n\t\t\t\t\tlet frames = timelineMap.length;\n\t\t\t\t\tif (frames == 0) continue;\n\n\t\t\t\t\tif (timelineName === \"rotate\") {\n\t\t\t\t\t\ttimelines.push(readTimeline1(timelineMap, new RotateTimeline(frames, frames, boneIndex), 0, 1));\n\t\t\t\t\t} else if (timelineName === \"translate\") {\n\t\t\t\t\t\tlet timeline = new TranslateTimeline(frames, frames << 1, boneIndex);\n\t\t\t\t\t\ttimelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 0, scale));\n\t\t\t\t\t} else if (timelineName === \"translatex\") {\n\t\t\t\t\t\tlet timeline = new TranslateXTimeline(frames, frames, boneIndex);\n\t\t\t\t\t\ttimelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n\t\t\t\t\t} else if (timelineName === \"translatey\") {\n\t\t\t\t\t\tlet timeline = new TranslateYTimeline(frames, frames, boneIndex);\n\t\t\t\t\t\ttimelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n\t\t\t\t\t} else if (timelineName === \"scale\") {\n\t\t\t\t\t\tlet timeline = new ScaleTimeline(frames, frames << 1, boneIndex);\n\t\t\t\t\t\ttimelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 1, 1));\n\t\t\t\t\t} else if (timelineName === \"scalex\") {\n\t\t\t\t\t\tlet timeline = new ScaleXTimeline(frames, frames, boneIndex);\n\t\t\t\t\t\ttimelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n\t\t\t\t\t} else if (timelineName === \"scaley\") {\n\t\t\t\t\t\tlet timeline = new ScaleYTimeline(frames, frames, boneIndex);\n\t\t\t\t\t\ttimelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n\t\t\t\t\t} else if (timelineName === \"shear\") {\n\t\t\t\t\t\tlet timeline = new ShearTimeline(frames, frames << 1, boneIndex);\n\t\t\t\t\t\ttimelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 0, 1));\n\t\t\t\t\t} else if (timelineName === \"shearx\") {\n\t\t\t\t\t\tlet timeline = new ShearXTimeline(frames, frames, boneIndex);\n\t\t\t\t\t\ttimelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n\t\t\t\t\t} else if (timelineName === \"sheary\") {\n\t\t\t\t\t\tlet timeline = new ShearYTimeline(frames, frames, boneIndex);\n\t\t\t\t\t\ttimelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n\t\t\t\t\t} else if (timelineName === \"inherit\") {\n\t\t\t\t\t\tlet timeline = new InheritTimeline(frames, bone.index);\n\t\t\t\t\t\tfor (let frame = 0; frame < timelineMap.length; frame++) {\n\t\t\t\t\t\t\tlet aFrame = timelineMap[frame];\n\t\t\t\t\t\t\ttimeline.setFrame(frame, getValue(aFrame, \"time\", 0), Utils.enumValue(Inherit, getValue(aFrame, \"inherit\", \"Normal\")));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// IK constraint timelines.\n\t\tif (map.ik) {\n\t\t\tfor (let constraintName in map.ik) {\n\t\t\t\tlet constraintMap = map.ik[constraintName];\n\t\t\t\tlet keyMap = constraintMap[0];\n\t\t\t\tif (!keyMap) continue;\n\n\t\t\t\tlet constraint = skeletonData.findIkConstraint(constraintName);\n\t\t\t\tif (!constraint) throw new Error(\"IK Constraint not found: \" + constraintName);\n\t\t\t\tlet constraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n\t\t\t\tlet timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);\n\n\t\t\t\tlet time = getValue(keyMap, \"time\", 0);\n\t\t\t\tlet mix = getValue(keyMap, \"mix\", 1);\n\t\t\t\tlet softness = getValue(keyMap, \"softness\", 0) * scale;\n\n\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\ttimeline.setFrame(frame, time, mix, softness, getValue(keyMap, \"bendPositive\", true) ? 1 : -1, getValue(keyMap, \"compress\", false), getValue(keyMap, \"stretch\", false));\n\t\t\t\t\tlet nextMap = constraintMap[frame + 1];\n\t\t\t\t\tif (!nextMap) {\n\t\t\t\t\t\ttimeline.shrink(bezier);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet time2 = getValue(nextMap, \"time\", 0);\n\t\t\t\t\tlet mix2 = getValue(nextMap, \"mix\", 1);\n\t\t\t\t\tlet softness2 = getValue(nextMap, \"softness\", 0) * scale;\n\t\t\t\t\tlet curve = keyMap.curve;\n\t\t\t\t\tif (curve) {\n\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);\n\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);\n\t\t\t\t\t}\n\n\t\t\t\t\ttime = time2;\n\t\t\t\t\tmix = mix2;\n\t\t\t\t\tsoftness = softness2;\n\t\t\t\t\tkeyMap = nextMap;\n\t\t\t\t}\n\t\t\t\ttimelines.push(timeline);\n\t\t\t}\n\t\t}\n\n\t\t// Transform constraint timelines.\n\t\tif (map.transform) {\n\t\t\tfor (let constraintName in map.transform) {\n\t\t\t\tlet timelineMap = map.transform[constraintName];\n\t\t\t\tlet keyMap = timelineMap[0];\n\t\t\t\tif (!keyMap) continue;\n\n\t\t\t\tlet constraint = skeletonData.findTransformConstraint(constraintName);\n\t\t\t\tif (!constraint) throw new Error(\"Transform constraint not found: \" + constraintName);\n\t\t\t\tlet constraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n\t\t\t\tlet timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);\n\n\t\t\t\tlet time = getValue(keyMap, \"time\", 0);\n\t\t\t\tlet mixRotate = getValue(keyMap, \"mixRotate\", 1);\n\t\t\t\tlet mixX = getValue(keyMap, \"mixX\", 1);\n\t\t\t\tlet mixY = getValue(keyMap, \"mixY\", mixX);\n\t\t\t\tlet mixScaleX = getValue(keyMap, \"mixScaleX\", 1);\n\t\t\t\tlet mixScaleY = getValue(keyMap, \"mixScaleY\", mixScaleX);\n\t\t\t\tlet mixShearY = getValue(keyMap, \"mixShearY\", 1);\n\n\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\ttimeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n\t\t\t\t\tlet nextMap = timelineMap[frame + 1];\n\t\t\t\t\tif (!nextMap) {\n\t\t\t\t\t\ttimeline.shrink(bezier);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet time2 = getValue(nextMap, \"time\", 0);\n\t\t\t\t\tlet mixRotate2 = getValue(nextMap, \"mixRotate\", 1);\n\t\t\t\t\tlet mixX2 = getValue(nextMap, \"mixX\", 1);\n\t\t\t\t\tlet mixY2 = getValue(nextMap, \"mixY\", mixX2);\n\t\t\t\t\tlet mixScaleX2 = getValue(nextMap, \"mixScaleX\", 1);\n\t\t\t\t\tlet mixScaleY2 = getValue(nextMap, \"mixScaleY\", mixScaleX2);\n\t\t\t\t\tlet mixShearY2 = getValue(nextMap, \"mixShearY\", 1);\n\t\t\t\t\tlet curve = keyMap.curve;\n\t\t\t\t\tif (curve) {\n\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n\t\t\t\t\t}\n\n\t\t\t\t\ttime = time2;\n\t\t\t\t\tmixRotate = mixRotate2;\n\t\t\t\t\tmixX = mixX2;\n\t\t\t\t\tmixY = mixY2;\n\t\t\t\t\tmixScaleX = mixScaleX2;\n\t\t\t\t\tmixScaleY = mixScaleY2;\n\t\t\t\t\tmixScaleX = mixScaleX2;\n\t\t\t\t\tkeyMap = nextMap;\n\t\t\t\t}\n\t\t\t\ttimelines.push(timeline);\n\t\t\t}\n\t\t}\n\n\t\t// Path constraint timelines.\n\t\tif (map.path) {\n\t\t\tfor (let constraintName in map.path) {\n\t\t\t\tlet constraintMap = map.path[constraintName];\n\t\t\t\tlet constraint = skeletonData.findPathConstraint(constraintName);\n\t\t\t\tif (!constraint) throw new Error(\"Path constraint not found: \" + constraintName);\n\t\t\t\tlet constraintIndex = skeletonData.pathConstraints.indexOf(constraint);\n\t\t\t\tfor (let timelineName in constraintMap) {\n\t\t\t\t\tlet timelineMap = constraintMap[timelineName];\n\t\t\t\t\tlet keyMap = timelineMap[0];\n\t\t\t\t\tif (!keyMap) continue;\n\n\t\t\t\t\tlet frames = timelineMap.length;\n\t\t\t\t\tif (timelineName === \"position\") {\n\t\t\t\t\t\tlet timeline = new PathConstraintPositionTimeline(frames, frames, constraintIndex);\n\t\t\t\t\t\ttimelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));\n\t\t\t\t\t} else if (timelineName === \"spacing\") {\n\t\t\t\t\t\tlet timeline = new PathConstraintSpacingTimeline(frames, frames, constraintIndex);\n\t\t\t\t\t\ttimelines.push(readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1));\n\t\t\t\t\t} else if (timelineName === \"mix\") {\n\t\t\t\t\t\tlet timeline = new PathConstraintMixTimeline(frames, frames * 3, constraintIndex);\n\t\t\t\t\t\tlet time = getValue(keyMap, \"time\", 0);\n\t\t\t\t\t\tlet mixRotate = getValue(keyMap, \"mixRotate\", 1);\n\t\t\t\t\t\tlet mixX = getValue(keyMap, \"mixX\", 1);\n\t\t\t\t\t\tlet mixY = getValue(keyMap, \"mixY\", mixX);\n\t\t\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\t\t\ttimeline.setFrame(frame, time, mixRotate, mixX, mixY);\n\t\t\t\t\t\t\tlet nextMap = timelineMap[frame + 1];\n\t\t\t\t\t\t\tif (!nextMap) {\n\t\t\t\t\t\t\t\ttimeline.shrink(bezier);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet time2 = getValue(nextMap, \"time\", 0);\n\t\t\t\t\t\t\tlet mixRotate2 = getValue(nextMap, \"mixRotate\", 1);\n\t\t\t\t\t\t\tlet mixX2 = getValue(nextMap, \"mixX\", 1);\n\t\t\t\t\t\t\tlet mixY2 = getValue(nextMap, \"mixY\", mixX2);\n\t\t\t\t\t\t\tlet curve = keyMap.curve;\n\t\t\t\t\t\t\tif (curve) {\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n\t\t\t\t\t\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttime = time2;\n\t\t\t\t\t\t\tmixRotate = mixRotate2;\n\t\t\t\t\t\t\tmixX = mixX2;\n\t\t\t\t\t\t\tmixY = mixY2;\n\t\t\t\t\t\t\tkeyMap = nextMap;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Physics constraint timelines.\n\t\tif (map.physics) {\n\t\t\tfor (let constraintName in map.physics) {\n\t\t\t\tlet constraintMap = map.physics[constraintName];\n\t\t\t\tlet constraintIndex = -1;\n\t\t\t\tif (constraintName.length > 0) {\n\t\t\t\t\tlet constraint = skeletonData.findPhysicsConstraint(constraintName);\n\t\t\t\t\tif (!constraint) throw new Error(\"Physics constraint not found: \" + constraintName);\n\t\t\t\t\tconstraintIndex = skeletonData.physicsConstraints.indexOf(constraint);\n\t\t\t\t}\n\t\t\t\tfor (let timelineName in constraintMap) {\n\t\t\t\t\tlet timelineMap = constraintMap[timelineName];\n\t\t\t\t\tlet keyMap = timelineMap[0];\n\t\t\t\t\tif (!keyMap) continue;\n\n\t\t\t\t\tlet frames = timelineMap.length;\n\t\t\t\t\tif (timelineName == \"reset\") {\n\t\t\t\t\t\tconst timeline = new PhysicsConstraintResetTimeline(frames, constraintIndex);\n\t\t\t\t\t\tfor (let frame = 0; keyMap != null; keyMap = timelineMap[frame + 1], frame++)\n\t\t\t\t\t\t\ttimeline.setFrame(frame, getValue(keyMap, \"time\", 0));\n\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet timeline;\n\t\t\t\t\tif (timelineName == \"inertia\")\n\t\t\t\t\t\ttimeline = new PhysicsConstraintInertiaTimeline(frames, frames, constraintIndex);\n\t\t\t\t\telse if (timelineName == \"strength\")\n\t\t\t\t\t\ttimeline = new PhysicsConstraintStrengthTimeline(frames, frames, constraintIndex);\n\t\t\t\t\telse if (timelineName == \"damping\")\n\t\t\t\t\t\ttimeline = new PhysicsConstraintDampingTimeline(frames, frames, constraintIndex);\n\t\t\t\t\telse if (timelineName == \"mass\")\n\t\t\t\t\t\ttimeline = new PhysicsConstraintMassTimeline(frames, frames, constraintIndex);\n\t\t\t\t\telse if (timelineName == \"wind\")\n\t\t\t\t\t\ttimeline = new PhysicsConstraintWindTimeline(frames, frames, constraintIndex);\n\t\t\t\t\telse if (timelineName == \"gravity\")\n\t\t\t\t\t\ttimeline = new PhysicsConstraintGravityTimeline(frames, frames, constraintIndex);\n\t\t\t\t\telse if (timelineName == \"mix\") //\n\t\t\t\t\t\ttimeline = new PhysicsConstraintMixTimeline(frames, frames, constraintIndex);\n\t\t\t\t\telse\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttimelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Attachment timelines.\n\t\tif (map.attachments) {\n\t\t\tfor (let attachmentsName in map.attachments) {\n\t\t\t\tlet attachmentsMap = map.attachments[attachmentsName];\n\t\t\t\tlet skin = skeletonData.findSkin(attachmentsName);\n\t\t\t\tif (!skin) throw new Error(\"Skin not found: \" + attachmentsName);\n\t\t\t\tfor (let slotMapName in attachmentsMap) {\n\t\t\t\t\tlet slotMap = attachmentsMap[slotMapName];\n\t\t\t\t\tlet slot = skeletonData.findSlot(slotMapName);\n\t\t\t\t\tif (!slot) throw new Error(\"Slot not found: \" + slotMapName);\n\t\t\t\t\tlet slotIndex = slot.index;\n\t\t\t\t\tfor (let attachmentMapName in slotMap) {\n\t\t\t\t\t\tlet attachmentMap = slotMap[attachmentMapName];\n\t\t\t\t\t\tlet attachment = <VertexAttachment>skin.getAttachment(slotIndex, attachmentMapName);\n\n\t\t\t\t\t\tfor (let timelineMapName in attachmentMap) {\n\t\t\t\t\t\t\tlet timelineMap = attachmentMap[timelineMapName];\n\t\t\t\t\t\t\tlet keyMap = timelineMap[0];\n\t\t\t\t\t\t\tif (!keyMap) continue;\n\n\t\t\t\t\t\t\tif (timelineMapName == \"deform\") {\n\t\t\t\t\t\t\t\tlet weighted = attachment.bones;\n\t\t\t\t\t\t\t\tlet vertices = attachment.vertices;\n\t\t\t\t\t\t\t\tlet deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n\n\t\t\t\t\t\t\t\tlet timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);\n\t\t\t\t\t\t\t\tlet time = getValue(keyMap, \"time\", 0);\n\t\t\t\t\t\t\t\tfor (let frame = 0, bezier = 0; ; frame++) {\n\t\t\t\t\t\t\t\t\tlet deform: NumberArrayLike;\n\t\t\t\t\t\t\t\t\tlet verticesValue: Array<Number> = getValue(keyMap, \"vertices\", null);\n\t\t\t\t\t\t\t\t\tif (!verticesValue)\n\t\t\t\t\t\t\t\t\t\tdeform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tdeform = Utils.newFloatArray(deformLength);\n\t\t\t\t\t\t\t\t\t\tlet start = <number>getValue(keyMap, \"offset\", 0);\n\t\t\t\t\t\t\t\t\t\tUtils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n\t\t\t\t\t\t\t\t\t\tif (scale != 1) {\n\t\t\t\t\t\t\t\t\t\t\tfor (let i = start, n = i + verticesValue.length; i < n; i++)\n\t\t\t\t\t\t\t\t\t\t\t\tdeform[i] *= scale;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!weighted) {\n\t\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < deformLength; i++)\n\t\t\t\t\t\t\t\t\t\t\t\tdeform[i] += vertices[i];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttimeline.setFrame(frame, time, deform);\n\t\t\t\t\t\t\t\t\tlet nextMap = timelineMap[frame + 1];\n\t\t\t\t\t\t\t\t\tif (!nextMap) {\n\t\t\t\t\t\t\t\t\t\ttimeline.shrink(bezier);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet time2 = getValue(nextMap, \"time\", 0);\n\t\t\t\t\t\t\t\t\tlet curve = keyMap.curve;\n\t\t\t\t\t\t\t\t\tif (curve) bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);\n\t\t\t\t\t\t\t\t\ttime = time2;\n\t\t\t\t\t\t\t\t\tkeyMap = nextMap;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\t} else if (timelineMapName == \"sequence\") {\n\t\t\t\t\t\t\t\tlet timeline = new SequenceTimeline(timelineMap.length, slotIndex, attachment as unknown as HasTextureRegion);\n\t\t\t\t\t\t\t\tlet lastDelay = 0;\n\t\t\t\t\t\t\t\tfor (let frame = 0; frame < timelineMap.length; frame++) {\n\t\t\t\t\t\t\t\t\tlet delay = getValue(keyMap, \"delay\", lastDelay);\n\t\t\t\t\t\t\t\t\tlet time = getValue(keyMap, \"time\", 0);\n\t\t\t\t\t\t\t\t\tlet mode = SequenceMode[getValue(keyMap, \"mode\", \"hold\")] as unknown as number;\n\t\t\t\t\t\t\t\t\tlet index = getValue(keyMap, \"index\", 0);\n\t\t\t\t\t\t\t\t\ttimeline.setFrame(frame, time, mode, index, delay);\n\t\t\t\t\t\t\t\t\tlastDelay = delay;\n\t\t\t\t\t\t\t\t\tkeyMap = timelineMap[frame + 1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Draw order timelines.\n\t\tif (map.drawOrder) {\n\t\t\tlet timeline = new DrawOrderTimeline(map.drawOrder.length);\n\t\t\tlet slotCount = skeletonData.slots.length;\n\t\t\tlet frame = 0;\n\t\t\tfor (let i = 0; i < map.drawOrder.length; i++, frame++) {\n\t\t\t\tlet drawOrderMap = map.drawOrder[i];\n\t\t\t\tlet drawOrder: Array<number> | null = null;\n\t\t\t\tlet offsets = getValue(drawOrderMap, \"offsets\", null);\n\t\t\t\tif (offsets) {\n\t\t\t\t\tdrawOrder = Utils.newArray<number>(slotCount, -1);\n\t\t\t\t\tlet unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n\t\t\t\t\tlet originalIndex = 0, unchangedIndex = 0;\n\t\t\t\t\tfor (let ii = 0; ii < offsets.length; ii++) {\n\t\t\t\t\t\tlet offsetMap = offsets[ii];\n\t\t\t\t\t\tlet slot = skeletonData.findSlot(offsetMap.slot);\n\t\t\t\t\t\tif (!slot) throw new Error(\"Slot not found: \" + slot);\n\t\t\t\t\t\tlet slotIndex = slot.index;\n\t\t\t\t\t\t// Collect unchanged items.\n\t\t\t\t\t\twhile (originalIndex != slotIndex)\n\t\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\n\t\t\t\t\t\t// Set changed items.\n\t\t\t\t\t\tdrawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n\t\t\t\t\t}\n\t\t\t\t\t// Collect remaining unchanged items.\n\t\t\t\t\twhile (originalIndex < slotCount)\n\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\n\t\t\t\t\t// Fill in unchanged items.\n\t\t\t\t\tfor (let ii = slotCount - 1; ii >= 0; ii--)\n\t\t\t\t\t\tif (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n\t\t\t\t}\n\t\t\t\ttimeline.setFrame(frame, getValue(drawOrderMap, \"time\", 0), drawOrder);\n\t\t\t}\n\t\t\ttimelines.push(timeline);\n\t\t}\n\n\t\t// Event timelines.\n\t\tif (map.events) {\n\t\t\tlet timeline = new EventTimeline(map.events.length);\n\t\t\tlet frame = 0;\n\t\t\tfor (let i = 0; i < map.events.length; i++, frame++) {\n\t\t\t\tlet eventMap = map.events[i];\n\t\t\t\tlet eventData = skeletonData.findEvent(eventMap.name);\n\t\t\t\tif (!eventData) throw new Error(\"Event not found: \" + eventMap.name);\n\t\t\t\tlet event = new Event(Utils.toSinglePrecision(getValue(eventMap, \"time\", 0)), eventData);\n\t\t\t\tevent.intValue = getValue(eventMap, \"int\", eventData.intValue);\n\t\t\t\tevent.floatValue = getValue(eventMap, \"float\", eventData.floatValue);\n\t\t\t\tevent.stringValue = getValue(eventMap, \"string\", eventData.stringValue);\n\t\t\t\tif (event.data.audioPath) {\n\t\t\t\t\tevent.volume = getValue(eventMap, \"volume\", 1);\n\t\t\t\t\tevent.balance = getValue(eventMap, \"balance\", 0);\n\t\t\t\t}\n\t\t\t\ttimeline.setFrame(frame, event);\n\t\t\t}\n\t\t\ttimelines.push(timeline);\n\t\t}\n\n\t\tlet duration = 0;\n\t\tfor (let i = 0, n = timelines.length; i < n; i++)\n\t\t\tduration = Math.max(duration, timelines[i].getDuration());\n\t\tskeletonData.animations.push(new Animation(name, timelines, duration));\n\t}\n}\n\nclass LinkedMesh {\n\tparent: string; skin: string;\n\tslotIndex: number;\n\tmesh: MeshAttachment;\n\tinheritTimeline: boolean;\n\n\tconstructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\n\t\tthis.mesh = mesh;\n\t\tthis.skin = skin;\n\t\tthis.slotIndex = slotIndex;\n\t\tthis.parent = parent;\n\t\tthis.inheritTimeline = inheritDeform;\n\t}\n}\n\nfunction readTimeline1 (keys: any[], timeline: CurveTimeline1, defaultValue: number, scale: number) {\n\tlet keyMap = keys[0];\n\tlet time = getValue(keyMap, \"time\", 0);\n\tlet value = getValue(keyMap, \"value\", defaultValue) * scale;\n\tlet bezier = 0;\n\tfor (let frame = 0; ; frame++) {\n\t\ttimeline.setFrame(frame, time, value);\n\t\tlet nextMap = keys[frame + 1];\n\t\tif (!nextMap) {\n\t\t\ttimeline.shrink(bezier);\n\t\t\treturn timeline;\n\t\t}\n\t\tlet time2 = getValue(nextMap, \"time\", 0);\n\t\tlet value2 = getValue(nextMap, \"value\", defaultValue) * scale;\n\t\tif (keyMap.curve) bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);\n\t\ttime = time2;\n\t\tvalue = value2;\n\t\tkeyMap = nextMap;\n\t}\n}\n\nfunction readTimeline2 (keys: any[], timeline: CurveTimeline2, name1: string, name2: string, defaultValue: number, scale: number) {\n\tlet keyMap = keys[0];\n\tlet time = getValue(keyMap, \"time\", 0);\n\tlet value1 = getValue(keyMap, name1, defaultValue) * scale;\n\tlet value2 = getValue(keyMap, name2, defaultValue) * scale;\n\tlet bezier = 0;\n\tfor (let frame = 0; ; frame++) {\n\t\ttimeline.setFrame(frame, time, value1, value2);\n\t\tlet nextMap = keys[frame + 1];\n\t\tif (!nextMap) {\n\t\t\ttimeline.shrink(bezier);\n\t\t\treturn timeline;\n\t\t}\n\t\tlet time2 = getValue(nextMap, \"time\", 0);\n\t\tlet nvalue1 = getValue(nextMap, name1, defaultValue) * scale;\n\t\tlet nvalue2 = getValue(nextMap, name2, defaultValue) * scale;\n\t\tlet curve = keyMap.curve;\n\t\tif (curve) {\n\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);\n\t\t\tbezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);\n\t\t}\n\t\ttime = time2;\n\t\tvalue1 = nvalue1;\n\t\tvalue2 = nvalue2;\n\t\tkeyMap = nextMap;\n\t}\n}\n\nfunction readCurve (curve: any, timeline: CurveTimeline, bezier: number, frame: number, value: number, time1: number, time2: number,\n\tvalue1: number, value2: number, scale: number) {\n\tif (curve == \"stepped\") {\n\t\ttimeline.setStepped(frame);\n\t\treturn bezier;\n\t}\n\tlet i = value << 2;\n\tlet cx1 = curve[i];\n\tlet cy1 = curve[i + 1] * scale;\n\tlet cx2 = curve[i + 2];\n\tlet cy2 = curve[i + 3] * scale;\n\ttimeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);\n\treturn bezier + 1;\n}\n\nfunction getValue (map: any, property: string, defaultValue: any) {\n\treturn map[property] !== undefined ? map[property] : defaultValue;\n}\n", "/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\n(() => {\n\tif (typeof Math.fround === \"undefined\") {\n\t\tMath.fround = (function (array) {\n\t\t\treturn function (x: number) {\n\t\t\t\treturn array[0] = x, array[0];\n\t\t\t};\n\t\t})(new Float32Array(1));\n\t}\n})();\n\nexport { }\n", "import {\n\tTexture as SpineTexture,\n\tTextureFilter,\n\tTextureWrap,\n} from \"@esotericsoftware/spine-core\";\nimport * as BABYLON from \"babylonjs\";\n\n/**\n * BabylonJsTexture\n *\n * This class extends the Spine Runtime Texture to store a Babylon.js DynamicTexture.\n * It handles filtering/wrap setup for Spine textures in Babylon.js.\n */\nexport class BabylonJsTexture extends SpineTexture {\n\t/** The actual Babylon.js DynamicTexture object */\n\tpublic texture: BABYLON.DynamicTexture;\n\n\t/**\n\t * @param image - HTMLImageElement or ImageBitmap\n\t * @param scene - The current Babylon.js Scene\n\t * @param premultipliedAlpha - PMA setting from Spine\n\t */\n\tconstructor(\n\t\timage: HTMLImageElement | ImageBitmap,\n\t\tscene: BABYLON.Scene,\n\t) {\n\t\tsuper(image);\n\n\t\t// Retrieve width/height from the image\n\t\tconst width = (image as HTMLImageElement).width ||\n\t\t\t(image as ImageBitmap).width;\n\t\tconst height = (image as HTMLImageElement).height ||\n\t\t\t(image as ImageBitmap).height;\n\n\t\t// Create a new DynamicTexture\n\t\tthis.texture = new BABYLON.DynamicTexture(\n\t\t\t\"spineDynamicTexture\",\n\t\t\t{ width, height },\n\t\t\tscene,\n\t\t\tfalse,\n\t\t);\n\n\t\t// Draw the raw image onto the DynamicTexture\n\t\tconst context = this.texture.getContext();\n\t\tcontext.clearRect(0, 0, width, height);\n\t\tcontext.drawImage(image as CanvasImageSource, 0, 0, width, height);\n\t\tthis.texture.update(false);\n\n\t\t// Indicate that the texture has alpha\n\t\tthis.texture.hasAlpha = true;\n\n\t\t// Handling premultipliedAlpha may require custom blending in Babylon.js.\n\t\t// By default, Babylon.js won't automatically handle premultiplied alpha on DynamicTextures.\n\t\t// Additional logic might be necessary, depending on your exact use case.\n\t}\n\n\t/**\n\t * Called by Spine to set min/mag filter\n\t */\n\tsetFilters(minFilter: TextureFilter, magFilter: TextureFilter) {\n\t\t// Convert Spine filter to Babylon sampling mode\n\t\tconst babylonMinFilter = BabylonJsTexture.toBabylonSamplingMode(minFilter);\n\t\tconst babylonMagFilter = BabylonJsTexture.toBabylonSamplingMode(magFilter);\n\n\t\t// Babylon.js typically uses a single samplingMode for min/mag combined.\n\t\tif (this.texture._texture) {\n\t\t\tthis.texture._texture.samplingMode = babylonMinFilter;\n\t\t}\n\t}\n\n\t/**\n\t * Called by Spine to set wrap mode\n\t */\n\tsetWraps(uWrap: TextureWrap, vWrap: TextureWrap) {\n\t\tthis.texture.wrapU = BabylonJsTexture.toBabylonTextureWrap(uWrap);\n\t\tthis.texture.wrapV = BabylonJsTexture.toBabylonTextureWrap(vWrap);\n\t}\n\n\t/**\n\t * Dispose GPU resources\n\t */\n\tdispose() {\n\t\tthis.texture.dispose();\n\t}\n\n\t/**\n\t * Convert Spine's TextureFilter to Babylon's sampling mode\n\t */\n\tstatic toBabylonSamplingMode(filter: TextureFilter): number {\n\t\tswitch (filter) {\n\t\t\tcase TextureFilter.Linear:\n\t\t\t\treturn BABYLON.Texture.BILINEAR_SAMPLINGMODE;\n\t\t\tcase TextureFilter.MipMap:\n\t\t\tcase TextureFilter.MipMapLinearNearest:\n\t\t\tcase TextureFilter.MipMapNearestLinear:\n\t\t\tcase TextureFilter.MipMapNearestNearest:\n\t\t\t\treturn BABYLON.Texture.TRILINEAR_SAMPLINGMODE;\n\t\t\tcase TextureFilter.Nearest:\n\t\t\t\treturn BABYLON.Texture.NEAREST_SAMPLINGMODE;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unknown texture filter: \" + filter);\n\t\t}\n\t}\n\n\t/**\n\t * Convert Spine's TextureWrap to Babylon's wrap mode\n\t */\n\tstatic toBabylonTextureWrap(wrap: TextureWrap): number {\n\t\tswitch (wrap) {\n\t\t\tcase TextureWrap.ClampToEdge:\n\t\t\t\treturn BABYLON.Texture.CLAMP_ADDRESSMODE;\n\t\t\tcase TextureWrap.MirroredRepeat:\n\t\t\t\treturn BABYLON.Texture.MIRROR_ADDRESSMODE;\n\t\t\tcase TextureWrap.Repeat:\n\t\t\t\treturn BABYLON.Texture.WRAP_ADDRESSMODE;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unknown texture wrap: \" + wrap);\n\t\t}\n\t}\n}\n", "import { AssetManagerBase, Downloader } from \"@esotericsoftware/spine-core\";\nimport * as BABYLON from \"babylonjs\";\nimport { BabylonJsTexture } from \"./BabylonJsTexture.js\";\n\n/**\n * A custom asset manager for loading images and creating BabylonJsTexture for Spine.\n */\nexport class AssetManager extends AssetManagerBase {\n\tconstructor(\n\t\tscene: BABYLON.Scene,\n\t\tpathPrefix: string = \"\",\n\t\tdownloader: Downloader = new Downloader(),\n\t) {\n\t\tsuper(\n\t\t\t(image: HTMLImageElement | ImageBitmap) => {\n\t\t\t\treturn new BabylonJsTexture(image, scene);\n\t\t\t},\n\t\t\tpathPrefix,\n\t\t\tdownloader,\n\t\t);\n\t}\n}\n", "import * as BABYLON from \"babylonjs\";\nimport { BlendMode } from \"@esotericsoftware/spine-core\";\n\n/**\n * MaterialWithTexture\n *\n * A material interface with an optional spineTexture to store the actual Babylon Texture used by Spine.\n */\nexport interface MaterialWithTexture extends BABYLON.Material {\n\tspineTexture?: BABYLON.Texture;\n}\n\n/**\n * MeshBatcher\n *\n * This class handles batching of vertices and indices from multiple Spine slot attachments\n * into a single Babylon Mesh for efficiency. It uses SubMesh to separate different materials\n * (textures, blend modes).\n */\nexport class MeshBatcher {\n\tpublic static MAX_VERTICES = 10920; // Arbitrary example limit\n\n\tprivate _scene: BABYLON.Scene;\n\tpublic mesh: BABYLON.Mesh;\n\n\t// CPU-side buffers\n\tprivate vertices: Float32Array;\n\tprivate colors: Float32Array;\n\tprivate uv: Float32Array;\n\tprivate indices: Uint16Array;\n\n\tprivate vertexCount = 0;\n\tprivate indexCount = 0;\n\n\t// SubMesh grouping\n\tprivate materialGroups: Array<{\n\t\tindexStart: number;\n\t\tindexCount: number;\n\t\tmaterialIndex: number;\n\t}> = [];\n\n\t// Material list\n\tpublic materials: MaterialWithTexture[] = [];\n\n\t// Kinds for vertex data\n\tprivate positionsKind = BABYLON.VertexBuffer.PositionKind;\n\tprivate colorKind = BABYLON.VertexBuffer.ColorKind;\n\tprivate uvKind = BABYLON.VertexBuffer.UVKind;\n\n\t/**\n\t * @param scene - The current Babylon.js Scene\n\t * @param maxVertices - Maximum vertices in the batch\n\t */\n\tconstructor(\n\t\tscene: BABYLON.Scene,\n\t\tmaxVertices: number = MeshBatcher.MAX_VERTICES,\n\t) {\n\t\tthis._scene = scene;\n\n\t\t// Allocate buffers\n\t\tthis.vertices = new Float32Array(maxVertices * 3); // x, y, z\n\t\tthis.colors = new Float32Array(maxVertices * 4); // r, g, b, a\n\t\tthis.uv = new Float32Array(maxVertices * 2); // u, v\n\t\tthis.indices = new Uint16Array(maxVertices * 3);\n\n\t\t// Create Babylon Mesh\n\t\tthis.mesh = new BABYLON.Mesh(\"SpineBatchMesh\", this._scene);\n\t\tthis.mesh.setVerticesData(this.positionsKind, this.vertices, true);\n\t\tthis.mesh.setVerticesData(this.colorKind, this.colors, true, 4);\n\t\tthis.mesh.setVerticesData(this.uvKind, this.uv, true, 2);\n\t\tthis.mesh.setIndices(this.indices, null, true);\n\t}\n\n\t/**\n\t * Clear the batch data.\n\t */\n\tpublic clear() {\n\t\tthis.vertexCount = 0;\n\t\tthis.indexCount = 0;\n\t\tthis.materialGroups = [];\n\t\tthis.mesh.subMeshes = [];\n\t}\n\n\t/**\n\t * Call before batching any slot data.\n\t */\n\tpublic begin() {\n\t\tthis.clear();\n\t}\n\n\t/**\n\t * Check if there's enough space to batch incoming data.\n\t */\n\tpublic canBatch(numVertices: number, numIndices: number) {\n\t\tif (this.vertexCount + numVertices >= this.vertices.length / 3) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.indexCount + numIndices >= this.indices.length) return false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Append vertices & indices from Spine attachments into the batch.\n\t *\n\t * @param vertices - Vertex data in a specific layout\n\t * @param verticesLength - Number of floats in vertices\n\t * @param indices - Triangle indices\n\t * @param indicesLength - Number of indices\n\t * @param z - z offset\n\t */\n\tpublic batch(\n\t\tvertices: ArrayLike<number>,\n\t\tverticesLength: number,\n\t\tindices: ArrayLike<number>,\n\t\tindicesLength: number,\n\t\tz: number = 0,\n\t) {\n\t\tconst baseVertex = this.vertexCount;\n\t\tlet vpos = this.vertexCount * 3;\n\t\tlet cpos = this.vertexCount * 4;\n\t\tlet uvpos = this.vertexCount * 2;\n\n\t\t// Example stride of 9: x, y, z, r, g, b, a, u, v\n\t\tconst stride = 9;\n\n\t\t// Copy vertex data to the local buffers\n\t\tfor (let i = 0; i < verticesLength; i += stride) {\n\t\t\t// position\n\t\t\tthis.vertices[vpos++] = vertices[i + 0]; // x\n\t\t\tthis.vertices[vpos++] = vertices[i + 1]; // y\n\t\t\tthis.vertices[vpos++] = vertices[i + 2]; // z\n\n\t\t\t// color\n\t\t\tthis.colors[cpos++] = vertices[i + 3]; // r\n\t\t\tthis.colors[cpos++] = vertices[i + 4]; // g\n\t\t\tthis.colors[cpos++] = vertices[i + 5]; // b\n\t\t\tthis.colors[cpos++] = vertices[i + 6]; // a\n\n\t\t\t// uv\n\t\t\tthis.uv[uvpos++] = vertices[i + 7]; // u\n\t\t\tthis.uv[uvpos++] = vertices[i + 8]; // v\n\t\t}\n\n\t\t// Copy indices\n\t\tfor (let i = 0; i < indicesLength; i++) {\n\t\t\tthis.indices[this.indexCount + i] = indices[i] + baseVertex;\n\t\t}\n\n\t\tthis.vertexCount += verticesLength / stride;\n\t\tthis.indexCount += indicesLength;\n\t}\n\n\t/**\n\t * Create a subMesh for the latest added triangles with a specified material index.\n\t */\n\tpublic addMaterialGroup(indicesLength: number, materialIndex: number) {\n\t\tconst currentIndexStart = this.indexCount;\n\t\tthis.materialGroups.push({\n\t\t\tindexStart: currentIndexStart,\n\t\t\tindexCount: indicesLength,\n\t\t\tmaterialIndex,\n\t\t});\n\t}\n\n\t/**\n\t * Upload updated buffers to GPU and create subMeshes.\n\t */\n\tpublic end() {\n\t\tthis.mesh.updateVerticesData(this.positionsKind, this.vertices, false);\n\t\tthis.mesh.updateVerticesData(this.colorKind, this.colors, false);\n\t\tthis.mesh.updateVerticesData(this.uvKind, this.uv, false);\n\t\tthis.mesh.updateIndices(this.indices);\n\n\t\tthis.mesh.subMeshes = [];\n\t\tfor (const group of this.materialGroups) {\n\t\t\tconst subMesh = new BABYLON.SubMesh(\n\t\t\t\tgroup.materialIndex,\n\t\t\t\t0,\n\t\t\t\tthis.vertexCount,\n\t\t\t\tgroup.indexStart,\n\t\t\t\tgroup.indexCount,\n\t\t\t\tthis.mesh,\n\t\t\t);\n\t\t\tthis.mesh.subMeshes.push(subMesh);\n\t\t}\n\t}\n\n\t/**\n\t * Dispose mesh and free resources.\n\t */\n\tpublic dispose() {\n\t\tthis.mesh.dispose();\n\t}\n\n\t/**\n\t * Find or create a material index matching the specified texture and blend mode.\n\t * @param slotTexture - The Babylon texture from the Spine slot\n\t * @param slotBlendMode - The Spine blend mode\n\t */\n\tpublic findMaterialIndex(\n\t\tslotTexture: BABYLON.Texture,\n\t\tslotBlendMode: BlendMode,\n\t): number {\n\t\tfor (let i = 0; i < this.materials.length; i++) {\n\t\t\tif (\n\t\t\t\tthis.materials[i].spineTexture === slotTexture &&\n\t\t\t\tthis._isSameBlendMode(this.materials[i], slotBlendMode)\n\t\t\t) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\t// Create new material\n\t\tconst newMaterial = this._createSpineMaterial(slotTexture, slotBlendMode);\n\t\tconst newIndex = this.materials.length;\n\t\tthis.materials.push(newMaterial);\n\n\t\t// Reassign multiMaterial\n\t\tthis.mesh.material = null;\n\t\tconst multiMat = new BABYLON.MultiMaterial(\"SpineMultiMat\", this._scene);\n\t\tmultiMat.subMaterials = this.materials;\n\t\tthis.mesh.material = multiMat;\n\n\t\treturn newIndex;\n\t}\n\n\t/**\n\t * Compare blend mode on an existing material.\n\t */\n\tprivate _isSameBlendMode(mat: MaterialWithTexture, blendMode: BlendMode) {\n\t\t// Checking alphaMode for approximate match.\n\t\t// More advanced logic might be needed for Screen or Multiply in custom shaders.\n\t\tif (\n\t\t\tblendMode === BlendMode.Normal &&\n\t\t\tmat.alphaMode === BABYLON.Engine.ALPHA_COMBINE\n\t\t) return true;\n\t\tif (\n\t\t\tblendMode === BlendMode.Additive &&\n\t\t\tmat.alphaMode === BABYLON.Engine.ALPHA_ADD\n\t\t) return true;\n\t\tif (\n\t\t\tblendMode === BlendMode.Multiply &&\n\t\t\tmat.alphaMode === BABYLON.Engine.ALPHA_MULTIPLY\n\t\t) return true;\n\t\tif (\n\t\t\tblendMode === BlendMode.Screen &&\n\t\t\tmat.alphaMode === BABYLON.Engine.ALPHA_COMBINE\n\t\t) return true;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create a basic Babylon StandardMaterial with the texture and approximate blend mode.\n\t */\n\tprivate _createSpineMaterial(\n\t\ttexture: BABYLON.Texture,\n\t\tblendMode: BlendMode,\n\t): MaterialWithTexture {\n\t\tconst mat = new BABYLON.StandardMaterial(\n\t\t\t\"SpineMaterial\",\n\t\t\tthis._scene,\n\t\t) as MaterialWithTexture;\n\t\tmat.spineTexture = texture;\n\t\t//mat.diffuseTexture = texture;\n\t\t//mat.emissiveTexture = texture; // sometimes used to avoid lighting in basic usage\n\t\t//mat.disableLighting = true;\n\t\tmat.backFaceCulling = false;\n\t\t//mat.useAlphaFromDiffuseTexture = true;\n\n\t\tswitch (blendMode) {\n\t\t\tcase BlendMode.Normal:\n\t\t\t\tmat.alphaMode = BABYLON.Engine.ALPHA_COMBINE;\n\t\t\t\tbreak;\n\t\t\tcase BlendMode.Additive:\n\t\t\t\tmat.alphaMode = BABYLON.Engine.ALPHA_ADD;\n\t\t\t\tbreak;\n\t\t\tcase BlendMode.Multiply:\n\t\t\t\tmat.alphaMode = BABYLON.Engine.ALPHA_MULTIPLY;\n\t\t\t\tbreak;\n\t\t\tcase BlendMode.Screen:\n\t\t\tdefault:\n\t\t\t\t// Babylon does not have a built-in screen blend mode, so a custom shader could be used\n\t\t\t\tmat.alphaMode = BABYLON.Engine.ALPHA_COMBINE;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn mat;\n\t}\n}\n", "import {\n\tAnimationState,\n\tAnimationStateData,\n\tClippingAttachment,\n\tColor,\n\tMeshAttachment,\n\tPhysics,\n\tRegionAttachment,\n\tSkeleton,\n\tSkeletonClipping,\n\tSkeletonData,\n} from \"@esotericsoftware/spine-core\";\nimport * as BABYLON from \"babylonjs\";\nimport { BabylonJsTexture } from \"./BabylonJsTexture.js\";\nimport { MeshBatcher } from \"./MeshBatcher.js\";\n\n/**\n * Configuration interface for creating a SkeletonMesh.\n */\nexport interface SkeletonMeshConfiguration {\n\t/** The SkeletonData loaded from SkeletonJson or SkeletonBinary */\n\tskeletonData: SkeletonData;\n\t/** Whether to enable two-color tint (Tint black) */\n\ttwoColorTint?: boolean;\n}\n\n/**\n * SkeletonMesh\n *\n * This class manages a Spine Skeleton, its AnimationState, and a set of MeshBatchers in Babylon.js.\n * It extends TransformNode so that all MeshBatcher meshes can be parented here.\n */\nexport class SkeletonMesh extends BABYLON.TransformNode {\n\tpublic skeleton: Skeleton;\n\tpublic animationState: AnimationState;\n\n\tprivate _batcherArray: MeshBatcher[] = [];\n\tprivate _nextBatchIndex = 0;\n\n\tprivate _clipper = new SkeletonClipping();\n\tprivate _vertexSize = 9; // Default: x, y, z, r, g, b, a, u, v\n\tprivate _tempColor = new Color();\n\tprivate _tempDarkColor = new Color();\n\n\t/** z-offset between slots (for layering) */\n\tpublic zOffset: number = 0.1;\n\n\t/**\n\t * @param name - TransformNode name\n\t * @param scene - Babylon.js Scene\n\t * @param config - SkeletonMeshConfiguration\n\t */\n\tconstructor(\n\t\tname: string,\n\t\tscene: BABYLON.Scene,\n\t\tconfig: SkeletonMeshConfiguration,\n\t) {\n\t\tsuper(name, scene);\n\t\tthis._scene = scene;\n\n\t\t// Create the Spine Skeleton\n\t\tthis.skeleton = new Skeleton(config.skeletonData);\n\t\tconst animData = new AnimationStateData(config.skeletonData);\n\t\tthis.animationState = new AnimationState(animData);\n\n\t\t// If twoColorTint is needed, increase vertex size accordingly\n\t\tif (config.twoColorTint) {\n\t\t\tthis._vertexSize = 9 + 4; // hypothetical extra space for dark color\n\t\t}\n\t}\n\n\t/**\n\t * Update the Spine skeleton and animation state.\n\t * @param deltaTime - Time in seconds since last update\n\t */\n\tpublic update(deltaTime: number) {\n\t\t// Update animation state\n\t\tthis.animationState.update(deltaTime);\n\t\tthis.animationState.apply(this.skeleton);\n\n\t\t// Update skeleton with physics (Spine 4.1+)\n\t\tthis.skeleton.update(deltaTime);\n\t\tthis.skeleton.updateWorldTransform(Physics.update);\n\n\t\t// Rebatch the geometry\n\t\tthis.updateGeometry();\n\t}\n\n\t/**\n\t * Dispose all batchers and this transform node.\n\t */\n\tpublic dispose() {\n\t\tsuper.dispose();\n\t\tfor (const b of this._batcherArray) {\n\t\t\tb.dispose();\n\t\t}\n\t}\n\n\t/**\n\t * Clear all existing batchers.\n\t */\n\tprivate _clearBatches() {\n\t\tfor (let i = 0; i < this._batcherArray.length; i++) {\n\t\t\tconst batcher = this._batcherArray[i];\n\t\t\tbatcher.clear();\n\t\t\tbatcher.mesh.setEnabled(false);\n\t\t}\n\t\tthis._nextBatchIndex = 0;\n\t}\n\n\t/**\n\t * Get the next available batcher or create a new one.\n\t */\n\tprivate _nextBatcher(): MeshBatcher {\n\t\tif (this._batcherArray.length <= this._nextBatchIndex) {\n\t\t\tconst newBatch = new MeshBatcher(this._scene);\n\t\t\tnewBatch.mesh.parent = this;\n\t\t\tthis._batcherArray.push(newBatch);\n\t\t}\n\t\tconst batch = this._batcherArray[this._nextBatchIndex++];\n\t\tbatch.mesh.setEnabled(true);\n\t\treturn batch;\n\t}\n\n\t/**\n\t * Loop through the skeleton's draw order and feed vertex/index data into a MeshBatcher.\n\t */\n\tprivate updateGeometry() {\n\t\tthis._clearBatches();\n\n\t\tconst drawOrder = this.skeleton.drawOrder;\n\t\tconst clipper = this._clipper;\n\n\t\tlet batch = this._nextBatcher();\n\t\tbatch.begin();\n\n\t\tlet z = 0;\n\t\tconst zOffset = this.zOffset;\n\n\t\tfor (let i = 0, n = drawOrder.length; i < n; i++) {\n\t\t\tconst slot = drawOrder[i];\n\t\t\tif (!slot.bone.active) {\n\t\t\t\tclipper.clipEndWithSlot(slot);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst attachment = slot.getAttachment();\n\t\t\tif (attachment instanceof ClippingAttachment) {\n\t\t\t\tclipper.clipStart(slot, attachment);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet texture: BabylonJsTexture | null = null;\n\t\t\tlet regionTriangles: number[] | null = null;\n\t\t\tlet finalVertices: Float32Array | null = null;\n\t\t\tlet finalVerticesLength = 0;\n\t\t\tlet finalIndices: number[] = [];\n\t\t\tlet finalIndicesLength = 0;\n\n\t\t\t// Handle RegionAttachment\n\t\t\tif (attachment instanceof RegionAttachment) {\n\t\t\t\ttexture = attachment.region?.texture as BabylonJsTexture;\n\t\t\t\tconst vertexCount = 4;\n\t\t\t\tfinalVerticesLength = vertexCount * this._vertexSize;\n\t\t\t\tconst verts = new Float32Array(finalVerticesLength);\n\t\t\t\tattachment.computeWorldVertices(slot, verts, 0, this._vertexSize);\n\n\t\t\t\tregionTriangles = [0, 1, 2, 2, 3, 0];\n\t\t\t\tfinalIndices = regionTriangles;\n\t\t\t\tfinalIndicesLength = regionTriangles.length;\n\t\t\t\tfinalVertices = verts;\n\n\t\t\t\t// Handle MeshAttachment\n\t\t\t} else if (attachment instanceof MeshAttachment) {\n\t\t\t\ttexture = attachment.region?.texture as BabylonJsTexture;\n\t\t\t\tconst mesh = attachment;\n\t\t\t\tconst vertexCount = mesh.worldVerticesLength >> 1;\n\t\t\t\tfinalVerticesLength = vertexCount * this._vertexSize;\n\t\t\t\tconst verts = new Float32Array(finalVerticesLength);\n\t\t\t\tmesh.computeWorldVertices(\n\t\t\t\t\tslot,\n\t\t\t\t\t0,\n\t\t\t\t\tmesh.worldVerticesLength,\n\t\t\t\t\tverts,\n\t\t\t\t\t0,\n\t\t\t\t\tthis._vertexSize,\n\t\t\t\t);\n\n\t\t\t\tregionTriangles = mesh.triangles;\n\t\t\t\tfinalIndices = regionTriangles;\n\t\t\t\tfinalIndicesLength = regionTriangles.length;\n\t\t\t\tfinalVertices = verts;\n\t\t\t} else {\n\t\t\t\tclipper.clipEndWithSlot(slot);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If there's no valid texture, skip\n\t\t\tif (!texture || !finalVertices) {\n\t\t\t\tclipper.clipEndWithSlot(slot);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Calculate final color\n\t\t\tconst skeletonColor = this.skeleton.color;\n\t\t\tconst slotColor = slot.color;\n\t\t\tconst attachmentColor = (attachment as any).color || Color.WHITE;\n\t\t\tconst alpha = skeletonColor.a * slotColor.a * attachmentColor.a;\n\t\t\tthis._tempColor.set(\n\t\t\t\tskeletonColor.r * slotColor.r * attachmentColor.r,\n\t\t\t\tskeletonColor.g * slotColor.g * attachmentColor.g,\n\t\t\t\tskeletonColor.b * slotColor.b * attachmentColor.b,\n\t\t\t\talpha,\n\t\t\t);\n\n\t\t\tif (!slot.darkColor) {\n\t\t\t\tthis._tempDarkColor.set(0, 0, 0, 0);\n\t\t\t} else {\n\t\t\t\tthis._tempDarkColor.set(\n\t\t\t\t\tslot.darkColor.r,\n\t\t\t\t\tslot.darkColor.g,\n\t\t\t\t\tslot.darkColor.b,\n\t\t\t\t\tslot.darkColor.a,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Clipping logic (if clipper is active) can be applied here.\n\t\t\t// This sample omits clipper details.\n\n\t\t\t// Apply color/uv to finalVertices if needed\n\t\t\t// For demonstration, assume the vertex layout is (x, y, z, r, g, b, a, u, v)\n\t\t\t// Two-color extension would require storing dark color as well.\n\t\t\tfor (let v = 2; v < finalVerticesLength; v += this._vertexSize) {\n\t\t\t\tfinalVertices[v + 0] = this._tempColor.r; // r\n\t\t\t\tfinalVertices[v + 1] = this._tempColor.g; // g\n\t\t\t\tfinalVertices[v + 2] = this._tempColor.b; // b\n\t\t\t\tfinalVertices[v + 3] = this._tempColor.a; // a\n\t\t\t\t// Then u, v, etc.\n\t\t\t\t// If twoColorTint is enabled, you would insert dark color in the extra fields.\n\t\t\t}\n\n\t\t\t// Check if we can batch\n\t\t\tif (\n\t\t\t\t!batch.canBatch(\n\t\t\t\t\tfinalVerticesLength / this._vertexSize,\n\t\t\t\t\tfinalIndicesLength,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tbatch.end();\n\t\t\t\tbatch = this._nextBatcher();\n\t\t\t\tbatch.begin();\n\t\t\t}\n\n\t\t\t// Find or create material\n\t\t\tconst matIndex = batch.findMaterialIndex(\n\t\t\t\ttexture.texture,\n\t\t\t\tslot.data.blendMode,\n\t\t\t);\n\t\t\tbatch.addMaterialGroup(finalIndicesLength, matIndex);\n\t\t\tbatch.batch(\n\t\t\t\tfinalVertices,\n\t\t\t\tfinalVerticesLength,\n\t\t\t\tfinalIndices,\n\t\t\t\tfinalIndicesLength,\n\t\t\t\tz,\n\t\t\t);\n\n\t\t\tz += zOffset;\n\t\t\tclipper.clipEndWithSlot(slot);\n\t\t}\n\n\t\tclipper.clipEnd();\n\t\tbatch.end();\n\t}\n}\n"],
  "mappings": "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",
  "names": ["v", "SequenceMode", "MixBlend", "MixDirection", "x", "y", "i", "vertexAttachment", "constraint", "i", "n", "timeline", "EventType", "TextureFilter", "TextureWrap", "page", "Inherit", "s", "PositionMode", "SpacingMode", "RotateMode", "closed", "pathLength", "multiplier", "Physics", "BlendMode", "closed", "AttachmentType", "n", "LinkedMesh", "readTimeline1", "readTimeline2", "timeline", "BABYLON", "BABYLON"]
}
