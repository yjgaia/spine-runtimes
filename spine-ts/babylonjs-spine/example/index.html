<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>BabylonJS Spine 1000 Animations</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Babylon.js library -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <!-- Babylon.js GUI library - for displaying FPS -->
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <!-- Spine integration plugin for Babylon.js (e.g. babylonjs-spine.js) -->
    <script src="../dist/iife/babylonjs-spine.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body,
      html {
        width: 100%;
        height: 100%;
      }
      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <canvas id="renderCanvas"></canvas>
    <script>
      let engine, scene, assetManager;
      let skeletonData; // We'll reuse the loaded SkeletonData
      const skeletonMeshes = []; // Array to store 1,000 Spine Mesh instances

      // Spine file paths
      const baseUrl = "assets/";
      const skeletonFile = "swordsman.json";
      const atlasFile = "swordsman.atlas";
      // You can change 'animationName' to something like "walk" or "attack"
      const animationName = "idle";

      /**
       * Initializes the Babylon engine and the scene.
       */
      function init() {
        const canvas = document.getElementById("renderCanvas");
        engine = new BABYLON.Engine(canvas, true);
        scene = new BABYLON.Scene(engine);

        // Create a basic camera and light
        const camera = new BABYLON.FreeCamera(
          "camera",
          new BABYLON.Vector3(0, 0, -30),
          scene,
        );
        camera.setTarget(BABYLON.Vector3.Zero());

        const light = new BABYLON.HemisphericLight(
          "light",
          new BABYLON.Vector3(0, 1, 0),
          scene,
        );

        // Create an AssetManager for loading Spine assets
        assetManager = new spine.AssetManager(scene, baseUrl);
        assetManager.loadText(skeletonFile);
        assetManager.loadTextureAtlas(atlasFile);

        // Start the render loop
        engine.runRenderLoop(() => {
          // Once loading is complete and skeletonData is not yet created
          if (assetManager.isLoadingComplete() && !skeletonData) {
            // Parse the skeleton data from JSON and Atlas
            skeletonData = createSkeletonData();
            // Create 1,000 Spine animations
            createMultipleSkeletons(1000);
            // Create the FPS overlay
            createFPSUI();
          }

          // Update every SkeletonMesh (Spine animation) in the scene
          for (let i = 0; i < skeletonMeshes.length; i++) {
            skeletonMeshes[i].update(engine.getDeltaTime() / 1000);
          }

          // Render the scene
          scene.render();
        });

        // Handle browser window resizing
        window.addEventListener("resize", () => {
          engine.resize();
        });
      }

      /**
       * Creates SkeletonData from JSON and Atlas files.
       */
      function createSkeletonData() {
        const jsonData = assetManager.require(skeletonFile);
        const atlas = assetManager.require(atlasFile);

        // Create an attachment loader
        const atlasLoader = new spine.AtlasAttachmentLoader(atlas);
        // Create a SkeletonJson parser
        const skeletonJson = new spine.SkeletonJson(atlasLoader);

        // Adjust scale if needed
        skeletonJson.scale = 0.1;

        // Parse and return SkeletonData
        return skeletonJson.readSkeletonData(jsonData);
      }

      /**
       * Creates multiple SkeletonMesh instances and positions them randomly.
       * @param {number} count Number of SkeletonMesh instances to create
       */
      function createMultipleSkeletons(count) {
        for (let i = 0; i < count; i++) {
          // Create a new SkeletonMesh from previously parsed SkeletonData
          const skeletonMesh = new spine.SkeletonMesh(
            "skeleton-" + i,
            scene,
            { skeletonData },
          );

          // Set an animation
          skeletonMesh.animationState.setAnimation(
            0,
            animationName,
            true,
          );

          // Random position between -40~40 (X) and -20~20 (Y)
          skeletonMesh.position.x = getRandomFloat(-40, 40);
          skeletonMesh.position.y = getRandomFloat(-20, 20);

          // Scale down or up as needed
          skeletonMesh.scaling = new BABYLON.Vector3(0.3, 0.3, 0.3);

          // Add to the scene
          scene.addTransformNode(skeletonMesh);

          // Store in an array for updating later
          skeletonMeshes.push(skeletonMesh);
        }
      }

      /**
       * Displays an FPS counter on the screen using Babylon GUI.
       */
      function createFPSUI() {
        const guiTexture = BABYLON.GUI.AdvancedDynamicTexture
          .CreateFullscreenUI("UI");
        const fpsText = new BABYLON.GUI.TextBlock();
        fpsText.text = "FPS: 0";
        fpsText.color = "white";
        fpsText.fontSize = 24;
        fpsText.textHorizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        fpsText.textVerticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        fpsText.left = 20;
        fpsText.top = 20;
        guiTexture.addControl(fpsText);

        // Update the FPS text every frame
        scene.onBeforeRenderObservable.add(() => {
          fpsText.text = "FPS: " + engine.getFps().toFixed(1);
        });
      }

      /**
       * Returns a random float between min and max.
       * @param {number} min Minimum value
       * @param {number} max Maximum value
       * @returns {number} Random float in the range [min, max]
       */
      function getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
      }

      // Entry point
      init();
    </script>
  </body>
</html>
