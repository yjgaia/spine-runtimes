<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
</head>
<!-- Spine WebGL runtime -->
<script src="../dist/iife/spine-webgl.js"></script>
<!-- jQuery for simple DOM manipulation (optional but used in this example) -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
<style>
  * {
    margin: 0;
    padding: 0;
  }
  body,
  html {
    height: 100%;
    background: #333;
  }
  canvas {
    position: absolute;
    width: 100%;
    height: 100%;
  }
  /* Simple overlay for FPS display */
  #fpsCounter {
    color: #fff;
    position: fixed;
    top: 10px;
    left: 10px;
    font: 14px Arial, sans-serif;
    background: rgba(0,0,0,0.4);
    padding: 5px 10px;
    border-radius: 4px;
  }
  /* Simple debug checkbox styling */
  #debugLabel {
    color: #fff;
    position: fixed;
    top: 35px;
    left: 10px;
    font: 14px Arial, sans-serif;
    background: rgba(0,0,0,0.4);
    padding: 5px 10px;
    border-radius: 4px;
    display: inline-block;
  }
</style>
<body>
  <!-- Main render canvas -->
  <canvas id="canvas"></canvas>

  <!-- FPS counter overlay -->
  <div id="fpsCounter">FPS: 0</div>

  <!-- Debug checkbox overlay -->
  <label id="debugLabel">
    Debug: <input type="checkbox" id="debug" />
  </label>

  <script>
    let canvas, ctx;
    let shader, batcher, mvp;
    let skeletonRenderer, assetManager;

    // Debug rendering
    let debugRenderer, shapes, debugShader;

    // Timing & FPS calculation
    let lastFrameTime;
    let fpsSpan;

    // We will store 1,000 swordsman skeleton instances here
    const swordsmen = [];

    // Adjust to your actual swordsman file names if needed
    // (Ensure these files exist in the "assets/" directory.)
    const SKELETON_JSON = "swordsman.json";
    const SKELETON_ATLAS = "swordsman.atlas";

    // Number of skeletons to create
    const NUM_SKELETONS = 1000;

    function init() {
      // Setup references
      canvas = document.getElementById("canvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Simple config object for WebGL
      let config = { alpha: false };
      ctx = new spine.ManagedWebGLRenderingContext(canvas, config);
      if (!ctx.gl) {
        alert('WebGL is unavailable.');
        return;
      }

      // Create the shader, batcher, matrix, skeleton renderer, and asset manager
      shader = spine.Shader.newTwoColoredTextured(ctx);
      batcher = new spine.PolygonBatcher(ctx);
      mvp = new spine.Matrix4();
      mvp.ortho2d(0, 0, canvas.width - 1, canvas.height - 1);
      skeletonRenderer = new spine.SkeletonRenderer(ctx);
      assetManager = new spine.AssetManager(ctx, "assets/");

      // Debug-related objects
      debugRenderer = new spine.SkeletonDebugRenderer(ctx);
      debugRenderer.drawRegionAttachments = true;
      debugRenderer.drawBoundingBoxes = true;
      debugRenderer.drawMeshHull = true;
      debugRenderer.drawMeshTriangles = true;
      debugRenderer.drawPaths = true;
      debugShader = spine.Shader.newColored(ctx);
      shapes = new spine.ShapeRenderer(ctx);

      // Load the swordsman assets
      assetManager.loadText(SKELETON_JSON);
      assetManager.loadTextureAtlas(SKELETON_ATLAS);

      // Prepare for load completion
      requestAnimationFrame(load);
    }

    function load() {
      // Wait until assets are fully loaded
      if (assetManager.isLoadingComplete()) {
        // Create one "template" skeleton from the JSON/Atlas
        const mainSkeletonData = loadSkeleton(SKELETON_JSON, "idle", true);

        // Clone this template multiple times
        for (let i = 0; i < NUM_SKELETONS; i++) {
          swordsmen.push(cloneSkeleton(mainSkeletonData));
        }

        // Set up the initial time for FPS calculation
        lastFrameTime = Date.now() / 1000;

        // Start the main render loop
        requestAnimationFrame(render);
      } else {
        requestAnimationFrame(load);
      }
    }

    /**
     * Loads one swordsman skeleton from JSON and Atlas.
     * @param {string} name - The JSON file name
     * @param {string} initialAnimation - The initial animation to play
     * @param {boolean} premultipliedAlpha - Whether the atlas uses PMA
     * @returns An object containing the skeleton, state, bounds, and PMA info
     */
    function loadSkeleton(name, initialAnimation, premultipliedAlpha) {
      // Retrieve the texture atlas from the AssetManager
      let atlas = assetManager.require(SKELETON_ATLAS);

      // Create an AtlasAttachmentLoader
      let atlasLoader = new spine.AtlasAttachmentLoader(atlas);

      // Decide if the file is JSON or binary. We'll assume JSON here.
      let skeletonLoader = new spine.SkeletonJson(atlasLoader);

      // Parse the skeleton JSON
      skeletonLoader.scale = 1;
      let skeletonData = skeletonLoader.readSkeletonData(assetManager.require(name));
      let skeleton = new spine.Skeleton(skeletonData);

      // Calculate initial bounds
      let bounds = calculateSetupPoseBounds(skeleton);

      // Create AnimationState
      let animationStateData = new spine.AnimationStateData(skeleton.data);
      let animationState = new spine.AnimationState(animationStateData);
      animationState.setAnimation(0, initialAnimation, true);

      return {
        skeleton: skeleton,
        state: animationState,
        bounds: bounds,
        premultipliedAlpha: premultipliedAlpha
      };
    }

    /**
     * Clones the original skeleton data (reusing the same atlas data) to create a new instance.
     * Positions each skeleton randomly for demonstration purposes.
     * @param {object} template - The main skeleton object
     * @returns {object} A new instance with separate skeleton and state, plus random positions
     */
    function cloneSkeleton(template) {
      // Create a new Skeleton from the same skeletonData
      let newSkeleton = new spine.Skeleton(template.skeleton.data);
      newSkeleton.setToSetupPose();
      newSkeleton.updateWorldTransform(spine.Physics.update);

      // Create a new AnimationState
      let newStateData = new spine.AnimationStateData(newSkeleton.data);
      let newState = new spine.AnimationState(newStateData);

      // Copy the original animation setup
      // (We can copy existing tracks or just set from scratch)
      const track0 = template.state.tracks[0];
      if (track0) {
        newState.setAnimation(0, track0.animation.name, true);
      }

      // Random position within the canvas area
      // Let's place them within some portion of the screen (e.g., 0.2 to 0.8 of width/height)
      let rndX = Math.random() * canvas.width * 0.6 + canvas.width * 0.2;
      let rndY = Math.random() * canvas.height * 0.6 + canvas.height * 0.2;

      // Return a new object containing the new skeleton and state, plus random transform
      return {
        skeleton: newSkeleton,
        state: newState,
        premultipliedAlpha: template.premultipliedAlpha,
        x: rndX,
        y: rndY
      };
    }

    /**
     * Calculates setup pose bounds for centering or sizing logic if needed.
     */
    function calculateSetupPoseBounds(skeleton) {
      skeleton.setToSetupPose();
      skeleton.updateWorldTransform(spine.Physics.update);
      let offset = new spine.Vector2();
      let size = new spine.Vector2();
      skeleton.getBounds(offset, size, []);
      return { offset: offset, size: size };
    }

    /**
     * Main render loop.
     */
    function render() {
      let gl = ctx.gl;
      let now = Date.now() / 1000;
      let delta = now - lastFrameTime;
      lastFrameTime = now;

      // Calculate and display FPS
      let fps = (1 / delta).toFixed(1);
      document.getElementById("fpsCounter").innerText = `FPS: ${fps}`;

      resizeCanvasAndUpdateMVP();

      // Clear the background
      gl.clearColor(0.3, 0.3, 0.3, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      // Render each swordsman
      shader.bind();
      shader.setUniformi(spine.Shader.SAMPLER, 0);
      shader.setUniform4x4f(spine.Shader.MVP_MATRIX, mvp.values);

      batcher.begin(shader);

      // For each skeleton instance, update and draw
      swordsmen.forEach((instance) => {
        // Update animation
        instance.state.update(delta);
        instance.state.apply(instance.skeleton);
        instance.skeleton.updateWorldTransform(spine.Physics.update);

        // Position the skeleton (translation)
        // We'll do a simple approach: move the skeleton by adjusting bone 0 or using offset.
        // For simplicity, let's transform by setting skeleton.x / y. 
        // The spine-webgl Skeleton doesn't have built-in x/y, so let's temporarily move all bones.

        // Move the entire skeleton by adjusting the root bone's world position
        let rootBone = instance.skeleton.bones[0];
        rootBone.x = instance.x;
        rootBone.y = instance.y;
        rootBone.rotation = 0; // If you want random rotation, set it here.

        // Re-update transforms after moving root
        instance.skeleton.updateWorldTransform(spine.Physics.update);

        // Let the skeletonRenderer know if it should use premultiplied alpha
        skeletonRenderer.premultipliedAlpha = instance.premultipliedAlpha;
        // Draw
        skeletonRenderer.draw(batcher, instance.skeleton);
      });

      batcher.end();
      shader.unbind();

      // Debug rendering if checked
      if ($("#debug").is(":checked")) {
        debugShader.bind();
        debugShader.setUniform4x4f(spine.Shader.MVP_MATRIX, mvp.values);
        shapes.begin(debugShader);
        swordsmen.forEach((instance) => {
          debugRenderer.premultipliedAlpha = instance.premultipliedAlpha;
          debugRenderer.draw(shapes, instance.skeleton);
        });
        shapes.end();
        debugShader.unbind();
      }

      // Request next frame
      requestAnimationFrame(render);
    }

    /**
     * Adjusts the canvas size to match the client size and updates the orthographic projection (mvp).
     */
    function resizeCanvasAndUpdateMVP() {
      let w = canvas.clientWidth;
      let h = canvas.clientHeight;
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
      // Keep it simple: Just set an ortho that matches the entire canvas
      mvp.ortho2d(0, 0, canvas.width, canvas.height);
      ctx.gl.viewport(0, 0, canvas.width, canvas.height);
    }

    // Initialize everything
    init();
  </script>
</body>
</html>
